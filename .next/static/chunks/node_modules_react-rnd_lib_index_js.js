/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_react-rnd_lib_index_js"],{

/***/ "./node_modules/clsx/dist/clsx.m.js":
/*!******************************************!*\
  !*** ./node_modules/clsx/dist/clsx.m.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"clsx\": function() { return /* binding */ clsx; }\n/* harmony export */ });\nfunction r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f);else for(t in e)e[t]&&(n&&(n+=\" \"),n+=t);return n}function clsx(){for(var e,t,f=0,n=\"\";f<arguments.length;)(e=arguments[f++])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}/* harmony default export */ __webpack_exports__[\"default\"] = (clsx);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2xzeC9kaXN0L2Nsc3gubS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsY0FBYyxhQUFhLCtDQUErQyx1REFBdUQsV0FBVywwQ0FBMEMseUNBQXlDLFNBQWdCLGdCQUFnQixxQkFBcUIsbUJBQW1CLGtEQUFrRCxTQUFTLCtEQUFlLElBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Nsc3gvZGlzdC9jbHN4Lm0uanM/NzdhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiByKGUpe3ZhciB0LGYsbj1cIlwiO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlfHxcIm51bWJlclwiPT10eXBlb2YgZSluKz1lO2Vsc2UgaWYoXCJvYmplY3RcIj09dHlwZW9mIGUpaWYoQXJyYXkuaXNBcnJheShlKSlmb3IodD0wO3Q8ZS5sZW5ndGg7dCsrKWVbdF0mJihmPXIoZVt0XSkpJiYobiYmKG4rPVwiIFwiKSxuKz1mKTtlbHNlIGZvcih0IGluIGUpZVt0XSYmKG4mJihuKz1cIiBcIiksbis9dCk7cmV0dXJuIG59ZXhwb3J0IGZ1bmN0aW9uIGNsc3goKXtmb3IodmFyIGUsdCxmPTAsbj1cIlwiO2Y8YXJndW1lbnRzLmxlbmd0aDspKGU9YXJndW1lbnRzW2YrK10pJiYodD1yKGUpKSYmKG4mJihuKz1cIiBcIiksbis9dCk7cmV0dXJuIG59ZXhwb3J0IGRlZmF1bHQgY2xzeDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/clsx/dist/clsx.m.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/object-assign.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/object-assign.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar assign = Object.assign.bind(Object);\nmodule.exports = assign;\nmodule.exports[\"default\"] = module.exports;\n\n//# sourceMappingURL=object-assign.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9vYmplY3QtYXNzaWduLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLHlCQUFzQjs7QUFFdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC9wb2x5ZmlsbHMvb2JqZWN0LWFzc2lnbi5qcz9lN2QxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24uYmluZChPYmplY3QpO1xubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ247XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9iamVjdC1hc3NpZ24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/polyfills/object-assign.js\n"));

/***/ }),

/***/ "./node_modules/react-rnd/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/react-rnd/lib/index.js ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Rnd\": function() { return /* binding */ Rnd; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_draggable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-draggable */ \"./node_modules/react-draggable/build/cjs/cjs.js\");\n/* harmony import */ var react_draggable__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_draggable__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var re_resizable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! re-resizable */ \"./node_modules/re-resizable/lib/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */ /* global Reflect, Promise */ var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || ({\n        __proto__: []\n    }) instanceof Array && function(d, b) {\n        d.__proto__ = b;\n    } || function(d, b) {\n        for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n    extendStatics(d, b);\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nfunction __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nvar resizableStyle = {\n    width: \"auto\",\n    height: \"auto\",\n    display: \"inline-block\",\n    position: \"absolute\",\n    top: 0,\n    left: 0\n};\nvar getEnableResizingByFlag = function(flag) {\n    return {\n        bottom: flag,\n        bottomLeft: flag,\n        bottomRight: flag,\n        left: flag,\n        right: flag,\n        top: flag,\n        topLeft: flag,\n        topRight: flag\n    };\n};\nvar Rnd = /** @class */ function(_super) {\n    __extends(Rnd, _super);\n    function Rnd(props) {\n        var _this = _super.call(this, props) || this;\n        _this.resizingPosition = {\n            x: 0,\n            y: 0\n        };\n        _this.offsetFromParent = {\n            left: 0,\n            top: 0\n        };\n        _this.resizableElement = {\n            current: null\n        };\n        _this.originalPosition = {\n            x: 0,\n            y: 0\n        };\n        _this.state = {\n            resizing: false,\n            bounds: {\n                top: 0,\n                right: 0,\n                bottom: 0,\n                left: 0\n            },\n            maxWidth: props.maxWidth,\n            maxHeight: props.maxHeight\n        };\n        _this.onResizeStart = _this.onResizeStart.bind(_this);\n        _this.onResize = _this.onResize.bind(_this);\n        _this.onResizeStop = _this.onResizeStop.bind(_this);\n        _this.onDragStart = _this.onDragStart.bind(_this);\n        _this.onDrag = _this.onDrag.bind(_this);\n        _this.onDragStop = _this.onDragStop.bind(_this);\n        _this.getMaxSizesFromProps = _this.getMaxSizesFromProps.bind(_this);\n        return _this;\n    }\n    Rnd.prototype.componentDidMount = function() {\n        this.updateOffsetFromParent();\n        var _a = this.offsetFromParent, left = _a.left, top = _a.top;\n        var _b = this.getDraggablePosition(), x = _b.x, y = _b.y;\n        this.draggable.setState({\n            x: x - left,\n            y: y - top\n        });\n        // HACK: Apply position adjustment\n        this.forceUpdate();\n    };\n    // HACK: To get `react-draggable` state x and y.\n    Rnd.prototype.getDraggablePosition = function() {\n        var _a = this.draggable.state, x = _a.x, y = _a.y;\n        return {\n            x: x,\n            y: y\n        };\n    };\n    Rnd.prototype.getParent = function() {\n        return this.resizable && this.resizable.parentNode;\n    };\n    Rnd.prototype.getParentSize = function() {\n        return this.resizable.getParentSize();\n    };\n    Rnd.prototype.getMaxSizesFromProps = function() {\n        var maxWidth = typeof this.props.maxWidth === \"undefined\" ? Number.MAX_SAFE_INTEGER : this.props.maxWidth;\n        var maxHeight = typeof this.props.maxHeight === \"undefined\" ? Number.MAX_SAFE_INTEGER : this.props.maxHeight;\n        return {\n            maxWidth: maxWidth,\n            maxHeight: maxHeight\n        };\n    };\n    Rnd.prototype.getSelfElement = function() {\n        return this.resizable && this.resizable.resizable;\n    };\n    Rnd.prototype.getOffsetHeight = function(boundary) {\n        var scale = this.props.scale;\n        switch(this.props.bounds){\n            case \"window\":\n                return window.innerHeight / scale;\n            case \"body\":\n                return document.body.offsetHeight / scale;\n            default:\n                return boundary.offsetHeight;\n        }\n    };\n    Rnd.prototype.getOffsetWidth = function(boundary) {\n        var scale = this.props.scale;\n        switch(this.props.bounds){\n            case \"window\":\n                return window.innerWidth / scale;\n            case \"body\":\n                return document.body.offsetWidth / scale;\n            default:\n                return boundary.offsetWidth;\n        }\n    };\n    Rnd.prototype.onDragStart = function(e, data) {\n        if (this.props.onDragStart) {\n            this.props.onDragStart(e, data);\n        }\n        var pos = this.getDraggablePosition();\n        this.originalPosition = pos;\n        if (!this.props.bounds) return;\n        var parent = this.getParent();\n        var scale = this.props.scale;\n        var boundary;\n        if (this.props.bounds === \"parent\") {\n            boundary = parent;\n        } else if (this.props.bounds === \"body\") {\n            var parentRect_1 = parent.getBoundingClientRect();\n            var parentLeft_1 = parentRect_1.left;\n            var parentTop_1 = parentRect_1.top;\n            var bodyRect = document.body.getBoundingClientRect();\n            var left_1 = -(parentLeft_1 - parent.offsetLeft * scale - bodyRect.left) / scale;\n            var top_1 = -(parentTop_1 - parent.offsetTop * scale - bodyRect.top) / scale;\n            var right = (document.body.offsetWidth - this.resizable.size.width * scale) / scale + left_1;\n            var bottom = (document.body.offsetHeight - this.resizable.size.height * scale) / scale + top_1;\n            return this.setState({\n                bounds: {\n                    top: top_1,\n                    right: right,\n                    bottom: bottom,\n                    left: left_1\n                }\n            });\n        } else if (this.props.bounds === \"window\") {\n            if (!this.resizable) return;\n            var parentRect_2 = parent.getBoundingClientRect();\n            var parentLeft_2 = parentRect_2.left;\n            var parentTop_2 = parentRect_2.top;\n            var left_2 = -(parentLeft_2 - parent.offsetLeft * scale) / scale;\n            var top_2 = -(parentTop_2 - parent.offsetTop * scale) / scale;\n            var right = (window.innerWidth - this.resizable.size.width * scale) / scale + left_2;\n            var bottom = (window.innerHeight - this.resizable.size.height * scale) / scale + top_2;\n            return this.setState({\n                bounds: {\n                    top: top_2,\n                    right: right,\n                    bottom: bottom,\n                    left: left_2\n                }\n            });\n        } else if (typeof this.props.bounds === \"string\") {\n            boundary = document.querySelector(this.props.bounds);\n        } else if (this.props.bounds instanceof HTMLElement) {\n            boundary = this.props.bounds;\n        }\n        if (!(boundary instanceof HTMLElement) || !(parent instanceof HTMLElement)) {\n            return;\n        }\n        var boundaryRect = boundary.getBoundingClientRect();\n        var boundaryLeft = boundaryRect.left;\n        var boundaryTop = boundaryRect.top;\n        var parentRect = parent.getBoundingClientRect();\n        var parentLeft = parentRect.left;\n        var parentTop = parentRect.top;\n        var left = (boundaryLeft - parentLeft) / scale;\n        var top = boundaryTop - parentTop;\n        if (!this.resizable) return;\n        this.updateOffsetFromParent();\n        var offset = this.offsetFromParent;\n        this.setState({\n            bounds: {\n                top: top - offset.top,\n                right: left + (boundary.offsetWidth - this.resizable.size.width) - offset.left / scale,\n                bottom: top + (boundary.offsetHeight - this.resizable.size.height) - offset.top,\n                left: left - offset.left / scale\n            }\n        });\n    };\n    Rnd.prototype.onDrag = function(e, data) {\n        if (!this.props.onDrag) return;\n        var _a = this.offsetFromParent, left = _a.left, top = _a.top;\n        if (!this.props.dragAxis || this.props.dragAxis === \"both\") {\n            return this.props.onDrag(e, __assign(__assign({}, data), {\n                x: data.x + left,\n                y: data.y + top\n            }));\n        } else if (this.props.dragAxis === \"x\") {\n            return this.props.onDrag(e, __assign(__assign({}, data), {\n                x: data.x + left,\n                y: this.originalPosition.y + top,\n                deltaY: 0\n            }));\n        } else if (this.props.dragAxis === \"y\") {\n            return this.props.onDrag(e, __assign(__assign({}, data), {\n                x: this.originalPosition.x + left,\n                y: data.y + top,\n                deltaX: 0\n            }));\n        }\n    };\n    Rnd.prototype.onDragStop = function(e, data) {\n        if (!this.props.onDragStop) return;\n        var _a = this.offsetFromParent, left = _a.left, top = _a.top;\n        if (!this.props.dragAxis || this.props.dragAxis === \"both\") {\n            return this.props.onDragStop(e, __assign(__assign({}, data), {\n                x: data.x + left,\n                y: data.y + top\n            }));\n        } else if (this.props.dragAxis === \"x\") {\n            return this.props.onDragStop(e, __assign(__assign({}, data), {\n                x: data.x + left,\n                y: this.originalPosition.y + top,\n                deltaY: 0\n            }));\n        } else if (this.props.dragAxis === \"y\") {\n            return this.props.onDragStop(e, __assign(__assign({}, data), {\n                x: this.originalPosition.x + left,\n                y: data.y + top,\n                deltaX: 0\n            }));\n        }\n    };\n    Rnd.prototype.onResizeStart = function(e, dir, elementRef) {\n        e.stopPropagation();\n        this.setState({\n            resizing: true\n        });\n        var scale = this.props.scale;\n        var offset = this.offsetFromParent;\n        var pos = this.getDraggablePosition();\n        this.resizingPosition = {\n            x: pos.x + offset.left,\n            y: pos.y + offset.top\n        };\n        this.originalPosition = pos;\n        if (this.props.bounds) {\n            var parent_1 = this.getParent();\n            var boundary = void 0;\n            if (this.props.bounds === \"parent\") {\n                boundary = parent_1;\n            } else if (this.props.bounds === \"body\") {\n                boundary = document.body;\n            } else if (this.props.bounds === \"window\") {\n                boundary = window;\n            } else if (typeof this.props.bounds === \"string\") {\n                boundary = document.querySelector(this.props.bounds);\n            } else if (this.props.bounds instanceof HTMLElement) {\n                boundary = this.props.bounds;\n            }\n            var self_1 = this.getSelfElement();\n            if (self_1 instanceof Element && (boundary instanceof HTMLElement || boundary === window) && parent_1 instanceof HTMLElement) {\n                var _a = this.getMaxSizesFromProps(), maxWidth = _a.maxWidth, maxHeight = _a.maxHeight;\n                var parentSize = this.getParentSize();\n                if (maxWidth && typeof maxWidth === \"string\") {\n                    if (maxWidth.endsWith(\"%\")) {\n                        var ratio = Number(maxWidth.replace(\"%\", \"\")) / 100;\n                        maxWidth = parentSize.width * ratio;\n                    } else if (maxWidth.endsWith(\"px\")) {\n                        maxWidth = Number(maxWidth.replace(\"px\", \"\"));\n                    }\n                }\n                if (maxHeight && typeof maxHeight === \"string\") {\n                    if (maxHeight.endsWith(\"%\")) {\n                        var ratio = Number(maxHeight.replace(\"%\", \"\")) / 100;\n                        maxHeight = parentSize.height * ratio;\n                    } else if (maxHeight.endsWith(\"px\")) {\n                        maxHeight = Number(maxHeight.replace(\"px\", \"\"));\n                    }\n                }\n                var selfRect = self_1.getBoundingClientRect();\n                var selfLeft = selfRect.left;\n                var selfTop = selfRect.top;\n                var boundaryRect = this.props.bounds === \"window\" ? {\n                    left: 0,\n                    top: 0\n                } : boundary.getBoundingClientRect();\n                var boundaryLeft = boundaryRect.left;\n                var boundaryTop = boundaryRect.top;\n                var offsetWidth = this.getOffsetWidth(boundary);\n                var offsetHeight = this.getOffsetHeight(boundary);\n                var hasLeft = dir.toLowerCase().endsWith(\"left\");\n                var hasRight = dir.toLowerCase().endsWith(\"right\");\n                var hasTop = dir.startsWith(\"top\");\n                var hasBottom = dir.startsWith(\"bottom\");\n                if ((hasLeft || hasTop) && this.resizable) {\n                    var max = (selfLeft - boundaryLeft) / scale + this.resizable.size.width;\n                    this.setState({\n                        maxWidth: max > Number(maxWidth) ? maxWidth : max\n                    });\n                }\n                // INFO: To set bounds in `lock aspect ratio with bounds` case. See also that story.\n                if (hasRight || this.props.lockAspectRatio && !hasLeft && !hasTop) {\n                    var max = offsetWidth + (boundaryLeft - selfLeft) / scale;\n                    this.setState({\n                        maxWidth: max > Number(maxWidth) ? maxWidth : max\n                    });\n                }\n                if ((hasTop || hasLeft) && this.resizable) {\n                    var max = (selfTop - boundaryTop) / scale + this.resizable.size.height;\n                    this.setState({\n                        maxHeight: max > Number(maxHeight) ? maxHeight : max\n                    });\n                }\n                // INFO: To set bounds in `lock aspect ratio with bounds` case. See also that story.\n                if (hasBottom || this.props.lockAspectRatio && !hasTop && !hasLeft) {\n                    var max = offsetHeight + (boundaryTop - selfTop) / scale;\n                    this.setState({\n                        maxHeight: max > Number(maxHeight) ? maxHeight : max\n                    });\n                }\n            }\n        } else {\n            this.setState({\n                maxWidth: this.props.maxWidth,\n                maxHeight: this.props.maxHeight\n            });\n        }\n        if (this.props.onResizeStart) {\n            this.props.onResizeStart(e, dir, elementRef);\n        }\n    };\n    Rnd.prototype.onResize = function(e, direction, elementRef, delta) {\n        var _this = this;\n        // INFO: Apply x and y position adjustments caused by resizing to draggable\n        var newPos = {\n            x: this.originalPosition.x,\n            y: this.originalPosition.y\n        };\n        var left = -delta.width;\n        var top = -delta.height;\n        var directions = [\n            \"top\",\n            \"left\",\n            \"topLeft\",\n            \"bottomLeft\",\n            \"topRight\"\n        ];\n        if (directions.includes(direction)) {\n            if (direction === \"bottomLeft\") {\n                newPos.x += left;\n            } else if (direction === \"topRight\") {\n                newPos.y += top;\n            } else {\n                newPos.x += left;\n                newPos.y += top;\n            }\n        }\n        var draggableState = this.draggable.state;\n        if (newPos.x !== draggableState.x || newPos.y !== draggableState.y) {\n            (0,react_dom__WEBPACK_IMPORTED_MODULE_3__.flushSync)(function() {\n                _this.draggable.setState(newPos);\n            });\n        }\n        this.updateOffsetFromParent();\n        var offset = this.offsetFromParent;\n        var x = this.getDraggablePosition().x + offset.left;\n        var y = this.getDraggablePosition().y + offset.top;\n        this.resizingPosition = {\n            x: x,\n            y: y\n        };\n        if (!this.props.onResize) return;\n        this.props.onResize(e, direction, elementRef, delta, {\n            x: x,\n            y: y\n        });\n    };\n    Rnd.prototype.onResizeStop = function(e, direction, elementRef, delta) {\n        this.setState({\n            resizing: false\n        });\n        var _a = this.getMaxSizesFromProps(), maxWidth = _a.maxWidth, maxHeight = _a.maxHeight;\n        this.setState({\n            maxWidth: maxWidth,\n            maxHeight: maxHeight\n        });\n        if (this.props.onResizeStop) {\n            this.props.onResizeStop(e, direction, elementRef, delta, this.resizingPosition);\n        }\n    };\n    Rnd.prototype.updateSize = function(size) {\n        if (!this.resizable) return;\n        this.resizable.updateSize({\n            width: size.width,\n            height: size.height\n        });\n    };\n    Rnd.prototype.updatePosition = function(position) {\n        this.draggable.setState(position);\n    };\n    Rnd.prototype.updateOffsetFromParent = function() {\n        var scale = this.props.scale;\n        var parent = this.getParent();\n        var self = this.getSelfElement();\n        if (!parent || self === null) {\n            return {\n                top: 0,\n                left: 0\n            };\n        }\n        var parentRect = parent.getBoundingClientRect();\n        var parentLeft = parentRect.left;\n        var parentTop = parentRect.top;\n        var selfRect = self.getBoundingClientRect();\n        var position = this.getDraggablePosition();\n        var scrollLeft = parent.scrollLeft;\n        var scrollTop = parent.scrollTop;\n        this.offsetFromParent = {\n            left: selfRect.left - parentLeft + scrollLeft - position.x * scale,\n            top: selfRect.top - parentTop + scrollTop - position.y * scale\n        };\n    };\n    Rnd.prototype.render = function() {\n        var _this = this;\n        var _a = this.props, disableDragging = _a.disableDragging, style = _a.style, dragHandleClassName = _a.dragHandleClassName, position = _a.position, onMouseDown = _a.onMouseDown, onMouseUp = _a.onMouseUp, dragAxis = _a.dragAxis, dragGrid = _a.dragGrid, bounds = _a.bounds, enableUserSelectHack = _a.enableUserSelectHack, cancel = _a.cancel, children = _a.children, onResizeStart = _a.onResizeStart, onResize = _a.onResize, onResizeStop = _a.onResizeStop, onDragStart = _a.onDragStart, onDrag = _a.onDrag, onDragStop = _a.onDragStop, resizeHandleStyles = _a.resizeHandleStyles, resizeHandleClasses = _a.resizeHandleClasses, resizeHandleComponent = _a.resizeHandleComponent, enableResizing = _a.enableResizing, resizeGrid = _a.resizeGrid, resizeHandleWrapperClass = _a.resizeHandleWrapperClass, resizeHandleWrapperStyle = _a.resizeHandleWrapperStyle, scale = _a.scale, allowAnyClick = _a.allowAnyClick, dragPositionOffset = _a.dragPositionOffset, resizableProps = __rest(_a, [\n            \"disableDragging\",\n            \"style\",\n            \"dragHandleClassName\",\n            \"position\",\n            \"onMouseDown\",\n            \"onMouseUp\",\n            \"dragAxis\",\n            \"dragGrid\",\n            \"bounds\",\n            \"enableUserSelectHack\",\n            \"cancel\",\n            \"children\",\n            \"onResizeStart\",\n            \"onResize\",\n            \"onResizeStop\",\n            \"onDragStart\",\n            \"onDrag\",\n            \"onDragStop\",\n            \"resizeHandleStyles\",\n            \"resizeHandleClasses\",\n            \"resizeHandleComponent\",\n            \"enableResizing\",\n            \"resizeGrid\",\n            \"resizeHandleWrapperClass\",\n            \"resizeHandleWrapperStyle\",\n            \"scale\",\n            \"allowAnyClick\",\n            \"dragPositionOffset\"\n        ]);\n        var defaultValue = this.props.default ? __assign({}, this.props.default) : undefined;\n        // Remove unknown props, see also https://reactjs.org/warnings/unknown-prop.html\n        delete resizableProps.default;\n        var cursorStyle = disableDragging || dragHandleClassName ? {\n            cursor: \"auto\"\n        } : {\n            cursor: \"move\"\n        };\n        var innerStyle = __assign(__assign(__assign({}, resizableStyle), cursorStyle), style);\n        var _b = this.offsetFromParent, left = _b.left, top = _b.top;\n        var draggablePosition;\n        if (position) {\n            draggablePosition = {\n                x: position.x - left,\n                y: position.y - top\n            };\n        }\n        // INFO: Make uncontorolled component when resizing to control position by setPostion.\n        var pos = this.state.resizing ? undefined : draggablePosition;\n        var dragAxisOrUndefined = this.state.resizing ? \"both\" : dragAxis;\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)((react_draggable__WEBPACK_IMPORTED_MODULE_1___default()), {\n            ref: function(c) {\n                if (!c) return;\n                _this.draggable = c;\n            },\n            handle: dragHandleClassName ? \".\".concat(dragHandleClassName) : undefined,\n            defaultPosition: defaultValue,\n            onMouseDown: onMouseDown,\n            // @ts-expect-error\n            onMouseUp: onMouseUp,\n            onStart: this.onDragStart,\n            onDrag: this.onDrag,\n            onStop: this.onDragStop,\n            axis: dragAxisOrUndefined,\n            disabled: disableDragging,\n            grid: dragGrid,\n            bounds: bounds ? this.state.bounds : undefined,\n            position: pos,\n            enableUserSelectHack: enableUserSelectHack,\n            cancel: cancel,\n            scale: scale,\n            allowAnyClick: allowAnyClick,\n            nodeRef: this.resizableElement,\n            positionOffset: dragPositionOffset\n        }, /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(re_resizable__WEBPACK_IMPORTED_MODULE_2__.Resizable, __assign({}, resizableProps, {\n            ref: function(c) {\n                if (!c) return;\n                _this.resizable = c;\n                _this.resizableElement.current = c.resizable;\n            },\n            defaultSize: defaultValue,\n            size: this.props.size,\n            enable: typeof enableResizing === \"boolean\" ? getEnableResizingByFlag(enableResizing) : enableResizing,\n            onResizeStart: this.onResizeStart,\n            onResize: this.onResize,\n            onResizeStop: this.onResizeStop,\n            style: innerStyle,\n            minWidth: this.props.minWidth,\n            minHeight: this.props.minHeight,\n            maxWidth: this.state.resizing ? this.state.maxWidth : this.props.maxWidth,\n            maxHeight: this.state.resizing ? this.state.maxHeight : this.props.maxHeight,\n            grid: resizeGrid,\n            handleWrapperClass: resizeHandleWrapperClass,\n            handleWrapperStyle: resizeHandleWrapperStyle,\n            lockAspectRatio: this.props.lockAspectRatio,\n            lockAspectRatioExtraWidth: this.props.lockAspectRatioExtraWidth,\n            lockAspectRatioExtraHeight: this.props.lockAspectRatioExtraHeight,\n            handleStyles: resizeHandleStyles,\n            handleClasses: resizeHandleClasses,\n            handleComponent: resizeHandleComponent,\n            scale: this.props.scale\n        }), children));\n    };\n    Rnd.defaultProps = {\n        maxWidth: Number.MAX_SAFE_INTEGER,\n        maxHeight: Number.MAX_SAFE_INTEGER,\n        scale: 1,\n        onResizeStart: function() {},\n        onResize: function() {},\n        onResizeStop: function() {},\n        onDragStart: function() {},\n        onDrag: function() {},\n        onDragStop: function() {}\n    };\n    return Rnd;\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent);\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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dEM7WUFBdUJuRixPQUFPLElBQUksQ0FBQ3ZDLE1BQU11QztRQUFNLElBQUlnRjtJQUMzNUI7SUFDQXpILElBQUltSyxlQUFlO1FBQ2ZySixVQUFVc0IsT0FBT0M7UUFDakJ0QixXQUFXcUIsT0FBT0M7UUFDbEJJLE9BQU87UUFDUHpCLGVBQWUsWUFBYztRQUM3QkUsVUFBVSxZQUFjO1FBQ3hCQyxjQUFjLFlBQWM7UUFDNUJDLGFBQWEsWUFBYztRQUMzQkMsUUFBUSxZQUFjO1FBQ3RCQyxZQUFZLFlBQWM7SUFDOUI7SUFDQSxPQUFPdEI7QUFDWCxFQUFFaEQsZ0RBQWFBO0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJuZC9saWIvaW5kZXguanM/ZWU2MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBQdXJlQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IERyYWdnYWJsZSBmcm9tICdyZWFjdC1kcmFnZ2FibGUnO1xuaW1wb3J0IHsgUmVzaXphYmxlIH0gZnJvbSAncmUtcmVzaXphYmxlJztcbmltcG9ydCB7IGZsdXNoU3luYyB9IGZyb20gJ3JlYWN0LWRvbSc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cblxudmFyIHJlc2l6YWJsZVN0eWxlID0ge1xuICAgIHdpZHRoOiBcImF1dG9cIixcbiAgICBoZWlnaHQ6IFwiYXV0b1wiLFxuICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMCxcbn07XG52YXIgZ2V0RW5hYmxlUmVzaXppbmdCeUZsYWcgPSBmdW5jdGlvbiAoZmxhZykgeyByZXR1cm4gKHtcbiAgICBib3R0b206IGZsYWcsXG4gICAgYm90dG9tTGVmdDogZmxhZyxcbiAgICBib3R0b21SaWdodDogZmxhZyxcbiAgICBsZWZ0OiBmbGFnLFxuICAgIHJpZ2h0OiBmbGFnLFxuICAgIHRvcDogZmxhZyxcbiAgICB0b3BMZWZ0OiBmbGFnLFxuICAgIHRvcFJpZ2h0OiBmbGFnLFxufSk7IH07XG52YXIgUm5kID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSbmQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUm5kKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZXNpemluZ1Bvc2l0aW9uID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIF90aGlzLm9mZnNldEZyb21QYXJlbnQgPSB7IGxlZnQ6IDAsIHRvcDogMCB9O1xuICAgICAgICBfdGhpcy5yZXNpemFibGVFbGVtZW50ID0geyBjdXJyZW50OiBudWxsIH07XG4gICAgICAgIF90aGlzLm9yaWdpbmFsUG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICByZXNpemluZzogZmFsc2UsXG4gICAgICAgICAgICBib3VuZHM6IHtcbiAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWF4V2lkdGg6IHByb3BzLm1heFdpZHRoLFxuICAgICAgICAgICAgbWF4SGVpZ2h0OiBwcm9wcy5tYXhIZWlnaHQsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uUmVzaXplU3RhcnQgPSBfdGhpcy5vblJlc2l6ZVN0YXJ0LmJpbmQoX3RoaXMpO1xuICAgICAgICBfdGhpcy5vblJlc2l6ZSA9IF90aGlzLm9uUmVzaXplLmJpbmQoX3RoaXMpO1xuICAgICAgICBfdGhpcy5vblJlc2l6ZVN0b3AgPSBfdGhpcy5vblJlc2l6ZVN0b3AuYmluZChfdGhpcyk7XG4gICAgICAgIF90aGlzLm9uRHJhZ1N0YXJ0ID0gX3RoaXMub25EcmFnU3RhcnQuYmluZChfdGhpcyk7XG4gICAgICAgIF90aGlzLm9uRHJhZyA9IF90aGlzLm9uRHJhZy5iaW5kKF90aGlzKTtcbiAgICAgICAgX3RoaXMub25EcmFnU3RvcCA9IF90aGlzLm9uRHJhZ1N0b3AuYmluZChfdGhpcyk7XG4gICAgICAgIF90aGlzLmdldE1heFNpemVzRnJvbVByb3BzID0gX3RoaXMuZ2V0TWF4U2l6ZXNGcm9tUHJvcHMuYmluZChfdGhpcyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUm5kLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVPZmZzZXRGcm9tUGFyZW50KCk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMub2Zmc2V0RnJvbVBhcmVudCwgbGVmdCA9IF9hLmxlZnQsIHRvcCA9IF9hLnRvcDtcbiAgICAgICAgdmFyIF9iID0gdGhpcy5nZXREcmFnZ2FibGVQb3NpdGlvbigpLCB4ID0gX2IueCwgeSA9IF9iLnk7XG4gICAgICAgIHRoaXMuZHJhZ2dhYmxlLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHg6IHggLSBsZWZ0LFxuICAgICAgICAgICAgeTogeSAtIHRvcCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEhBQ0s6IEFwcGx5IHBvc2l0aW9uIGFkanVzdG1lbnRcbiAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgIH07XG4gICAgLy8gSEFDSzogVG8gZ2V0IGByZWFjdC1kcmFnZ2FibGVgIHN0YXRlIHggYW5kIHkuXG4gICAgUm5kLnByb3RvdHlwZS5nZXREcmFnZ2FibGVQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5kcmFnZ2FibGUuc3RhdGUsIHggPSBfYS54LCB5ID0gX2EueTtcbiAgICAgICAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xuICAgIH07XG4gICAgUm5kLnByb3RvdHlwZS5nZXRQYXJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2l6YWJsZSAmJiB0aGlzLnJlc2l6YWJsZS5wYXJlbnROb2RlO1xuICAgIH07XG4gICAgUm5kLnByb3RvdHlwZS5nZXRQYXJlbnRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNpemFibGUuZ2V0UGFyZW50U2l6ZSgpO1xuICAgIH07XG4gICAgUm5kLnByb3RvdHlwZS5nZXRNYXhTaXplc0Zyb21Qcm9wcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1heFdpZHRoID0gdHlwZW9mIHRoaXMucHJvcHMubWF4V2lkdGggPT09IFwidW5kZWZpbmVkXCIgPyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiA6IHRoaXMucHJvcHMubWF4V2lkdGg7XG4gICAgICAgIHZhciBtYXhIZWlnaHQgPSB0eXBlb2YgdGhpcy5wcm9wcy5tYXhIZWlnaHQgPT09IFwidW5kZWZpbmVkXCIgPyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiA6IHRoaXMucHJvcHMubWF4SGVpZ2h0O1xuICAgICAgICByZXR1cm4geyBtYXhXaWR0aDogbWF4V2lkdGgsIG1heEhlaWdodDogbWF4SGVpZ2h0IH07XG4gICAgfTtcbiAgICBSbmQucHJvdG90eXBlLmdldFNlbGZFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNpemFibGUgJiYgdGhpcy5yZXNpemFibGUucmVzaXphYmxlO1xuICAgIH07XG4gICAgUm5kLnByb3RvdHlwZS5nZXRPZmZzZXRIZWlnaHQgPSBmdW5jdGlvbiAoYm91bmRhcnkpIHtcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5wcm9wcy5zY2FsZTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnByb3BzLmJvdW5kcykge1xuICAgICAgICAgICAgY2FzZSBcIndpbmRvd1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJIZWlnaHQgLyBzY2FsZTtcbiAgICAgICAgICAgIGNhc2UgXCJib2R5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0IC8gc2NhbGU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBib3VuZGFyeS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJuZC5wcm90b3R5cGUuZ2V0T2Zmc2V0V2lkdGggPSBmdW5jdGlvbiAoYm91bmRhcnkpIHtcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5wcm9wcy5zY2FsZTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnByb3BzLmJvdW5kcykge1xuICAgICAgICAgICAgY2FzZSBcIndpbmRvd1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJXaWR0aCAvIHNjYWxlO1xuICAgICAgICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aCAvIHNjYWxlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gYm91bmRhcnkub2Zmc2V0V2lkdGg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJuZC5wcm90b3R5cGUub25EcmFnU3RhcnQgPSBmdW5jdGlvbiAoZSwgZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5vbkRyYWdTdGFydCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkRyYWdTdGFydChlLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9zID0gdGhpcy5nZXREcmFnZ2FibGVQb3NpdGlvbigpO1xuICAgICAgICB0aGlzLm9yaWdpbmFsUG9zaXRpb24gPSBwb3M7XG4gICAgICAgIGlmICghdGhpcy5wcm9wcy5ib3VuZHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnByb3BzLnNjYWxlO1xuICAgICAgICB2YXIgYm91bmRhcnk7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmJvdW5kcyA9PT0gXCJwYXJlbnRcIikge1xuICAgICAgICAgICAgYm91bmRhcnkgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wcm9wcy5ib3VuZHMgPT09IFwiYm9keVwiKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50UmVjdF8xID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdmFyIHBhcmVudExlZnRfMSA9IHBhcmVudFJlY3RfMS5sZWZ0O1xuICAgICAgICAgICAgdmFyIHBhcmVudFRvcF8xID0gcGFyZW50UmVjdF8xLnRvcDtcbiAgICAgICAgICAgIHZhciBib2R5UmVjdCA9IGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB2YXIgbGVmdF8xID0gLShwYXJlbnRMZWZ0XzEgLSBwYXJlbnQub2Zmc2V0TGVmdCAqIHNjYWxlIC0gYm9keVJlY3QubGVmdCkgLyBzY2FsZTtcbiAgICAgICAgICAgIHZhciB0b3BfMSA9IC0ocGFyZW50VG9wXzEgLSBwYXJlbnQub2Zmc2V0VG9wICogc2NhbGUgLSBib2R5UmVjdC50b3ApIC8gc2NhbGU7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSAoZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aCAtIHRoaXMucmVzaXphYmxlLnNpemUud2lkdGggKiBzY2FsZSkgLyBzY2FsZSArIGxlZnRfMTtcbiAgICAgICAgICAgIHZhciBib3R0b20gPSAoZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQgLSB0aGlzLnJlc2l6YWJsZS5zaXplLmhlaWdodCAqIHNjYWxlKSAvIHNjYWxlICsgdG9wXzE7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRTdGF0ZSh7IGJvdW5kczogeyB0b3A6IHRvcF8xLCByaWdodDogcmlnaHQsIGJvdHRvbTogYm90dG9tLCBsZWZ0OiBsZWZ0XzEgfSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnByb3BzLmJvdW5kcyA9PT0gXCJ3aW5kb3dcIikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlc2l6YWJsZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgcGFyZW50UmVjdF8yID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdmFyIHBhcmVudExlZnRfMiA9IHBhcmVudFJlY3RfMi5sZWZ0O1xuICAgICAgICAgICAgdmFyIHBhcmVudFRvcF8yID0gcGFyZW50UmVjdF8yLnRvcDtcbiAgICAgICAgICAgIHZhciBsZWZ0XzIgPSAtKHBhcmVudExlZnRfMiAtIHBhcmVudC5vZmZzZXRMZWZ0ICogc2NhbGUpIC8gc2NhbGU7XG4gICAgICAgICAgICB2YXIgdG9wXzIgPSAtKHBhcmVudFRvcF8yIC0gcGFyZW50Lm9mZnNldFRvcCAqIHNjYWxlKSAvIHNjYWxlO1xuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gKHdpbmRvdy5pbm5lcldpZHRoIC0gdGhpcy5yZXNpemFibGUuc2l6ZS53aWR0aCAqIHNjYWxlKSAvIHNjYWxlICsgbGVmdF8yO1xuICAgICAgICAgICAgdmFyIGJvdHRvbSA9ICh3aW5kb3cuaW5uZXJIZWlnaHQgLSB0aGlzLnJlc2l6YWJsZS5zaXplLmhlaWdodCAqIHNjYWxlKSAvIHNjYWxlICsgdG9wXzI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRTdGF0ZSh7IGJvdW5kczogeyB0b3A6IHRvcF8yLCByaWdodDogcmlnaHQsIGJvdHRvbTogYm90dG9tLCBsZWZ0OiBsZWZ0XzIgfSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy5wcm9wcy5ib3VuZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGJvdW5kYXJ5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLnByb3BzLmJvdW5kcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wcm9wcy5ib3VuZHMgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgYm91bmRhcnkgPSB0aGlzLnByb3BzLmJvdW5kcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShib3VuZGFyeSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB8fCAhKHBhcmVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBib3VuZGFyeVJlY3QgPSBib3VuZGFyeS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIGJvdW5kYXJ5TGVmdCA9IGJvdW5kYXJ5UmVjdC5sZWZ0O1xuICAgICAgICB2YXIgYm91bmRhcnlUb3AgPSBib3VuZGFyeVJlY3QudG9wO1xuICAgICAgICB2YXIgcGFyZW50UmVjdCA9IHBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIHBhcmVudExlZnQgPSBwYXJlbnRSZWN0LmxlZnQ7XG4gICAgICAgIHZhciBwYXJlbnRUb3AgPSBwYXJlbnRSZWN0LnRvcDtcbiAgICAgICAgdmFyIGxlZnQgPSAoYm91bmRhcnlMZWZ0IC0gcGFyZW50TGVmdCkgLyBzY2FsZTtcbiAgICAgICAgdmFyIHRvcCA9IGJvdW5kYXJ5VG9wIC0gcGFyZW50VG9wO1xuICAgICAgICBpZiAoIXRoaXMucmVzaXphYmxlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnVwZGF0ZU9mZnNldEZyb21QYXJlbnQoKTtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0RnJvbVBhcmVudDtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBib3VuZHM6IHtcbiAgICAgICAgICAgICAgICB0b3A6IHRvcCAtIG9mZnNldC50b3AsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IGxlZnQgKyAoYm91bmRhcnkub2Zmc2V0V2lkdGggLSB0aGlzLnJlc2l6YWJsZS5zaXplLndpZHRoKSAtIG9mZnNldC5sZWZ0IC8gc2NhbGUsXG4gICAgICAgICAgICAgICAgYm90dG9tOiB0b3AgKyAoYm91bmRhcnkub2Zmc2V0SGVpZ2h0IC0gdGhpcy5yZXNpemFibGUuc2l6ZS5oZWlnaHQpIC0gb2Zmc2V0LnRvcCxcbiAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0IC0gb2Zmc2V0LmxlZnQgLyBzY2FsZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUm5kLnByb3RvdHlwZS5vbkRyYWcgPSBmdW5jdGlvbiAoZSwgZGF0YSkge1xuICAgICAgICBpZiAoIXRoaXMucHJvcHMub25EcmFnKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLm9mZnNldEZyb21QYXJlbnQsIGxlZnQgPSBfYS5sZWZ0LCB0b3AgPSBfYS50b3A7XG4gICAgICAgIGlmICghdGhpcy5wcm9wcy5kcmFnQXhpcyB8fCB0aGlzLnByb3BzLmRyYWdBeGlzID09PSBcImJvdGhcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMub25EcmFnKGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBkYXRhKSwgeyB4OiBkYXRhLnggKyBsZWZ0LCB5OiBkYXRhLnkgKyB0b3AgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucHJvcHMuZHJhZ0F4aXMgPT09IFwieFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5vbkRyYWcoZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGRhdGEpLCB7IHg6IGRhdGEueCArIGxlZnQsIHk6IHRoaXMub3JpZ2luYWxQb3NpdGlvbi55ICsgdG9wLCBkZWx0YVk6IDAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucHJvcHMuZHJhZ0F4aXMgPT09IFwieVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5vbkRyYWcoZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGRhdGEpLCB7IHg6IHRoaXMub3JpZ2luYWxQb3NpdGlvbi54ICsgbGVmdCwgeTogZGF0YS55ICsgdG9wLCBkZWx0YVg6IDAgfSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSbmQucHJvdG90eXBlLm9uRHJhZ1N0b3AgPSBmdW5jdGlvbiAoZSwgZGF0YSkge1xuICAgICAgICBpZiAoIXRoaXMucHJvcHMub25EcmFnU3RvcClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5vZmZzZXRGcm9tUGFyZW50LCBsZWZ0ID0gX2EubGVmdCwgdG9wID0gX2EudG9wO1xuICAgICAgICBpZiAoIXRoaXMucHJvcHMuZHJhZ0F4aXMgfHwgdGhpcy5wcm9wcy5kcmFnQXhpcyA9PT0gXCJib3RoXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLm9uRHJhZ1N0b3AoZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGRhdGEpLCB7IHg6IGRhdGEueCArIGxlZnQsIHk6IGRhdGEueSArIHRvcCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wcm9wcy5kcmFnQXhpcyA9PT0gXCJ4XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLm9uRHJhZ1N0b3AoZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGRhdGEpLCB7IHg6IGRhdGEueCArIGxlZnQsIHk6IHRoaXMub3JpZ2luYWxQb3NpdGlvbi55ICsgdG9wLCBkZWx0YVk6IDAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucHJvcHMuZHJhZ0F4aXMgPT09IFwieVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5vbkRyYWdTdG9wKGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBkYXRhKSwgeyB4OiB0aGlzLm9yaWdpbmFsUG9zaXRpb24ueCArIGxlZnQsIHk6IGRhdGEueSArIHRvcCwgZGVsdGFYOiAwIH0pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUm5kLnByb3RvdHlwZS5vblJlc2l6ZVN0YXJ0ID0gZnVuY3Rpb24gKGUsIGRpciwgZWxlbWVudFJlZikge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHJlc2l6aW5nOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5wcm9wcy5zY2FsZTtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0RnJvbVBhcmVudDtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0RHJhZ2dhYmxlUG9zaXRpb24oKTtcbiAgICAgICAgdGhpcy5yZXNpemluZ1Bvc2l0aW9uID0geyB4OiBwb3MueCArIG9mZnNldC5sZWZ0LCB5OiBwb3MueSArIG9mZnNldC50b3AgfTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbFBvc2l0aW9uID0gcG9zO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5ib3VuZHMpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRfMSA9IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgICAgICAgICB2YXIgYm91bmRhcnkgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5ib3VuZHMgPT09IFwicGFyZW50XCIpIHtcbiAgICAgICAgICAgICAgICBib3VuZGFyeSA9IHBhcmVudF8xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wcm9wcy5ib3VuZHMgPT09IFwiYm9keVwiKSB7XG4gICAgICAgICAgICAgICAgYm91bmRhcnkgPSBkb2N1bWVudC5ib2R5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wcm9wcy5ib3VuZHMgPT09IFwid2luZG93XCIpIHtcbiAgICAgICAgICAgICAgICBib3VuZGFyeSA9IHdpbmRvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLnByb3BzLmJvdW5kcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGJvdW5kYXJ5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLnByb3BzLmJvdW5kcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnByb3BzLmJvdW5kcyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgYm91bmRhcnkgPSB0aGlzLnByb3BzLmJvdW5kcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzZWxmXzEgPSB0aGlzLmdldFNlbGZFbGVtZW50KCk7XG4gICAgICAgICAgICBpZiAoc2VsZl8xIGluc3RhbmNlb2YgRWxlbWVudCAmJlxuICAgICAgICAgICAgICAgIChib3VuZGFyeSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IGJvdW5kYXJ5ID09PSB3aW5kb3cpICYmXG4gICAgICAgICAgICAgICAgcGFyZW50XzEgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IHRoaXMuZ2V0TWF4U2l6ZXNGcm9tUHJvcHMoKSwgbWF4V2lkdGggPSBfYS5tYXhXaWR0aCwgbWF4SGVpZ2h0ID0gX2EubWF4SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRTaXplID0gdGhpcy5nZXRQYXJlbnRTaXplKCk7XG4gICAgICAgICAgICAgICAgaWYgKG1heFdpZHRoICYmIHR5cGVvZiBtYXhXaWR0aCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF4V2lkdGguZW5kc1dpdGgoXCIlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF0aW8gPSBOdW1iZXIobWF4V2lkdGgucmVwbGFjZShcIiVcIiwgXCJcIikpIC8gMTAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGggPSBwYXJlbnRTaXplLndpZHRoICogcmF0aW87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWF4V2lkdGguZW5kc1dpdGgoXCJweFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGggPSBOdW1iZXIobWF4V2lkdGgucmVwbGFjZShcInB4XCIsIFwiXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWF4SGVpZ2h0ICYmIHR5cGVvZiBtYXhIZWlnaHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heEhlaWdodC5lbmRzV2l0aChcIiVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXRpbyA9IE51bWJlcihtYXhIZWlnaHQucmVwbGFjZShcIiVcIiwgXCJcIikpIC8gMTAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0ID0gcGFyZW50U2l6ZS5oZWlnaHQgKiByYXRpbztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXhIZWlnaHQuZW5kc1dpdGgoXCJweFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0ID0gTnVtYmVyKG1heEhlaWdodC5yZXBsYWNlKFwicHhcIiwgXCJcIikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzZWxmUmVjdCA9IHNlbGZfMS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZkxlZnQgPSBzZWxmUmVjdC5sZWZ0O1xuICAgICAgICAgICAgICAgIHZhciBzZWxmVG9wID0gc2VsZlJlY3QudG9wO1xuICAgICAgICAgICAgICAgIHZhciBib3VuZGFyeVJlY3QgPSB0aGlzLnByb3BzLmJvdW5kcyA9PT0gXCJ3aW5kb3dcIiA/IHsgbGVmdDogMCwgdG9wOiAwIH0gOiBib3VuZGFyeS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICB2YXIgYm91bmRhcnlMZWZ0ID0gYm91bmRhcnlSZWN0LmxlZnQ7XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kYXJ5VG9wID0gYm91bmRhcnlSZWN0LnRvcDtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0V2lkdGggPSB0aGlzLmdldE9mZnNldFdpZHRoKGJvdW5kYXJ5KTtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0SGVpZ2h0ID0gdGhpcy5nZXRPZmZzZXRIZWlnaHQoYm91bmRhcnkpO1xuICAgICAgICAgICAgICAgIHZhciBoYXNMZWZ0ID0gZGlyLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoXCJsZWZ0XCIpO1xuICAgICAgICAgICAgICAgIHZhciBoYXNSaWdodCA9IGRpci50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKFwicmlnaHRcIik7XG4gICAgICAgICAgICAgICAgdmFyIGhhc1RvcCA9IGRpci5zdGFydHNXaXRoKFwidG9wXCIpO1xuICAgICAgICAgICAgICAgIHZhciBoYXNCb3R0b20gPSBkaXIuc3RhcnRzV2l0aChcImJvdHRvbVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoKGhhc0xlZnQgfHwgaGFzVG9wKSAmJiB0aGlzLnJlc2l6YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4ID0gKHNlbGZMZWZ0IC0gYm91bmRhcnlMZWZ0KSAvIHNjYWxlICsgdGhpcy5yZXNpemFibGUuc2l6ZS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IG1heFdpZHRoOiBtYXggPiBOdW1iZXIobWF4V2lkdGgpID8gbWF4V2lkdGggOiBtYXggfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElORk86IFRvIHNldCBib3VuZHMgaW4gYGxvY2sgYXNwZWN0IHJhdGlvIHdpdGggYm91bmRzYCBjYXNlLiBTZWUgYWxzbyB0aGF0IHN0b3J5LlxuICAgICAgICAgICAgICAgIGlmIChoYXNSaWdodCB8fCAodGhpcy5wcm9wcy5sb2NrQXNwZWN0UmF0aW8gJiYgIWhhc0xlZnQgJiYgIWhhc1RvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heCA9IG9mZnNldFdpZHRoICsgKGJvdW5kYXJ5TGVmdCAtIHNlbGZMZWZ0KSAvIHNjYWxlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgbWF4V2lkdGg6IG1heCA+IE51bWJlcihtYXhXaWR0aCkgPyBtYXhXaWR0aCA6IG1heCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChoYXNUb3AgfHwgaGFzTGVmdCkgJiYgdGhpcy5yZXNpemFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heCA9IChzZWxmVG9wIC0gYm91bmRhcnlUb3ApIC8gc2NhbGUgKyB0aGlzLnJlc2l6YWJsZS5zaXplLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhIZWlnaHQ6IG1heCA+IE51bWJlcihtYXhIZWlnaHQpID8gbWF4SGVpZ2h0IDogbWF4LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSU5GTzogVG8gc2V0IGJvdW5kcyBpbiBgbG9jayBhc3BlY3QgcmF0aW8gd2l0aCBib3VuZHNgIGNhc2UuIFNlZSBhbHNvIHRoYXQgc3RvcnkuXG4gICAgICAgICAgICAgICAgaWYgKGhhc0JvdHRvbSB8fCAodGhpcy5wcm9wcy5sb2NrQXNwZWN0UmF0aW8gJiYgIWhhc1RvcCAmJiAhaGFzTGVmdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heCA9IG9mZnNldEhlaWdodCArIChib3VuZGFyeVRvcCAtIHNlbGZUb3ApIC8gc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0OiBtYXggPiBOdW1iZXIobWF4SGVpZ2h0KSA/IG1heEhlaWdodCA6IG1heCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgbWF4V2lkdGg6IHRoaXMucHJvcHMubWF4V2lkdGgsXG4gICAgICAgICAgICAgICAgbWF4SGVpZ2h0OiB0aGlzLnByb3BzLm1heEhlaWdodCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uUmVzaXplU3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25SZXNpemVTdGFydChlLCBkaXIsIGVsZW1lbnRSZWYpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSbmQucHJvdG90eXBlLm9uUmVzaXplID0gZnVuY3Rpb24gKGUsIGRpcmVjdGlvbiwgZWxlbWVudFJlZiwgZGVsdGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gSU5GTzogQXBwbHkgeCBhbmQgeSBwb3NpdGlvbiBhZGp1c3RtZW50cyBjYXVzZWQgYnkgcmVzaXppbmcgdG8gZHJhZ2dhYmxlXG4gICAgICAgIHZhciBuZXdQb3MgPSB7IHg6IHRoaXMub3JpZ2luYWxQb3NpdGlvbi54LCB5OiB0aGlzLm9yaWdpbmFsUG9zaXRpb24ueSB9O1xuICAgICAgICB2YXIgbGVmdCA9IC1kZWx0YS53aWR0aDtcbiAgICAgICAgdmFyIHRvcCA9IC1kZWx0YS5oZWlnaHQ7XG4gICAgICAgIHZhciBkaXJlY3Rpb25zID0gW1widG9wXCIsIFwibGVmdFwiLCBcInRvcExlZnRcIiwgXCJib3R0b21MZWZ0XCIsIFwidG9wUmlnaHRcIl07XG4gICAgICAgIGlmIChkaXJlY3Rpb25zLmluY2x1ZGVzKGRpcmVjdGlvbikpIHtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09IFwiYm90dG9tTGVmdFwiKSB7XG4gICAgICAgICAgICAgICAgbmV3UG9zLnggKz0gbGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gXCJ0b3BSaWdodFwiKSB7XG4gICAgICAgICAgICAgICAgbmV3UG9zLnkgKz0gdG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3UG9zLnggKz0gbGVmdDtcbiAgICAgICAgICAgICAgICBuZXdQb3MueSArPSB0b3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRyYWdnYWJsZVN0YXRlID0gdGhpcy5kcmFnZ2FibGUuc3RhdGU7XG4gICAgICAgIGlmIChuZXdQb3MueCAhPT0gZHJhZ2dhYmxlU3RhdGUueCB8fCBuZXdQb3MueSAhPT0gZHJhZ2dhYmxlU3RhdGUueSkge1xuICAgICAgICAgICAgZmx1c2hTeW5jKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5kcmFnZ2FibGUuc2V0U3RhdGUobmV3UG9zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlT2Zmc2V0RnJvbVBhcmVudCgpO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXRGcm9tUGFyZW50O1xuICAgICAgICB2YXIgeCA9IHRoaXMuZ2V0RHJhZ2dhYmxlUG9zaXRpb24oKS54ICsgb2Zmc2V0LmxlZnQ7XG4gICAgICAgIHZhciB5ID0gdGhpcy5nZXREcmFnZ2FibGVQb3NpdGlvbigpLnkgKyBvZmZzZXQudG9wO1xuICAgICAgICB0aGlzLnJlc2l6aW5nUG9zaXRpb24gPSB7IHg6IHgsIHk6IHkgfTtcbiAgICAgICAgaWYgKCF0aGlzLnByb3BzLm9uUmVzaXplKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnByb3BzLm9uUmVzaXplKGUsIGRpcmVjdGlvbiwgZWxlbWVudFJlZiwgZGVsdGEsIHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJuZC5wcm90b3R5cGUub25SZXNpemVTdG9wID0gZnVuY3Rpb24gKGUsIGRpcmVjdGlvbiwgZWxlbWVudFJlZiwgZGVsdGEpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICByZXNpemluZzogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmdldE1heFNpemVzRnJvbVByb3BzKCksIG1heFdpZHRoID0gX2EubWF4V2lkdGgsIG1heEhlaWdodCA9IF9hLm1heEhlaWdodDtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IG1heFdpZHRoOiBtYXhXaWR0aCwgbWF4SGVpZ2h0OiBtYXhIZWlnaHQgfSk7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uUmVzaXplU3RvcCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vblJlc2l6ZVN0b3AoZSwgZGlyZWN0aW9uLCBlbGVtZW50UmVmLCBkZWx0YSwgdGhpcy5yZXNpemluZ1Bvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUm5kLnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlc2l6YWJsZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5yZXNpemFibGUudXBkYXRlU2l6ZSh7IHdpZHRoOiBzaXplLndpZHRoLCBoZWlnaHQ6IHNpemUuaGVpZ2h0IH0pO1xuICAgIH07XG4gICAgUm5kLnByb3RvdHlwZS51cGRhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICB0aGlzLmRyYWdnYWJsZS5zZXRTdGF0ZShwb3NpdGlvbik7XG4gICAgfTtcbiAgICBSbmQucHJvdG90eXBlLnVwZGF0ZU9mZnNldEZyb21QYXJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMucHJvcHMuc2NhbGU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMuZ2V0U2VsZkVsZW1lbnQoKTtcbiAgICAgICAgaWYgKCFwYXJlbnQgfHwgc2VsZiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcmVudFJlY3QgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBwYXJlbnRMZWZ0ID0gcGFyZW50UmVjdC5sZWZ0O1xuICAgICAgICB2YXIgcGFyZW50VG9wID0gcGFyZW50UmVjdC50b3A7XG4gICAgICAgIHZhciBzZWxmUmVjdCA9IHNlbGYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuZ2V0RHJhZ2dhYmxlUG9zaXRpb24oKTtcbiAgICAgICAgdmFyIHNjcm9sbExlZnQgPSBwYXJlbnQuc2Nyb2xsTGVmdDtcbiAgICAgICAgdmFyIHNjcm9sbFRvcCA9IHBhcmVudC5zY3JvbGxUb3A7XG4gICAgICAgIHRoaXMub2Zmc2V0RnJvbVBhcmVudCA9IHtcbiAgICAgICAgICAgIGxlZnQ6IHNlbGZSZWN0LmxlZnQgLSBwYXJlbnRMZWZ0ICsgc2Nyb2xsTGVmdCAtIHBvc2l0aW9uLnggKiBzY2FsZSxcbiAgICAgICAgICAgIHRvcDogc2VsZlJlY3QudG9wIC0gcGFyZW50VG9wICsgc2Nyb2xsVG9wIC0gcG9zaXRpb24ueSAqIHNjYWxlLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgUm5kLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIGRpc2FibGVEcmFnZ2luZyA9IF9hLmRpc2FibGVEcmFnZ2luZywgc3R5bGUgPSBfYS5zdHlsZSwgZHJhZ0hhbmRsZUNsYXNzTmFtZSA9IF9hLmRyYWdIYW5kbGVDbGFzc05hbWUsIHBvc2l0aW9uID0gX2EucG9zaXRpb24sIG9uTW91c2VEb3duID0gX2Eub25Nb3VzZURvd24sIG9uTW91c2VVcCA9IF9hLm9uTW91c2VVcCwgZHJhZ0F4aXMgPSBfYS5kcmFnQXhpcywgZHJhZ0dyaWQgPSBfYS5kcmFnR3JpZCwgYm91bmRzID0gX2EuYm91bmRzLCBlbmFibGVVc2VyU2VsZWN0SGFjayA9IF9hLmVuYWJsZVVzZXJTZWxlY3RIYWNrLCBjYW5jZWwgPSBfYS5jYW5jZWwsIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIG9uUmVzaXplU3RhcnQgPSBfYS5vblJlc2l6ZVN0YXJ0LCBvblJlc2l6ZSA9IF9hLm9uUmVzaXplLCBvblJlc2l6ZVN0b3AgPSBfYS5vblJlc2l6ZVN0b3AsIG9uRHJhZ1N0YXJ0ID0gX2Eub25EcmFnU3RhcnQsIG9uRHJhZyA9IF9hLm9uRHJhZywgb25EcmFnU3RvcCA9IF9hLm9uRHJhZ1N0b3AsIHJlc2l6ZUhhbmRsZVN0eWxlcyA9IF9hLnJlc2l6ZUhhbmRsZVN0eWxlcywgcmVzaXplSGFuZGxlQ2xhc3NlcyA9IF9hLnJlc2l6ZUhhbmRsZUNsYXNzZXMsIHJlc2l6ZUhhbmRsZUNvbXBvbmVudCA9IF9hLnJlc2l6ZUhhbmRsZUNvbXBvbmVudCwgZW5hYmxlUmVzaXppbmcgPSBfYS5lbmFibGVSZXNpemluZywgcmVzaXplR3JpZCA9IF9hLnJlc2l6ZUdyaWQsIHJlc2l6ZUhhbmRsZVdyYXBwZXJDbGFzcyA9IF9hLnJlc2l6ZUhhbmRsZVdyYXBwZXJDbGFzcywgcmVzaXplSGFuZGxlV3JhcHBlclN0eWxlID0gX2EucmVzaXplSGFuZGxlV3JhcHBlclN0eWxlLCBzY2FsZSA9IF9hLnNjYWxlLCBhbGxvd0FueUNsaWNrID0gX2EuYWxsb3dBbnlDbGljaywgZHJhZ1Bvc2l0aW9uT2Zmc2V0ID0gX2EuZHJhZ1Bvc2l0aW9uT2Zmc2V0LCByZXNpemFibGVQcm9wcyA9IF9fcmVzdChfYSwgW1wiZGlzYWJsZURyYWdnaW5nXCIsIFwic3R5bGVcIiwgXCJkcmFnSGFuZGxlQ2xhc3NOYW1lXCIsIFwicG9zaXRpb25cIiwgXCJvbk1vdXNlRG93blwiLCBcIm9uTW91c2VVcFwiLCBcImRyYWdBeGlzXCIsIFwiZHJhZ0dyaWRcIiwgXCJib3VuZHNcIiwgXCJlbmFibGVVc2VyU2VsZWN0SGFja1wiLCBcImNhbmNlbFwiLCBcImNoaWxkcmVuXCIsIFwib25SZXNpemVTdGFydFwiLCBcIm9uUmVzaXplXCIsIFwib25SZXNpemVTdG9wXCIsIFwib25EcmFnU3RhcnRcIiwgXCJvbkRyYWdcIiwgXCJvbkRyYWdTdG9wXCIsIFwicmVzaXplSGFuZGxlU3R5bGVzXCIsIFwicmVzaXplSGFuZGxlQ2xhc3Nlc1wiLCBcInJlc2l6ZUhhbmRsZUNvbXBvbmVudFwiLCBcImVuYWJsZVJlc2l6aW5nXCIsIFwicmVzaXplR3JpZFwiLCBcInJlc2l6ZUhhbmRsZVdyYXBwZXJDbGFzc1wiLCBcInJlc2l6ZUhhbmRsZVdyYXBwZXJTdHlsZVwiLCBcInNjYWxlXCIsIFwiYWxsb3dBbnlDbGlja1wiLCBcImRyYWdQb3NpdGlvbk9mZnNldFwiXSk7XG4gICAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSB0aGlzLnByb3BzLmRlZmF1bHQgPyBfX2Fzc2lnbih7fSwgdGhpcy5wcm9wcy5kZWZhdWx0KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gUmVtb3ZlIHVua25vd24gcHJvcHMsIHNlZSBhbHNvIGh0dHBzOi8vcmVhY3Rqcy5vcmcvd2FybmluZ3MvdW5rbm93bi1wcm9wLmh0bWxcbiAgICAgICAgZGVsZXRlIHJlc2l6YWJsZVByb3BzLmRlZmF1bHQ7XG4gICAgICAgIHZhciBjdXJzb3JTdHlsZSA9IGRpc2FibGVEcmFnZ2luZyB8fCBkcmFnSGFuZGxlQ2xhc3NOYW1lID8geyBjdXJzb3I6IFwiYXV0b1wiIH0gOiB7IGN1cnNvcjogXCJtb3ZlXCIgfTtcbiAgICAgICAgdmFyIGlubmVyU3R5bGUgPSBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmVzaXphYmxlU3R5bGUpLCBjdXJzb3JTdHlsZSksIHN0eWxlKTtcbiAgICAgICAgdmFyIF9iID0gdGhpcy5vZmZzZXRGcm9tUGFyZW50LCBsZWZ0ID0gX2IubGVmdCwgdG9wID0gX2IudG9wO1xuICAgICAgICB2YXIgZHJhZ2dhYmxlUG9zaXRpb247XG4gICAgICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICAgICAgZHJhZ2dhYmxlUG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeDogcG9zaXRpb24ueCAtIGxlZnQsXG4gICAgICAgICAgICAgICAgeTogcG9zaXRpb24ueSAtIHRvcCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSU5GTzogTWFrZSB1bmNvbnRvcm9sbGVkIGNvbXBvbmVudCB3aGVuIHJlc2l6aW5nIHRvIGNvbnRyb2wgcG9zaXRpb24gYnkgc2V0UG9zdGlvbi5cbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuc3RhdGUucmVzaXppbmcgPyB1bmRlZmluZWQgOiBkcmFnZ2FibGVQb3NpdGlvbjtcbiAgICAgICAgdmFyIGRyYWdBeGlzT3JVbmRlZmluZWQgPSB0aGlzLnN0YXRlLnJlc2l6aW5nID8gXCJib3RoXCIgOiBkcmFnQXhpcztcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KERyYWdnYWJsZSwgeyByZWY6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgX3RoaXMuZHJhZ2dhYmxlID0gYztcbiAgICAgICAgICAgIH0sIGhhbmRsZTogZHJhZ0hhbmRsZUNsYXNzTmFtZSA/IFwiLlwiLmNvbmNhdChkcmFnSGFuZGxlQ2xhc3NOYW1lKSA6IHVuZGVmaW5lZCwgZGVmYXVsdFBvc2l0aW9uOiBkZWZhdWx0VmFsdWUsIG9uTW91c2VEb3duOiBvbk1vdXNlRG93biwgXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBvbk1vdXNlVXA6IG9uTW91c2VVcCwgb25TdGFydDogdGhpcy5vbkRyYWdTdGFydCwgb25EcmFnOiB0aGlzLm9uRHJhZywgb25TdG9wOiB0aGlzLm9uRHJhZ1N0b3AsIGF4aXM6IGRyYWdBeGlzT3JVbmRlZmluZWQsIGRpc2FibGVkOiBkaXNhYmxlRHJhZ2dpbmcsIGdyaWQ6IGRyYWdHcmlkLCBib3VuZHM6IGJvdW5kcyA/IHRoaXMuc3RhdGUuYm91bmRzIDogdW5kZWZpbmVkLCBwb3NpdGlvbjogcG9zLCBlbmFibGVVc2VyU2VsZWN0SGFjazogZW5hYmxlVXNlclNlbGVjdEhhY2ssIGNhbmNlbDogY2FuY2VsLCBzY2FsZTogc2NhbGUsIGFsbG93QW55Q2xpY2s6IGFsbG93QW55Q2xpY2ssIG5vZGVSZWY6IHRoaXMucmVzaXphYmxlRWxlbWVudCwgcG9zaXRpb25PZmZzZXQ6IGRyYWdQb3NpdGlvbk9mZnNldCB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChSZXNpemFibGUsIF9fYXNzaWduKHt9LCByZXNpemFibGVQcm9wcywgeyByZWY6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVzaXphYmxlID0gYztcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVzaXphYmxlRWxlbWVudC5jdXJyZW50ID0gYy5yZXNpemFibGU7XG4gICAgICAgICAgICAgICAgfSwgZGVmYXVsdFNpemU6IGRlZmF1bHRWYWx1ZSwgc2l6ZTogdGhpcy5wcm9wcy5zaXplLCBlbmFibGU6IHR5cGVvZiBlbmFibGVSZXNpemluZyA9PT0gXCJib29sZWFuXCIgPyBnZXRFbmFibGVSZXNpemluZ0J5RmxhZyhlbmFibGVSZXNpemluZykgOiBlbmFibGVSZXNpemluZywgb25SZXNpemVTdGFydDogdGhpcy5vblJlc2l6ZVN0YXJ0LCBvblJlc2l6ZTogdGhpcy5vblJlc2l6ZSwgb25SZXNpemVTdG9wOiB0aGlzLm9uUmVzaXplU3RvcCwgc3R5bGU6IGlubmVyU3R5bGUsIG1pbldpZHRoOiB0aGlzLnByb3BzLm1pbldpZHRoLCBtaW5IZWlnaHQ6IHRoaXMucHJvcHMubWluSGVpZ2h0LCBtYXhXaWR0aDogdGhpcy5zdGF0ZS5yZXNpemluZyA/IHRoaXMuc3RhdGUubWF4V2lkdGggOiB0aGlzLnByb3BzLm1heFdpZHRoLCBtYXhIZWlnaHQ6IHRoaXMuc3RhdGUucmVzaXppbmcgPyB0aGlzLnN0YXRlLm1heEhlaWdodCA6IHRoaXMucHJvcHMubWF4SGVpZ2h0LCBncmlkOiByZXNpemVHcmlkLCBoYW5kbGVXcmFwcGVyQ2xhc3M6IHJlc2l6ZUhhbmRsZVdyYXBwZXJDbGFzcywgaGFuZGxlV3JhcHBlclN0eWxlOiByZXNpemVIYW5kbGVXcmFwcGVyU3R5bGUsIGxvY2tBc3BlY3RSYXRpbzogdGhpcy5wcm9wcy5sb2NrQXNwZWN0UmF0aW8sIGxvY2tBc3BlY3RSYXRpb0V4dHJhV2lkdGg6IHRoaXMucHJvcHMubG9ja0FzcGVjdFJhdGlvRXh0cmFXaWR0aCwgbG9ja0FzcGVjdFJhdGlvRXh0cmFIZWlnaHQ6IHRoaXMucHJvcHMubG9ja0FzcGVjdFJhdGlvRXh0cmFIZWlnaHQsIGhhbmRsZVN0eWxlczogcmVzaXplSGFuZGxlU3R5bGVzLCBoYW5kbGVDbGFzc2VzOiByZXNpemVIYW5kbGVDbGFzc2VzLCBoYW5kbGVDb21wb25lbnQ6IHJlc2l6ZUhhbmRsZUNvbXBvbmVudCwgc2NhbGU6IHRoaXMucHJvcHMuc2NhbGUgfSksIGNoaWxkcmVuKSkpO1xuICAgIH07XG4gICAgUm5kLmRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgbWF4V2lkdGg6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgICBtYXhIZWlnaHQ6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgICBzY2FsZTogMSxcbiAgICAgICAgb25SZXNpemVTdGFydDogZnVuY3Rpb24gKCkgeyB9LFxuICAgICAgICBvblJlc2l6ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgICAgICBvblJlc2l6ZVN0b3A6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICAgICAgb25EcmFnU3RhcnQ6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICAgICAgb25EcmFnOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgICAgIG9uRHJhZ1N0b3A6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICB9O1xuICAgIHJldHVybiBSbmQ7XG59KFB1cmVDb21wb25lbnQpKTtcblxuZXhwb3J0IHsgUm5kIH07XG4iXSwibmFtZXMiOlsiY3JlYXRlRWxlbWVudCIsIlB1cmVDb21wb25lbnQiLCJEcmFnZ2FibGUiLCJSZXNpemFibGUiLCJmbHVzaFN5bmMiLCJleHRlbmRTdGF0aWNzIiwiZCIsImIiLCJPYmplY3QiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsIkFycmF5IiwicCIsImhhc093blByb3BlcnR5IiwiX19leHRlbmRzIiwiX18iLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsImNyZWF0ZSIsIl9fYXNzaWduIiwiYXNzaWduIiwidCIsInMiLCJpIiwibiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImNhbGwiLCJhcHBseSIsIl9fcmVzdCIsImUiLCJpbmRleE9mIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJyZXNpemFibGVTdHlsZSIsIndpZHRoIiwiaGVpZ2h0IiwiZGlzcGxheSIsInBvc2l0aW9uIiwidG9wIiwibGVmdCIsImdldEVuYWJsZVJlc2l6aW5nQnlGbGFnIiwiZmxhZyIsImJvdHRvbSIsImJvdHRvbUxlZnQiLCJib3R0b21SaWdodCIsInJpZ2h0IiwidG9wTGVmdCIsInRvcFJpZ2h0IiwiUm5kIiwiX3N1cGVyIiwicHJvcHMiLCJfdGhpcyIsInJlc2l6aW5nUG9zaXRpb24iLCJ4IiwieSIsIm9mZnNldEZyb21QYXJlbnQiLCJyZXNpemFibGVFbGVtZW50IiwiY3VycmVudCIsIm9yaWdpbmFsUG9zaXRpb24iLCJzdGF0ZSIsInJlc2l6aW5nIiwiYm91bmRzIiwibWF4V2lkdGgiLCJtYXhIZWlnaHQiLCJvblJlc2l6ZVN0YXJ0IiwiYmluZCIsIm9uUmVzaXplIiwib25SZXNpemVTdG9wIiwib25EcmFnU3RhcnQiLCJvbkRyYWciLCJvbkRyYWdTdG9wIiwiZ2V0TWF4U2l6ZXNGcm9tUHJvcHMiLCJjb21wb25lbnREaWRNb3VudCIsInVwZGF0ZU9mZnNldEZyb21QYXJlbnQiLCJfYSIsIl9iIiwiZ2V0RHJhZ2dhYmxlUG9zaXRpb24iLCJkcmFnZ2FibGUiLCJzZXRTdGF0ZSIsImZvcmNlVXBkYXRlIiwiZ2V0UGFyZW50IiwicmVzaXphYmxlIiwicGFyZW50Tm9kZSIsImdldFBhcmVudFNpemUiLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwiZ2V0U2VsZkVsZW1lbnQiLCJnZXRPZmZzZXRIZWlnaHQiLCJib3VuZGFyeSIsInNjYWxlIiwid2luZG93IiwiaW5uZXJIZWlnaHQiLCJkb2N1bWVudCIsImJvZHkiLCJvZmZzZXRIZWlnaHQiLCJnZXRPZmZzZXRXaWR0aCIsImlubmVyV2lkdGgiLCJvZmZzZXRXaWR0aCIsImRhdGEiLCJwb3MiLCJwYXJlbnQiLCJwYXJlbnRSZWN0XzEiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJwYXJlbnRMZWZ0XzEiLCJwYXJlbnRUb3BfMSIsImJvZHlSZWN0IiwibGVmdF8xIiwib2Zmc2V0TGVmdCIsInRvcF8xIiwib2Zmc2V0VG9wIiwic2l6ZSIsInBhcmVudFJlY3RfMiIsInBhcmVudExlZnRfMiIsInBhcmVudFRvcF8yIiwibGVmdF8yIiwidG9wXzIiLCJxdWVyeVNlbGVjdG9yIiwiSFRNTEVsZW1lbnQiLCJib3VuZGFyeVJlY3QiLCJib3VuZGFyeUxlZnQiLCJib3VuZGFyeVRvcCIsInBhcmVudFJlY3QiLCJwYXJlbnRMZWZ0IiwicGFyZW50VG9wIiwib2Zmc2V0IiwiZHJhZ0F4aXMiLCJkZWx0YVkiLCJkZWx0YVgiLCJkaXIiLCJlbGVtZW50UmVmIiwic3RvcFByb3BhZ2F0aW9uIiwicGFyZW50XzEiLCJzZWxmXzEiLCJFbGVtZW50IiwicGFyZW50U2l6ZSIsImVuZHNXaXRoIiwicmF0aW8iLCJyZXBsYWNlIiwic2VsZlJlY3QiLCJzZWxmTGVmdCIsInNlbGZUb3AiLCJoYXNMZWZ0IiwidG9Mb3dlckNhc2UiLCJoYXNSaWdodCIsImhhc1RvcCIsInN0YXJ0c1dpdGgiLCJoYXNCb3R0b20iLCJtYXgiLCJsb2NrQXNwZWN0UmF0aW8iLCJkaXJlY3Rpb24iLCJkZWx0YSIsIm5ld1BvcyIsImRpcmVjdGlvbnMiLCJpbmNsdWRlcyIsImRyYWdnYWJsZVN0YXRlIiwidXBkYXRlU2l6ZSIsInVwZGF0ZVBvc2l0aW9uIiwic2VsZiIsInNjcm9sbExlZnQiLCJzY3JvbGxUb3AiLCJyZW5kZXIiLCJkaXNhYmxlRHJhZ2dpbmciLCJzdHlsZSIsImRyYWdIYW5kbGVDbGFzc05hbWUiLCJvbk1vdXNlRG93biIsIm9uTW91c2VVcCIsImRyYWdHcmlkIiwiZW5hYmxlVXNlclNlbGVjdEhhY2siLCJjYW5jZWwiLCJjaGlsZHJlbiIsInJlc2l6ZUhhbmRsZVN0eWxlcyIsInJlc2l6ZUhhbmRsZUNsYXNzZXMiLCJyZXNpemVIYW5kbGVDb21wb25lbnQiLCJlbmFibGVSZXNpemluZyIsInJlc2l6ZUdyaWQiLCJyZXNpemVIYW5kbGVXcmFwcGVyQ2xhc3MiLCJyZXNpemVIYW5kbGVXcmFwcGVyU3R5bGUiLCJhbGxvd0FueUNsaWNrIiwiZHJhZ1Bvc2l0aW9uT2Zmc2V0IiwicmVzaXphYmxlUHJvcHMiLCJkZWZhdWx0VmFsdWUiLCJkZWZhdWx0IiwidW5kZWZpbmVkIiwiY3Vyc29yU3R5bGUiLCJjdXJzb3IiLCJpbm5lclN0eWxlIiwiZHJhZ2dhYmxlUG9zaXRpb24iLCJkcmFnQXhpc09yVW5kZWZpbmVkIiwicmVmIiwiYyIsImhhbmRsZSIsImNvbmNhdCIsImRlZmF1bHRQb3NpdGlvbiIsIm9uU3RhcnQiLCJvblN0b3AiLCJheGlzIiwiZGlzYWJsZWQiLCJncmlkIiwibm9kZVJlZiIsInBvc2l0aW9uT2Zmc2V0IiwiZGVmYXVsdFNpemUiLCJlbmFibGUiLCJtaW5XaWR0aCIsIm1pbkhlaWdodCIsImhhbmRsZVdyYXBwZXJDbGFzcyIsImhhbmRsZVdyYXBwZXJTdHlsZSIsImxvY2tBc3BlY3RSYXRpb0V4dHJhV2lkdGgiLCJsb2NrQXNwZWN0UmF0aW9FeHRyYUhlaWdodCIsImhhbmRsZVN0eWxlcyIsImhhbmRsZUNsYXNzZXMiLCJoYW5kbGVDb21wb25lbnQiLCJkZWZhdWx0UHJvcHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-rnd/lib/index.js\n"));

/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar printWarning = function() {};\n\nif (true) {\n  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n  var loggedTypeFailures = {};\n  var has = __webpack_require__(/*! ./lib/has */ \"./node_modules/prop-types/lib/has.js\");\n\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) { /**/ }\n  };\n}\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  if (true) {\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error;\n        // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            var err = Error(\n              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +\n              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' +\n              'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'\n            );\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n        } catch (ex) {\n          error = ex;\n        }\n        if (error && !(error instanceof Error)) {\n          printWarning(\n            (componentName || 'React class') + ': type specification of ' +\n            location + ' `' + typeSpecName + '` is invalid; the type checker ' +\n            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +\n            'You may have forgotten to pass an argument to the type checker ' +\n            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +\n            'shape all require an argument).'\n          );\n        }\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error.message] = true;\n\n          var stack = getStack ? getStack() : '';\n\n          printWarning(\n            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')\n          );\n        }\n      }\n    }\n  }\n}\n\n/**\n * Resets warning cache when testing.\n *\n * @private\n */\ncheckPropTypes.resetWarningCache = function() {\n  if (true) {\n    loggedTypeFailures = {};\n  }\n}\n\nmodule.exports = checkPropTypes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUEsSUFBSSxJQUFxQztBQUN6Qyw2QkFBNkIsbUJBQU8sQ0FBQyx5RkFBNEI7QUFDakU7QUFDQSxZQUFZLG1CQUFPLENBQUMsdURBQVc7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxZQUFZO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZHQUE2RztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanM/MjYyNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgdmFyIGhhcyA9IHJlcXVpcmUoJy4vbGliL2hhcycpO1xuXG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7IC8qKi8gfVxuICB9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcihcbiAgICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICtcbiAgICAgICAgICAgICAgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArXG4gICAgICAgICAgICAgICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICcgK1xuICAgICAgICAgICAgbG9jYXRpb24gKyAnIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAnICsgdHlwZW9mIGVycm9yICsgJy4gJyArXG4gICAgICAgICAgICAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICtcbiAgICAgICAgICAgICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdGYWlsZWQgJyArIGxvY2F0aW9uICsgJyB0eXBlOiAnICsgZXJyb3IubWVzc2FnZSArIChzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVzZXRzIHdhcm5pbmcgY2FjaGUgd2hlbiB0ZXN0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gZnVuY3Rpb24oKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/prop-types/checkPropTypes.js\n"));

/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactIs = __webpack_require__(/*! react-is */ \"./node_modules/react-is/index.js\");\nvar assign = __webpack_require__(/*! object-assign */ \"./node_modules/next/dist/build/polyfills/object-assign.js\");\n\nvar ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\nvar has = __webpack_require__(/*! ./lib/has */ \"./node_modules/prop-types/lib/has.js\");\nvar checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ \"./node_modules/prop-types/checkPropTypes.js\");\n\nvar printWarning = function() {};\n\nif (true) {\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\nfunction emptyFunctionThatReturnsNull() {\n  return null;\n}\n\nmodule.exports = function(isValidElement, throwOnDirectAccess) {\n  /* global Symbol */\n  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n  /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */\n  function getIteratorFn(maybeIterable) {\n    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */\n\n  var ANONYMOUS = '<<anonymous>>';\n\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n  var ReactPropTypes = {\n    array: createPrimitiveTypeChecker('array'),\n    bigint: createPrimitiveTypeChecker('bigint'),\n    bool: createPrimitiveTypeChecker('boolean'),\n    func: createPrimitiveTypeChecker('function'),\n    number: createPrimitiveTypeChecker('number'),\n    object: createPrimitiveTypeChecker('object'),\n    string: createPrimitiveTypeChecker('string'),\n    symbol: createPrimitiveTypeChecker('symbol'),\n\n    any: createAnyTypeChecker(),\n    arrayOf: createArrayOfTypeChecker,\n    element: createElementTypeChecker(),\n    elementType: createElementTypeTypeChecker(),\n    instanceOf: createInstanceTypeChecker,\n    node: createNodeChecker(),\n    objectOf: createObjectOfTypeChecker,\n    oneOf: createEnumTypeChecker,\n    oneOfType: createUnionTypeChecker,\n    shape: createShapeTypeChecker,\n    exact: createStrictShapeTypeChecker,\n  };\n\n  /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */\n  /*eslint-disable no-self-compare*/\n  function is(x, y) {\n    // SameValue algorithm\n    if (x === y) {\n      // Steps 1-5, 7-10\n      // Steps 6.b-6.e: +0 != -0\n      return x !== 0 || 1 / x === 1 / y;\n    } else {\n      // Step 6.a: NaN == NaN\n      return x !== x && y !== y;\n    }\n  }\n  /*eslint-enable no-self-compare*/\n\n  /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */\n  function PropTypeError(message, data) {\n    this.message = message;\n    this.data = data && typeof data === 'object' ? data: {};\n    this.stack = '';\n  }\n  // Make `instanceof Error` still work for returned errors.\n  PropTypeError.prototype = Error.prototype;\n\n  function createChainableTypeChecker(validate) {\n    if (true) {\n      var manualPropTypeCallCache = {};\n      var manualPropTypeWarningCount = 0;\n    }\n    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n      componentName = componentName || ANONYMOUS;\n      propFullName = propFullName || propName;\n\n      if (secret !== ReactPropTypesSecret) {\n        if (throwOnDirectAccess) {\n          // New behavior only for users of `prop-types` package\n          var err = new Error(\n            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n            'Use `PropTypes.checkPropTypes()` to call them. ' +\n            'Read more at http://fb.me/use-check-prop-types'\n          );\n          err.name = 'Invariant Violation';\n          throw err;\n        } else if ( true && typeof console !== 'undefined') {\n          // Old behavior for people using React.PropTypes\n          var cacheKey = componentName + ':' + propName;\n          if (\n            !manualPropTypeCallCache[cacheKey] &&\n            // Avoid spamming the console because they are often not actionable except for lib authors\n            manualPropTypeWarningCount < 3\n          ) {\n            printWarning(\n              'You are manually calling a React.PropTypes validation ' +\n              'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' +\n              'and will throw in the standalone `prop-types` package. ' +\n              'You may be seeing this warning due to a third-party PropTypes ' +\n              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'\n            );\n            manualPropTypeCallCache[cacheKey] = true;\n            manualPropTypeWarningCount++;\n          }\n        }\n      }\n      if (props[propName] == null) {\n        if (isRequired) {\n          if (props[propName] === null) {\n            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\n          }\n          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\n        }\n        return null;\n      } else {\n        return validate(props, propName, componentName, location, propFullName);\n      }\n    }\n\n    var chainedCheckType = checkType.bind(null, false);\n    chainedCheckType.isRequired = checkType.bind(null, true);\n\n    return chainedCheckType;\n  }\n\n  function createPrimitiveTypeChecker(expectedType) {\n    function validate(props, propName, componentName, location, propFullName, secret) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== expectedType) {\n        // `propValue` being instance of, say, date/regexp, pass the 'object'\n        // check, but we can offer a more precise error message here rather than\n        // 'of type `object`'.\n        var preciseType = getPreciseType(propValue);\n\n        return new PropTypeError(\n          'Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'),\n          {expectedType: expectedType}\n        );\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createAnyTypeChecker() {\n    return createChainableTypeChecker(emptyFunctionThatReturnsNull);\n  }\n\n  function createArrayOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\n      }\n      var propValue = props[propName];\n      if (!Array.isArray(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\n      }\n      for (var i = 0; i < propValue.length; i++) {\n        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);\n        if (error instanceof Error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!isValidElement(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!ReactIs.isValidElementType(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createInstanceTypeChecker(expectedClass) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!(props[propName] instanceof expectedClass)) {\n        var expectedClassName = expectedClass.name || ANONYMOUS;\n        var actualClassName = getClassName(props[propName]);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createEnumTypeChecker(expectedValues) {\n    if (!Array.isArray(expectedValues)) {\n      if (true) {\n        if (arguments.length > 1) {\n          printWarning(\n            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +\n            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'\n          );\n        } else {\n          printWarning('Invalid argument supplied to oneOf, expected an array.');\n        }\n      }\n      return emptyFunctionThatReturnsNull;\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      for (var i = 0; i < expectedValues.length; i++) {\n        if (is(propValue, expectedValues[i])) {\n          return null;\n        }\n      }\n\n      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {\n        var type = getPreciseType(value);\n        if (type === 'symbol') {\n          return String(value);\n        }\n        return value;\n      });\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createObjectOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\n      }\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\n      }\n      for (var key in propValue) {\n        if (has(propValue, key)) {\n          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n          if (error instanceof Error) {\n            return error;\n          }\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createUnionTypeChecker(arrayOfTypeCheckers) {\n    if (!Array.isArray(arrayOfTypeCheckers)) {\n       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : 0;\n      return emptyFunctionThatReturnsNull;\n    }\n\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n      var checker = arrayOfTypeCheckers[i];\n      if (typeof checker !== 'function') {\n        printWarning(\n          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +\n          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'\n        );\n        return emptyFunctionThatReturnsNull;\n      }\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var expectedTypes = [];\n      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n        var checker = arrayOfTypeCheckers[i];\n        var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);\n        if (checkerResult == null) {\n          return null;\n        }\n        if (checkerResult.data && has(checkerResult.data, 'expectedType')) {\n          expectedTypes.push(checkerResult.data.expectedType);\n        }\n      }\n      var expectedTypesMessage = (expectedTypes.length > 0) ? ', expected one of type [' + expectedTypes.join(', ') + ']': '';\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createNodeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!isNode(props[propName])) {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function invalidValidatorError(componentName, location, propFullName, key, type) {\n    return new PropTypeError(\n      (componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' +\n      'it must be a function, usually from the `prop-types` package, but received `' + type + '`.'\n    );\n  }\n\n  function createShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      for (var key in shapeTypes) {\n        var checker = shapeTypes[key];\n        if (typeof checker !== 'function') {\n          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createStrictShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      // We need to check all keys in case some are required but missing from props.\n      var allKeys = assign({}, props[propName], shapeTypes);\n      for (var key in allKeys) {\n        var checker = shapeTypes[key];\n        if (has(shapeTypes, key) && typeof checker !== 'function') {\n          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n        }\n        if (!checker) {\n          return new PropTypeError(\n            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +\n            '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') +\n            '\\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  ')\n          );\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function isNode(propValue) {\n    switch (typeof propValue) {\n      case 'number':\n      case 'string':\n      case 'undefined':\n        return true;\n      case 'boolean':\n        return !propValue;\n      case 'object':\n        if (Array.isArray(propValue)) {\n          return propValue.every(isNode);\n        }\n        if (propValue === null || isValidElement(propValue)) {\n          return true;\n        }\n\n        var iteratorFn = getIteratorFn(propValue);\n        if (iteratorFn) {\n          var iterator = iteratorFn.call(propValue);\n          var step;\n          if (iteratorFn !== propValue.entries) {\n            while (!(step = iterator.next()).done) {\n              if (!isNode(step.value)) {\n                return false;\n              }\n            }\n          } else {\n            // Iterator will provide entry [k,v] tuples rather than values.\n            while (!(step = iterator.next()).done) {\n              var entry = step.value;\n              if (entry) {\n                if (!isNode(entry[1])) {\n                  return false;\n                }\n              }\n            }\n          }\n        } else {\n          return false;\n        }\n\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  function isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === 'symbol') {\n      return true;\n    }\n\n    // falsy value can't be a Symbol\n    if (!propValue) {\n      return false;\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue['@@toStringTag'] === 'Symbol') {\n      return true;\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === 'function' && propValue instanceof Symbol) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // Equivalent of `typeof` but with special handling for array and regexp.\n  function getPropType(propValue) {\n    var propType = typeof propValue;\n    if (Array.isArray(propValue)) {\n      return 'array';\n    }\n    if (propValue instanceof RegExp) {\n      // Old webkits (at least until Android 4.0) return 'function' rather than\n      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n      // passes PropTypes.object.\n      return 'object';\n    }\n    if (isSymbol(propType, propValue)) {\n      return 'symbol';\n    }\n    return propType;\n  }\n\n  // This handles more types than `getPropType`. Only used for error messages.\n  // See `createPrimitiveTypeChecker`.\n  function getPreciseType(propValue) {\n    if (typeof propValue === 'undefined' || propValue === null) {\n      return '' + propValue;\n    }\n    var propType = getPropType(propValue);\n    if (propType === 'object') {\n      if (propValue instanceof Date) {\n        return 'date';\n      } else if (propValue instanceof RegExp) {\n        return 'regexp';\n      }\n    }\n    return propType;\n  }\n\n  // Returns a string that is postfixed to a warning about an invalid type.\n  // For example, \"undefined\" or \"of type array\"\n  function getPostfixForTypeWarning(value) {\n    var type = getPreciseType(value);\n    switch (type) {\n      case 'array':\n      case 'object':\n        return 'an ' + type;\n      case 'boolean':\n      case 'date':\n      case 'regexp':\n        return 'a ' + type;\n      default:\n        return type;\n    }\n  }\n\n  // Returns class name of the object, if any.\n  function getClassName(propValue) {\n    if (!propValue.constructor || !propValue.constructor.name) {\n      return ANONYMOUS;\n    }\n    return propValue.constructor.name;\n  }\n\n  ReactPropTypes.checkPropTypes = checkPropTypes;\n  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLGtEQUFVO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyxnRkFBZTs7QUFFcEMsMkJBQTJCLG1CQUFPLENBQUMseUZBQTRCO0FBQy9ELFVBQVUsbUJBQU8sQ0FBQyx1REFBVztBQUM3QixxQkFBcUIsbUJBQU8sQ0FBQyxxRUFBa0I7O0FBRS9DOztBQUVBLElBQUksSUFBcUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsOEJBQThCO0FBQzlCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCO0FBQzVCLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsU0FBUyxLQUFxQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsSUFBcUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQyw0RkFBNEYsQ0FBTTtBQUM3STtBQUNBOztBQUVBLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsZ0NBQWdDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpSEFBaUg7QUFDakg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzP2I3NmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9saWIvaGFzJyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCcuL2NoZWNrUHJvcFR5cGVzJyk7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gICAqXG4gICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICAgKlxuICAgKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICAgKiAgICAgICAuLi5cbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAgICpcbiAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAgICogICAgIH0sXG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gICAqXG4gICAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAgICpcbiAgICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gICAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAgICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAqICAgICAgICAgICk7XG4gICAqICAgICAgICB9XG4gICAqICAgICAgfVxuICAgKiAgICB9LFxuICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAgICogIH0pO1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgICBiaWdpbnQ6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdiaWdpbnQnKSxcbiAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICAgIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICAgIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgICBlbGVtZW50VHlwZTogY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSwgZGF0YSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5kYXRhID0gZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgPyBkYXRhOiB7fTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAnVXNlIGBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKWAgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBwcm9wIG9uIGAnICsgY29tcG9uZW50TmFtZSArICdgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSxcbiAgICAgICAgICB7ZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGV9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghUmVhY3RJcy5pc1ZhbGlkRWxlbWVudFR5cGUocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQgdHlwZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50cyBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXksIGdvdCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLiAnICtcbiAgICAgICAgICAgICdBIGNvbW1vbiBtaXN0YWtlIGlzIHRvIHdyaXRlIG9uZU9mKHgsIHksIHopIGluc3RlYWQgb2Ygb25lT2YoW3gsIHksIHpdKS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcywgZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgU3RyaW5nKHByb3BWYWx1ZSkgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKGhhcyhwcm9wVmFsdWUsIGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICcgKyBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlcikgKyAnIGF0IGluZGV4ICcgKyBpICsgJy4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICAgIHZhciBjaGVja2VyUmVzdWx0ID0gY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGNoZWNrZXJSZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGVja2VyUmVzdWx0LmRhdGEgJiYgaGFzKGNoZWNrZXJSZXN1bHQuZGF0YSwgJ2V4cGVjdGVkVHlwZScpKSB7XG4gICAgICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGNoZWNrZXJSZXN1bHQuZGF0YS5leHBlY3RlZFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZXhwZWN0ZWRUeXBlc01lc3NhZ2UgPSAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPiAwKSA/ICcsIGV4cGVjdGVkIG9uZSBvZiB0eXBlIFsnICsgZXhwZWN0ZWRUeXBlcy5qb2luKCcsICcpICsgJ10nOiAnJztcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AnICsgZXhwZWN0ZWRUeXBlc01lc3NhZ2UgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludmFsaWRWYWxpZGF0b3JFcnJvcihjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBrZXksIHR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHByb3BGdWxsTmFtZSArICcuJyArIGtleSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZSArICdgLidcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBpbnZhbGlkVmFsaWRhdG9yRXJyb3IoY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwga2V5LCBnZXRQcmVjaXNlVHlwZShjaGVja2VyKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBhbGwga2V5cyBpbiBjYXNlIHNvbWUgYXJlIHJlcXVpcmVkIGJ1dCBtaXNzaW5nIGZyb20gcHJvcHMuXG4gICAgICB2YXIgYWxsS2V5cyA9IGFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoaGFzKHNoYXBlVHlwZXMsIGtleSkgJiYgdHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gaW52YWxpZFZhbGlkYXRvckVycm9yKGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIGtleSwgZ2V0UHJlY2lzZVR5cGUoY2hlY2tlcikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHNoYXBlVHlwZXMpLCBudWxsLCAnICAnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IGlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgICAvLyBOYXRpdmUgU3ltYm9sLlxuICAgIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGZhbHN5IHZhbHVlIGNhbid0IGJlIGEgU3ltYm9sXG4gICAgaWYgKCFwcm9wVmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZSA9IGNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/prop-types/factoryWithTypeCheckers.js\n"));

/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (true) {\n  var ReactIs = __webpack_require__(/*! react-is */ \"./node_modules/react-is/index.js\");\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ \"./node_modules/prop-types/factoryWithTypeCheckers.js\")(ReactIs.isElement, throwOnDirectAccess);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxJQUFxQztBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxrREFBVTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsdUZBQTJCO0FBQ3RELEVBQUUsS0FBSyxFQUlOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzP2JkZTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RJcyA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKShSZWFjdElzLmlzRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMnKSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/prop-types/index.js\n"));

/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcz9lMDk4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/prop-types/lib/ReactPropTypesSecret.js\n"));

/***/ }),

/***/ "./node_modules/prop-types/lib/has.js":
/*!********************************************!*\
  !*** ./node_modules/prop-types/lib/has.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = Function.call.bind(Object.prototype.hasOwnProperty);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvaGFzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9oYXMuanM/ZTQ3MCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/prop-types/lib/has.js\n"));

/***/ }),

/***/ "./node_modules/re-resizable/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/re-resizable/lib/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Resizable\": function() { return /* binding */ Resizable; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _resizer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resizer */ \"./node_modules/re-resizable/lib/resizer.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\n\n\n\nvar DEFAULT_SIZE = {\n    width: 'auto',\n    height: 'auto',\n};\nvar clamp = function (n, min, max) { return Math.max(Math.min(n, max), min); };\nvar snap = function (n, size, gridGap) {\n    var v = Math.round(n / size);\n    return v * size + gridGap * (v - 1);\n};\nvar hasDirection = function (dir, target) {\n    return new RegExp(dir, 'i').test(target);\n};\n// INFO: In case of window is a Proxy and does not porxy Events correctly, use isTouchEvent & isMouseEvent to distinguish event type instead of `instanceof`.\nvar isTouchEvent = function (event) {\n    return Boolean(event.touches && event.touches.length);\n};\nvar isMouseEvent = function (event) {\n    return Boolean((event.clientX || event.clientX === 0) &&\n        (event.clientY || event.clientY === 0));\n};\nvar findClosestSnap = function (n, snapArray, snapGap) {\n    if (snapGap === void 0) { snapGap = 0; }\n    var closestGapIndex = snapArray.reduce(function (prev, curr, index) { return (Math.abs(curr - n) < Math.abs(snapArray[prev] - n) ? index : prev); }, 0);\n    var gap = Math.abs(snapArray[closestGapIndex] - n);\n    return snapGap === 0 || gap < snapGap ? snapArray[closestGapIndex] : n;\n};\nvar getStringSize = function (n) {\n    n = n.toString();\n    if (n === 'auto') {\n        return n;\n    }\n    if (n.endsWith('px')) {\n        return n;\n    }\n    if (n.endsWith('%')) {\n        return n;\n    }\n    if (n.endsWith('vh')) {\n        return n;\n    }\n    if (n.endsWith('vw')) {\n        return n;\n    }\n    if (n.endsWith('vmax')) {\n        return n;\n    }\n    if (n.endsWith('vmin')) {\n        return n;\n    }\n    return \"\".concat(n, \"px\");\n};\nvar getPixelSize = function (size, parentSize, innerWidth, innerHeight) {\n    if (size && typeof size === 'string') {\n        if (size.endsWith('px')) {\n            return Number(size.replace('px', ''));\n        }\n        if (size.endsWith('%')) {\n            var ratio = Number(size.replace('%', '')) / 100;\n            return parentSize * ratio;\n        }\n        if (size.endsWith('vw')) {\n            var ratio = Number(size.replace('vw', '')) / 100;\n            return innerWidth * ratio;\n        }\n        if (size.endsWith('vh')) {\n            var ratio = Number(size.replace('vh', '')) / 100;\n            return innerHeight * ratio;\n        }\n    }\n    return size;\n};\nvar calculateNewMax = function (parentSize, innerWidth, innerHeight, maxWidth, maxHeight, minWidth, minHeight) {\n    maxWidth = getPixelSize(maxWidth, parentSize.width, innerWidth, innerHeight);\n    maxHeight = getPixelSize(maxHeight, parentSize.height, innerWidth, innerHeight);\n    minWidth = getPixelSize(minWidth, parentSize.width, innerWidth, innerHeight);\n    minHeight = getPixelSize(minHeight, parentSize.height, innerWidth, innerHeight);\n    return {\n        maxWidth: typeof maxWidth === 'undefined' ? undefined : Number(maxWidth),\n        maxHeight: typeof maxHeight === 'undefined' ? undefined : Number(maxHeight),\n        minWidth: typeof minWidth === 'undefined' ? undefined : Number(minWidth),\n        minHeight: typeof minHeight === 'undefined' ? undefined : Number(minHeight),\n    };\n};\n/**\n * transform T | [T, T] to [T, T]\n * @param val\n * @returns\n */\n// tslint:disable-next-line\nvar normalizeToPair = function (val) { return (Array.isArray(val) ? val : [val, val]); };\nvar definedProps = [\n    'as',\n    'ref',\n    'style',\n    'className',\n    'grid',\n    'gridGap',\n    'snap',\n    'bounds',\n    'boundsByDirection',\n    'size',\n    'defaultSize',\n    'minWidth',\n    'minHeight',\n    'maxWidth',\n    'maxHeight',\n    'lockAspectRatio',\n    'lockAspectRatioExtraWidth',\n    'lockAspectRatioExtraHeight',\n    'enable',\n    'handleStyles',\n    'handleClasses',\n    'handleWrapperStyle',\n    'handleWrapperClass',\n    'children',\n    'onResizeStart',\n    'onResize',\n    'onResizeStop',\n    'handleComponent',\n    'scale',\n    'resizeRatio',\n    'snapGap',\n];\n// HACK: This class is used to calculate % size.\nvar baseClassName = '__resizable_base__';\nvar Resizable = /** @class */ (function (_super) {\n    __extends(Resizable, _super);\n    function Resizable(props) {\n        var _a, _b, _c, _d;\n        var _this = _super.call(this, props) || this;\n        _this.ratio = 1;\n        _this.resizable = null;\n        // For parent boundary\n        _this.parentLeft = 0;\n        _this.parentTop = 0;\n        // For boundary\n        _this.resizableLeft = 0;\n        _this.resizableRight = 0;\n        _this.resizableTop = 0;\n        _this.resizableBottom = 0;\n        // For target boundary\n        _this.targetLeft = 0;\n        _this.targetTop = 0;\n        _this.delta = {\n            width: 0,\n            height: 0,\n        };\n        _this.appendBase = function () {\n            if (!_this.resizable || !_this.window) {\n                return null;\n            }\n            var parent = _this.parentNode;\n            if (!parent) {\n                return null;\n            }\n            var element = _this.window.document.createElement('div');\n            element.style.width = '100%';\n            element.style.height = '100%';\n            element.style.position = 'absolute';\n            element.style.transform = 'scale(0, 0)';\n            element.style.left = '0';\n            element.style.flex = '0 0 100%';\n            if (element.classList) {\n                element.classList.add(baseClassName);\n            }\n            else {\n                element.className += baseClassName;\n            }\n            parent.appendChild(element);\n            return element;\n        };\n        _this.removeBase = function (base) {\n            var parent = _this.parentNode;\n            if (!parent) {\n                return;\n            }\n            parent.removeChild(base);\n        };\n        _this.state = {\n            isResizing: false,\n            width: (_b = (_a = _this.propsSize) === null || _a === void 0 ? void 0 : _a.width) !== null && _b !== void 0 ? _b : 'auto',\n            height: (_d = (_c = _this.propsSize) === null || _c === void 0 ? void 0 : _c.height) !== null && _d !== void 0 ? _d : 'auto',\n            direction: 'right',\n            original: {\n                x: 0,\n                y: 0,\n                width: 0,\n                height: 0,\n            },\n            backgroundStyle: {\n                height: '100%',\n                width: '100%',\n                backgroundColor: 'rgba(0,0,0,0)',\n                cursor: 'auto',\n                opacity: 0,\n                position: 'fixed',\n                zIndex: 9999,\n                top: '0',\n                left: '0',\n                bottom: '0',\n                right: '0',\n            },\n            flexBasis: undefined,\n        };\n        _this.onResizeStart = _this.onResizeStart.bind(_this);\n        _this.onMouseMove = _this.onMouseMove.bind(_this);\n        _this.onMouseUp = _this.onMouseUp.bind(_this);\n        return _this;\n    }\n    Object.defineProperty(Resizable.prototype, \"parentNode\", {\n        get: function () {\n            if (!this.resizable) {\n                return null;\n            }\n            return this.resizable.parentNode;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Resizable.prototype, \"window\", {\n        get: function () {\n            if (!this.resizable) {\n                return null;\n            }\n            if (!this.resizable.ownerDocument) {\n                return null;\n            }\n            return this.resizable.ownerDocument.defaultView;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Resizable.prototype, \"propsSize\", {\n        get: function () {\n            return this.props.size || this.props.defaultSize || DEFAULT_SIZE;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Resizable.prototype, \"size\", {\n        get: function () {\n            var width = 0;\n            var height = 0;\n            if (this.resizable && this.window) {\n                var orgWidth = this.resizable.offsetWidth;\n                var orgHeight = this.resizable.offsetHeight;\n                // HACK: Set position `relative` to get parent size.\n                //       This is because when re-resizable set `absolute`, I can not get base width correctly.\n                var orgPosition = this.resizable.style.position;\n                if (orgPosition !== 'relative') {\n                    this.resizable.style.position = 'relative';\n                }\n                // INFO: Use original width or height if set auto.\n                width = this.resizable.style.width !== 'auto' ? this.resizable.offsetWidth : orgWidth;\n                height = this.resizable.style.height !== 'auto' ? this.resizable.offsetHeight : orgHeight;\n                // Restore original position\n                this.resizable.style.position = orgPosition;\n            }\n            return { width: width, height: height };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Resizable.prototype, \"sizeStyle\", {\n        get: function () {\n            var _this = this;\n            var size = this.props.size;\n            var getSize = function (key) {\n                var _a;\n                if (typeof _this.state[key] === 'undefined' || _this.state[key] === 'auto') {\n                    return 'auto';\n                }\n                if (_this.propsSize && _this.propsSize[key] && ((_a = _this.propsSize[key]) === null || _a === void 0 ? void 0 : _a.toString().endsWith('%'))) {\n                    if (_this.state[key].toString().endsWith('%')) {\n                        return _this.state[key].toString();\n                    }\n                    var parentSize = _this.getParentSize();\n                    var value = Number(_this.state[key].toString().replace('px', ''));\n                    var percent = (value / parentSize[key]) * 100;\n                    return \"\".concat(percent, \"%\");\n                }\n                return getStringSize(_this.state[key]);\n            };\n            var width = size && typeof size.width !== 'undefined' && !this.state.isResizing\n                ? getStringSize(size.width)\n                : getSize('width');\n            var height = size && typeof size.height !== 'undefined' && !this.state.isResizing\n                ? getStringSize(size.height)\n                : getSize('height');\n            return { width: width, height: height };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Resizable.prototype.getParentSize = function () {\n        if (!this.parentNode) {\n            if (!this.window) {\n                return { width: 0, height: 0 };\n            }\n            return { width: this.window.innerWidth, height: this.window.innerHeight };\n        }\n        var base = this.appendBase();\n        if (!base) {\n            return { width: 0, height: 0 };\n        }\n        // INFO: To calculate parent width with flex layout\n        var wrapChanged = false;\n        var wrap = this.parentNode.style.flexWrap;\n        if (wrap !== 'wrap') {\n            wrapChanged = true;\n            this.parentNode.style.flexWrap = 'wrap';\n            // HACK: Use relative to get parent padding size\n        }\n        base.style.position = 'relative';\n        base.style.minWidth = '100%';\n        base.style.minHeight = '100%';\n        var size = {\n            width: base.offsetWidth,\n            height: base.offsetHeight,\n        };\n        if (wrapChanged) {\n            this.parentNode.style.flexWrap = wrap;\n        }\n        this.removeBase(base);\n        return size;\n    };\n    Resizable.prototype.bindEvents = function () {\n        if (this.window) {\n            this.window.addEventListener('mouseup', this.onMouseUp);\n            this.window.addEventListener('mousemove', this.onMouseMove);\n            this.window.addEventListener('mouseleave', this.onMouseUp);\n            this.window.addEventListener('touchmove', this.onMouseMove, {\n                capture: true,\n                passive: false,\n            });\n            this.window.addEventListener('touchend', this.onMouseUp);\n        }\n    };\n    Resizable.prototype.unbindEvents = function () {\n        if (this.window) {\n            this.window.removeEventListener('mouseup', this.onMouseUp);\n            this.window.removeEventListener('mousemove', this.onMouseMove);\n            this.window.removeEventListener('mouseleave', this.onMouseUp);\n            this.window.removeEventListener('touchmove', this.onMouseMove, true);\n            this.window.removeEventListener('touchend', this.onMouseUp);\n        }\n    };\n    Resizable.prototype.componentDidMount = function () {\n        if (!this.resizable || !this.window) {\n            return;\n        }\n        var computedStyle = this.window.getComputedStyle(this.resizable);\n        this.setState({\n            width: this.state.width || this.size.width,\n            height: this.state.height || this.size.height,\n            flexBasis: computedStyle.flexBasis !== 'auto' ? computedStyle.flexBasis : undefined,\n        });\n    };\n    Resizable.prototype.componentWillUnmount = function () {\n        if (this.window) {\n            this.unbindEvents();\n        }\n    };\n    Resizable.prototype.createSizeForCssProperty = function (newSize, kind) {\n        var propsSize = this.propsSize && this.propsSize[kind];\n        return this.state[kind] === 'auto' &&\n            this.state.original[kind] === newSize &&\n            (typeof propsSize === 'undefined' || propsSize === 'auto')\n            ? 'auto'\n            : newSize;\n    };\n    Resizable.prototype.calculateNewMaxFromBoundary = function (maxWidth, maxHeight) {\n        var boundsByDirection = this.props.boundsByDirection;\n        var direction = this.state.direction;\n        var widthByDirection = boundsByDirection && hasDirection('left', direction);\n        var heightByDirection = boundsByDirection && hasDirection('top', direction);\n        var boundWidth;\n        var boundHeight;\n        if (this.props.bounds === 'parent') {\n            var parent_1 = this.parentNode;\n            if (parent_1) {\n                boundWidth = widthByDirection\n                    ? this.resizableRight - this.parentLeft\n                    : parent_1.offsetWidth + (this.parentLeft - this.resizableLeft);\n                boundHeight = heightByDirection\n                    ? this.resizableBottom - this.parentTop\n                    : parent_1.offsetHeight + (this.parentTop - this.resizableTop);\n            }\n        }\n        else if (this.props.bounds === 'window') {\n            if (this.window) {\n                boundWidth = widthByDirection ? this.resizableRight : this.window.innerWidth - this.resizableLeft;\n                boundHeight = heightByDirection ? this.resizableBottom : this.window.innerHeight - this.resizableTop;\n            }\n        }\n        else if (this.props.bounds) {\n            boundWidth = widthByDirection\n                ? this.resizableRight - this.targetLeft\n                : this.props.bounds.offsetWidth + (this.targetLeft - this.resizableLeft);\n            boundHeight = heightByDirection\n                ? this.resizableBottom - this.targetTop\n                : this.props.bounds.offsetHeight + (this.targetTop - this.resizableTop);\n        }\n        if (boundWidth && Number.isFinite(boundWidth)) {\n            maxWidth = maxWidth && maxWidth < boundWidth ? maxWidth : boundWidth;\n        }\n        if (boundHeight && Number.isFinite(boundHeight)) {\n            maxHeight = maxHeight && maxHeight < boundHeight ? maxHeight : boundHeight;\n        }\n        return { maxWidth: maxWidth, maxHeight: maxHeight };\n    };\n    Resizable.prototype.calculateNewSizeFromDirection = function (clientX, clientY) {\n        var scale = this.props.scale || 1;\n        var _a = normalizeToPair(this.props.resizeRatio || 1), resizeRatioX = _a[0], resizeRatioY = _a[1];\n        var _b = this.state, direction = _b.direction, original = _b.original;\n        var _c = this.props, lockAspectRatio = _c.lockAspectRatio, lockAspectRatioExtraHeight = _c.lockAspectRatioExtraHeight, lockAspectRatioExtraWidth = _c.lockAspectRatioExtraWidth;\n        var newWidth = original.width;\n        var newHeight = original.height;\n        var extraHeight = lockAspectRatioExtraHeight || 0;\n        var extraWidth = lockAspectRatioExtraWidth || 0;\n        if (hasDirection('right', direction)) {\n            newWidth = original.width + ((clientX - original.x) * resizeRatioX) / scale;\n            if (lockAspectRatio) {\n                newHeight = (newWidth - extraWidth) / this.ratio + extraHeight;\n            }\n        }\n        if (hasDirection('left', direction)) {\n            newWidth = original.width - ((clientX - original.x) * resizeRatioX) / scale;\n            if (lockAspectRatio) {\n                newHeight = (newWidth - extraWidth) / this.ratio + extraHeight;\n            }\n        }\n        if (hasDirection('bottom', direction)) {\n            newHeight = original.height + ((clientY - original.y) * resizeRatioY) / scale;\n            if (lockAspectRatio) {\n                newWidth = (newHeight - extraHeight) * this.ratio + extraWidth;\n            }\n        }\n        if (hasDirection('top', direction)) {\n            newHeight = original.height - ((clientY - original.y) * resizeRatioY) / scale;\n            if (lockAspectRatio) {\n                newWidth = (newHeight - extraHeight) * this.ratio + extraWidth;\n            }\n        }\n        return { newWidth: newWidth, newHeight: newHeight };\n    };\n    Resizable.prototype.calculateNewSizeFromAspectRatio = function (newWidth, newHeight, max, min) {\n        var _a = this.props, lockAspectRatio = _a.lockAspectRatio, lockAspectRatioExtraHeight = _a.lockAspectRatioExtraHeight, lockAspectRatioExtraWidth = _a.lockAspectRatioExtraWidth;\n        var computedMinWidth = typeof min.width === 'undefined' ? 10 : min.width;\n        var computedMaxWidth = typeof max.width === 'undefined' || max.width < 0 ? newWidth : max.width;\n        var computedMinHeight = typeof min.height === 'undefined' ? 10 : min.height;\n        var computedMaxHeight = typeof max.height === 'undefined' || max.height < 0 ? newHeight : max.height;\n        var extraHeight = lockAspectRatioExtraHeight || 0;\n        var extraWidth = lockAspectRatioExtraWidth || 0;\n        if (lockAspectRatio) {\n            var extraMinWidth = (computedMinHeight - extraHeight) * this.ratio + extraWidth;\n            var extraMaxWidth = (computedMaxHeight - extraHeight) * this.ratio + extraWidth;\n            var extraMinHeight = (computedMinWidth - extraWidth) / this.ratio + extraHeight;\n            var extraMaxHeight = (computedMaxWidth - extraWidth) / this.ratio + extraHeight;\n            var lockedMinWidth = Math.max(computedMinWidth, extraMinWidth);\n            var lockedMaxWidth = Math.min(computedMaxWidth, extraMaxWidth);\n            var lockedMinHeight = Math.max(computedMinHeight, extraMinHeight);\n            var lockedMaxHeight = Math.min(computedMaxHeight, extraMaxHeight);\n            newWidth = clamp(newWidth, lockedMinWidth, lockedMaxWidth);\n            newHeight = clamp(newHeight, lockedMinHeight, lockedMaxHeight);\n        }\n        else {\n            newWidth = clamp(newWidth, computedMinWidth, computedMaxWidth);\n            newHeight = clamp(newHeight, computedMinHeight, computedMaxHeight);\n        }\n        return { newWidth: newWidth, newHeight: newHeight };\n    };\n    Resizable.prototype.setBoundingClientRect = function () {\n        var adjustedScale = 1 / (this.props.scale || 1);\n        // For parent boundary\n        if (this.props.bounds === 'parent') {\n            var parent_2 = this.parentNode;\n            if (parent_2) {\n                var parentRect = parent_2.getBoundingClientRect();\n                this.parentLeft = parentRect.left * adjustedScale;\n                this.parentTop = parentRect.top * adjustedScale;\n            }\n        }\n        // For target(html element) boundary\n        if (this.props.bounds && typeof this.props.bounds !== 'string') {\n            var targetRect = this.props.bounds.getBoundingClientRect();\n            this.targetLeft = targetRect.left * adjustedScale;\n            this.targetTop = targetRect.top * adjustedScale;\n        }\n        // For boundary\n        if (this.resizable) {\n            var _a = this.resizable.getBoundingClientRect(), left = _a.left, top_1 = _a.top, right = _a.right, bottom = _a.bottom;\n            this.resizableLeft = left * adjustedScale;\n            this.resizableRight = right * adjustedScale;\n            this.resizableTop = top_1 * adjustedScale;\n            this.resizableBottom = bottom * adjustedScale;\n        }\n    };\n    Resizable.prototype.onResizeStart = function (event, direction) {\n        if (!this.resizable || !this.window) {\n            return;\n        }\n        var clientX = 0;\n        var clientY = 0;\n        if (event.nativeEvent && isMouseEvent(event.nativeEvent)) {\n            clientX = event.nativeEvent.clientX;\n            clientY = event.nativeEvent.clientY;\n        }\n        else if (event.nativeEvent && isTouchEvent(event.nativeEvent)) {\n            clientX = event.nativeEvent.touches[0].clientX;\n            clientY = event.nativeEvent.touches[0].clientY;\n        }\n        if (this.props.onResizeStart) {\n            if (this.resizable) {\n                var startResize = this.props.onResizeStart(event, direction, this.resizable);\n                if (startResize === false) {\n                    return;\n                }\n            }\n        }\n        // Fix #168\n        if (this.props.size) {\n            if (typeof this.props.size.height !== 'undefined' && this.props.size.height !== this.state.height) {\n                this.setState({ height: this.props.size.height });\n            }\n            if (typeof this.props.size.width !== 'undefined' && this.props.size.width !== this.state.width) {\n                this.setState({ width: this.props.size.width });\n            }\n        }\n        // For lockAspectRatio case\n        this.ratio =\n            typeof this.props.lockAspectRatio === 'number' ? this.props.lockAspectRatio : this.size.width / this.size.height;\n        var flexBasis;\n        var computedStyle = this.window.getComputedStyle(this.resizable);\n        if (computedStyle.flexBasis !== 'auto') {\n            var parent_3 = this.parentNode;\n            if (parent_3) {\n                var dir = this.window.getComputedStyle(parent_3).flexDirection;\n                this.flexDir = dir.startsWith('row') ? 'row' : 'column';\n                flexBasis = computedStyle.flexBasis;\n            }\n        }\n        // For boundary\n        this.setBoundingClientRect();\n        this.bindEvents();\n        var state = {\n            original: {\n                x: clientX,\n                y: clientY,\n                width: this.size.width,\n                height: this.size.height,\n            },\n            isResizing: true,\n            backgroundStyle: __assign(__assign({}, this.state.backgroundStyle), { cursor: this.window.getComputedStyle(event.target).cursor || 'auto' }),\n            direction: direction,\n            flexBasis: flexBasis,\n        };\n        this.setState(state);\n    };\n    Resizable.prototype.onMouseMove = function (event) {\n        var _this = this;\n        if (!this.state.isResizing || !this.resizable || !this.window) {\n            return;\n        }\n        if (this.window.TouchEvent && isTouchEvent(event)) {\n            try {\n                event.preventDefault();\n                event.stopPropagation();\n            }\n            catch (e) {\n                // Ignore on fail\n            }\n        }\n        var _a = this.props, maxWidth = _a.maxWidth, maxHeight = _a.maxHeight, minWidth = _a.minWidth, minHeight = _a.minHeight;\n        var clientX = isTouchEvent(event) ? event.touches[0].clientX : event.clientX;\n        var clientY = isTouchEvent(event) ? event.touches[0].clientY : event.clientY;\n        var _b = this.state, direction = _b.direction, original = _b.original, width = _b.width, height = _b.height;\n        var parentSize = this.getParentSize();\n        var max = calculateNewMax(parentSize, this.window.innerWidth, this.window.innerHeight, maxWidth, maxHeight, minWidth, minHeight);\n        maxWidth = max.maxWidth;\n        maxHeight = max.maxHeight;\n        minWidth = max.minWidth;\n        minHeight = max.minHeight;\n        // Calculate new size\n        var _c = this.calculateNewSizeFromDirection(clientX, clientY), newHeight = _c.newHeight, newWidth = _c.newWidth;\n        // Calculate max size from boundary settings\n        var boundaryMax = this.calculateNewMaxFromBoundary(maxWidth, maxHeight);\n        if (this.props.snap && this.props.snap.x) {\n            newWidth = findClosestSnap(newWidth, this.props.snap.x, this.props.snapGap);\n        }\n        if (this.props.snap && this.props.snap.y) {\n            newHeight = findClosestSnap(newHeight, this.props.snap.y, this.props.snapGap);\n        }\n        // Calculate new size from aspect ratio\n        var newSize = this.calculateNewSizeFromAspectRatio(newWidth, newHeight, { width: boundaryMax.maxWidth, height: boundaryMax.maxHeight }, { width: minWidth, height: minHeight });\n        newWidth = newSize.newWidth;\n        newHeight = newSize.newHeight;\n        if (this.props.grid) {\n            var newGridWidth = snap(newWidth, this.props.grid[0], this.props.gridGap ? this.props.gridGap[0] : 0);\n            var newGridHeight = snap(newHeight, this.props.grid[1], this.props.gridGap ? this.props.gridGap[1] : 0);\n            var gap = this.props.snapGap || 0;\n            var w = gap === 0 || Math.abs(newGridWidth - newWidth) <= gap ? newGridWidth : newWidth;\n            var h = gap === 0 || Math.abs(newGridHeight - newHeight) <= gap ? newGridHeight : newHeight;\n            newWidth = w;\n            newHeight = h;\n        }\n        var delta = {\n            width: newWidth - original.width,\n            height: newHeight - original.height,\n        };\n        this.delta = delta;\n        if (width && typeof width === 'string') {\n            if (width.endsWith('%')) {\n                var percent = (newWidth / parentSize.width) * 100;\n                newWidth = \"\".concat(percent, \"%\");\n            }\n            else if (width.endsWith('vw')) {\n                var vw = (newWidth / this.window.innerWidth) * 100;\n                newWidth = \"\".concat(vw, \"vw\");\n            }\n            else if (width.endsWith('vh')) {\n                var vh = (newWidth / this.window.innerHeight) * 100;\n                newWidth = \"\".concat(vh, \"vh\");\n            }\n        }\n        if (height && typeof height === 'string') {\n            if (height.endsWith('%')) {\n                var percent = (newHeight / parentSize.height) * 100;\n                newHeight = \"\".concat(percent, \"%\");\n            }\n            else if (height.endsWith('vw')) {\n                var vw = (newHeight / this.window.innerWidth) * 100;\n                newHeight = \"\".concat(vw, \"vw\");\n            }\n            else if (height.endsWith('vh')) {\n                var vh = (newHeight / this.window.innerHeight) * 100;\n                newHeight = \"\".concat(vh, \"vh\");\n            }\n        }\n        var newState = {\n            width: this.createSizeForCssProperty(newWidth, 'width'),\n            height: this.createSizeForCssProperty(newHeight, 'height'),\n        };\n        if (this.flexDir === 'row') {\n            newState.flexBasis = newState.width;\n        }\n        else if (this.flexDir === 'column') {\n            newState.flexBasis = newState.height;\n        }\n        var widthChanged = this.state.width !== newState.width;\n        var heightChanged = this.state.height !== newState.height;\n        var flexBaseChanged = this.state.flexBasis !== newState.flexBasis;\n        var changed = widthChanged || heightChanged || flexBaseChanged;\n        if (changed) {\n            // For v18, update state sync\n            (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.flushSync)(function () {\n                _this.setState(newState);\n            });\n        }\n        if (this.props.onResize) {\n            if (changed) {\n                this.props.onResize(event, direction, this.resizable, delta);\n            }\n        }\n    };\n    Resizable.prototype.onMouseUp = function (event) {\n        var _a, _b;\n        var _c = this.state, isResizing = _c.isResizing, direction = _c.direction, original = _c.original;\n        if (!isResizing || !this.resizable) {\n            return;\n        }\n        if (this.props.onResizeStop) {\n            this.props.onResizeStop(event, direction, this.resizable, this.delta);\n        }\n        if (this.props.size) {\n            this.setState({ width: (_a = this.props.size.width) !== null && _a !== void 0 ? _a : 'auto', height: (_b = this.props.size.height) !== null && _b !== void 0 ? _b : 'auto' });\n        }\n        this.unbindEvents();\n        this.setState({\n            isResizing: false,\n            backgroundStyle: __assign(__assign({}, this.state.backgroundStyle), { cursor: 'auto' }),\n        });\n    };\n    Resizable.prototype.updateSize = function (size) {\n        var _a, _b;\n        this.setState({ width: (_a = size.width) !== null && _a !== void 0 ? _a : 'auto', height: (_b = size.height) !== null && _b !== void 0 ? _b : 'auto' });\n    };\n    Resizable.prototype.renderResizer = function () {\n        var _this = this;\n        var _a = this.props, enable = _a.enable, handleStyles = _a.handleStyles, handleClasses = _a.handleClasses, handleWrapperStyle = _a.handleWrapperStyle, handleWrapperClass = _a.handleWrapperClass, handleComponent = _a.handleComponent;\n        if (!enable) {\n            return null;\n        }\n        var resizers = Object.keys(enable).map(function (dir) {\n            if (enable[dir] !== false) {\n                return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_resizer__WEBPACK_IMPORTED_MODULE_3__.Resizer, { direction: dir, onResizeStart: _this.onResizeStart, replaceStyles: handleStyles && handleStyles[dir], className: handleClasses && handleClasses[dir], children: handleComponent && handleComponent[dir] ? handleComponent[dir] : null }, dir));\n            }\n            return null;\n        });\n        // #93 Wrap the resize box in span (will not break 100% width/height)\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: handleWrapperClass, style: handleWrapperStyle, children: resizers }));\n    };\n    Resizable.prototype.render = function () {\n        var _this = this;\n        var extendsProps = Object.keys(this.props).reduce(function (acc, key) {\n            if (definedProps.indexOf(key) !== -1) {\n                return acc;\n            }\n            acc[key] = _this.props[key];\n            return acc;\n        }, {});\n        var style = __assign(__assign(__assign({ position: 'relative', userSelect: this.state.isResizing ? 'none' : 'auto' }, this.props.style), this.sizeStyle), { maxWidth: this.props.maxWidth, maxHeight: this.props.maxHeight, minWidth: this.props.minWidth, minHeight: this.props.minHeight, boxSizing: 'border-box', flexShrink: 0 });\n        if (this.state.flexBasis) {\n            style.flexBasis = this.state.flexBasis;\n        }\n        var Wrapper = this.props.as || 'div';\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Wrapper, __assign({ style: style, className: this.props.className }, extendsProps, { \n            // `ref` is after `extendsProps` to ensure this one wins over a version\n            // passed in\n            ref: function (c) {\n                if (c) {\n                    _this.resizable = c;\n                }\n            }, children: [this.state.isResizing && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { style: this.state.backgroundStyle }), this.props.children, this.renderResizer()] })));\n    };\n    Resizable.defaultProps = {\n        as: 'div',\n        onResizeStart: function () { },\n        onResize: function () { },\n        onResizeStop: function () { },\n        enable: {\n            top: true,\n            right: true,\n            bottom: true,\n            left: true,\n            topRight: true,\n            bottomRight: true,\n            bottomLeft: true,\n            topLeft: true,\n        },\n        style: {},\n        grid: [1, 1],\n        gridGap: [0, 0],\n        lockAspectRatio: false,\n        lockAspectRatioExtraWidth: 0,\n        lockAspectRatioExtraHeight: 0,\n        scale: 1,\n        resizeRatio: 1,\n        snapGap: 0,\n    };\n    return Resizable;\n}(react__WEBPACK_IMPORTED_MODULE_1__.PureComponent));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmUtcmVzaXphYmxlL2xpYi9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3QjtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0JBQWdCLFNBQUksSUFBSSxTQUFJO0FBQzVCO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMrRDtBQUN6QjtBQUNBO0FBQ0Y7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsMEVBQTBFLDZFQUE2RTtBQUN2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDdEMsaUNBQWlDO0FBQ2pDLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxDQUFDLGdEQUFhO0FBQ00iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlLXJlc2l6YWJsZS9saWIvaW5kZXguanM/NzkxYSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmltcG9ydCB7IGpzeCBhcyBfanN4LCBqc3hzIGFzIF9qc3hzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgeyBQdXJlQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZmx1c2hTeW5jIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCB7IFJlc2l6ZXIgfSBmcm9tICcuL3Jlc2l6ZXInO1xudmFyIERFRkFVTFRfU0laRSA9IHtcbiAgICB3aWR0aDogJ2F1dG8nLFxuICAgIGhlaWdodDogJ2F1dG8nLFxufTtcbnZhciBjbGFtcCA9IGZ1bmN0aW9uIChuLCBtaW4sIG1heCkgeyByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4obiwgbWF4KSwgbWluKTsgfTtcbnZhciBzbmFwID0gZnVuY3Rpb24gKG4sIHNpemUsIGdyaWRHYXApIHtcbiAgICB2YXIgdiA9IE1hdGgucm91bmQobiAvIHNpemUpO1xuICAgIHJldHVybiB2ICogc2l6ZSArIGdyaWRHYXAgKiAodiAtIDEpO1xufTtcbnZhciBoYXNEaXJlY3Rpb24gPSBmdW5jdGlvbiAoZGlyLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChkaXIsICdpJykudGVzdCh0YXJnZXQpO1xufTtcbi8vIElORk86IEluIGNhc2Ugb2Ygd2luZG93IGlzIGEgUHJveHkgYW5kIGRvZXMgbm90IHBvcnh5IEV2ZW50cyBjb3JyZWN0bHksIHVzZSBpc1RvdWNoRXZlbnQgJiBpc01vdXNlRXZlbnQgdG8gZGlzdGluZ3Vpc2ggZXZlbnQgdHlwZSBpbnN0ZWFkIG9mIGBpbnN0YW5jZW9mYC5cbnZhciBpc1RvdWNoRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gQm9vbGVhbihldmVudC50b3VjaGVzICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoKTtcbn07XG52YXIgaXNNb3VzZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oKGV2ZW50LmNsaWVudFggfHwgZXZlbnQuY2xpZW50WCA9PT0gMCkgJiZcbiAgICAgICAgKGV2ZW50LmNsaWVudFkgfHwgZXZlbnQuY2xpZW50WSA9PT0gMCkpO1xufTtcbnZhciBmaW5kQ2xvc2VzdFNuYXAgPSBmdW5jdGlvbiAobiwgc25hcEFycmF5LCBzbmFwR2FwKSB7XG4gICAgaWYgKHNuYXBHYXAgPT09IHZvaWQgMCkgeyBzbmFwR2FwID0gMDsgfVxuICAgIHZhciBjbG9zZXN0R2FwSW5kZXggPSBzbmFwQXJyYXkucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyLCBpbmRleCkgeyByZXR1cm4gKE1hdGguYWJzKGN1cnIgLSBuKSA8IE1hdGguYWJzKHNuYXBBcnJheVtwcmV2XSAtIG4pID8gaW5kZXggOiBwcmV2KTsgfSwgMCk7XG4gICAgdmFyIGdhcCA9IE1hdGguYWJzKHNuYXBBcnJheVtjbG9zZXN0R2FwSW5kZXhdIC0gbik7XG4gICAgcmV0dXJuIHNuYXBHYXAgPT09IDAgfHwgZ2FwIDwgc25hcEdhcCA/IHNuYXBBcnJheVtjbG9zZXN0R2FwSW5kZXhdIDogbjtcbn07XG52YXIgZ2V0U3RyaW5nU2l6ZSA9IGZ1bmN0aW9uIChuKSB7XG4gICAgbiA9IG4udG9TdHJpbmcoKTtcbiAgICBpZiAobiA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICBpZiAobi5lbmRzV2l0aCgncHgnKSkge1xuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG4gICAgaWYgKG4uZW5kc1dpdGgoJyUnKSkge1xuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG4gICAgaWYgKG4uZW5kc1dpdGgoJ3ZoJykpIHtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuICAgIGlmIChuLmVuZHNXaXRoKCd2dycpKSB7XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICBpZiAobi5lbmRzV2l0aCgndm1heCcpKSB7XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICBpZiAobi5lbmRzV2l0aCgndm1pbicpKSB7XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIi5jb25jYXQobiwgXCJweFwiKTtcbn07XG52YXIgZ2V0UGl4ZWxTaXplID0gZnVuY3Rpb24gKHNpemUsIHBhcmVudFNpemUsIGlubmVyV2lkdGgsIGlubmVySGVpZ2h0KSB7XG4gICAgaWYgKHNpemUgJiYgdHlwZW9mIHNpemUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChzaXplLmVuZHNXaXRoKCdweCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKHNpemUucmVwbGFjZSgncHgnLCAnJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaXplLmVuZHNXaXRoKCclJykpIHtcbiAgICAgICAgICAgIHZhciByYXRpbyA9IE51bWJlcihzaXplLnJlcGxhY2UoJyUnLCAnJykpIC8gMTAwO1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudFNpemUgKiByYXRpbztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2l6ZS5lbmRzV2l0aCgndncnKSkge1xuICAgICAgICAgICAgdmFyIHJhdGlvID0gTnVtYmVyKHNpemUucmVwbGFjZSgndncnLCAnJykpIC8gMTAwO1xuICAgICAgICAgICAgcmV0dXJuIGlubmVyV2lkdGggKiByYXRpbztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2l6ZS5lbmRzV2l0aCgndmgnKSkge1xuICAgICAgICAgICAgdmFyIHJhdGlvID0gTnVtYmVyKHNpemUucmVwbGFjZSgndmgnLCAnJykpIC8gMTAwO1xuICAgICAgICAgICAgcmV0dXJuIGlubmVySGVpZ2h0ICogcmF0aW87XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG59O1xudmFyIGNhbGN1bGF0ZU5ld01heCA9IGZ1bmN0aW9uIChwYXJlbnRTaXplLCBpbm5lcldpZHRoLCBpbm5lckhlaWdodCwgbWF4V2lkdGgsIG1heEhlaWdodCwgbWluV2lkdGgsIG1pbkhlaWdodCkge1xuICAgIG1heFdpZHRoID0gZ2V0UGl4ZWxTaXplKG1heFdpZHRoLCBwYXJlbnRTaXplLndpZHRoLCBpbm5lcldpZHRoLCBpbm5lckhlaWdodCk7XG4gICAgbWF4SGVpZ2h0ID0gZ2V0UGl4ZWxTaXplKG1heEhlaWdodCwgcGFyZW50U2l6ZS5oZWlnaHQsIGlubmVyV2lkdGgsIGlubmVySGVpZ2h0KTtcbiAgICBtaW5XaWR0aCA9IGdldFBpeGVsU2l6ZShtaW5XaWR0aCwgcGFyZW50U2l6ZS53aWR0aCwgaW5uZXJXaWR0aCwgaW5uZXJIZWlnaHQpO1xuICAgIG1pbkhlaWdodCA9IGdldFBpeGVsU2l6ZShtaW5IZWlnaHQsIHBhcmVudFNpemUuaGVpZ2h0LCBpbm5lcldpZHRoLCBpbm5lckhlaWdodCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWF4V2lkdGg6IHR5cGVvZiBtYXhXaWR0aCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBOdW1iZXIobWF4V2lkdGgpLFxuICAgICAgICBtYXhIZWlnaHQ6IHR5cGVvZiBtYXhIZWlnaHQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogTnVtYmVyKG1heEhlaWdodCksXG4gICAgICAgIG1pbldpZHRoOiB0eXBlb2YgbWluV2lkdGggPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogTnVtYmVyKG1pbldpZHRoKSxcbiAgICAgICAgbWluSGVpZ2h0OiB0eXBlb2YgbWluSGVpZ2h0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IE51bWJlcihtaW5IZWlnaHQpLFxuICAgIH07XG59O1xuLyoqXG4gKiB0cmFuc2Zvcm0gVCB8IFtULCBUXSB0byBbVCwgVF1cbiAqIEBwYXJhbSB2YWxcbiAqIEByZXR1cm5zXG4gKi9cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxudmFyIG5vcm1hbGl6ZVRvUGFpciA9IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIChBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwgOiBbdmFsLCB2YWxdKTsgfTtcbnZhciBkZWZpbmVkUHJvcHMgPSBbXG4gICAgJ2FzJyxcbiAgICAncmVmJyxcbiAgICAnc3R5bGUnLFxuICAgICdjbGFzc05hbWUnLFxuICAgICdncmlkJyxcbiAgICAnZ3JpZEdhcCcsXG4gICAgJ3NuYXAnLFxuICAgICdib3VuZHMnLFxuICAgICdib3VuZHNCeURpcmVjdGlvbicsXG4gICAgJ3NpemUnLFxuICAgICdkZWZhdWx0U2l6ZScsXG4gICAgJ21pbldpZHRoJyxcbiAgICAnbWluSGVpZ2h0JyxcbiAgICAnbWF4V2lkdGgnLFxuICAgICdtYXhIZWlnaHQnLFxuICAgICdsb2NrQXNwZWN0UmF0aW8nLFxuICAgICdsb2NrQXNwZWN0UmF0aW9FeHRyYVdpZHRoJyxcbiAgICAnbG9ja0FzcGVjdFJhdGlvRXh0cmFIZWlnaHQnLFxuICAgICdlbmFibGUnLFxuICAgICdoYW5kbGVTdHlsZXMnLFxuICAgICdoYW5kbGVDbGFzc2VzJyxcbiAgICAnaGFuZGxlV3JhcHBlclN0eWxlJyxcbiAgICAnaGFuZGxlV3JhcHBlckNsYXNzJyxcbiAgICAnY2hpbGRyZW4nLFxuICAgICdvblJlc2l6ZVN0YXJ0JyxcbiAgICAnb25SZXNpemUnLFxuICAgICdvblJlc2l6ZVN0b3AnLFxuICAgICdoYW5kbGVDb21wb25lbnQnLFxuICAgICdzY2FsZScsXG4gICAgJ3Jlc2l6ZVJhdGlvJyxcbiAgICAnc25hcEdhcCcsXG5dO1xuLy8gSEFDSzogVGhpcyBjbGFzcyBpcyB1c2VkIHRvIGNhbGN1bGF0ZSAlIHNpemUuXG52YXIgYmFzZUNsYXNzTmFtZSA9ICdfX3Jlc2l6YWJsZV9iYXNlX18nO1xudmFyIFJlc2l6YWJsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVzaXphYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlc2l6YWJsZShwcm9wcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yYXRpbyA9IDE7XG4gICAgICAgIF90aGlzLnJlc2l6YWJsZSA9IG51bGw7XG4gICAgICAgIC8vIEZvciBwYXJlbnQgYm91bmRhcnlcbiAgICAgICAgX3RoaXMucGFyZW50TGVmdCA9IDA7XG4gICAgICAgIF90aGlzLnBhcmVudFRvcCA9IDA7XG4gICAgICAgIC8vIEZvciBib3VuZGFyeVxuICAgICAgICBfdGhpcy5yZXNpemFibGVMZWZ0ID0gMDtcbiAgICAgICAgX3RoaXMucmVzaXphYmxlUmlnaHQgPSAwO1xuICAgICAgICBfdGhpcy5yZXNpemFibGVUb3AgPSAwO1xuICAgICAgICBfdGhpcy5yZXNpemFibGVCb3R0b20gPSAwO1xuICAgICAgICAvLyBGb3IgdGFyZ2V0IGJvdW5kYXJ5XG4gICAgICAgIF90aGlzLnRhcmdldExlZnQgPSAwO1xuICAgICAgICBfdGhpcy50YXJnZXRUb3AgPSAwO1xuICAgICAgICBfdGhpcy5kZWx0YSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5hcHBlbmRCYXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5yZXNpemFibGUgfHwgIV90aGlzLndpbmRvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBhcmVudCA9IF90aGlzLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBfdGhpcy53aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gJ3NjYWxlKDAsIDApJztcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUubGVmdCA9ICcwJztcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuZmxleCA9ICcwIDAgMTAwJSc7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoYmFzZUNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSArPSBiYXNlQ2xhc3NOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlbW92ZUJhc2UgPSBmdW5jdGlvbiAoYmFzZSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IF90aGlzLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChiYXNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBpc1Jlc2l6aW5nOiBmYWxzZSxcbiAgICAgICAgICAgIHdpZHRoOiAoX2IgPSAoX2EgPSBfdGhpcy5wcm9wc1NpemUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS53aWR0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ2F1dG8nLFxuICAgICAgICAgICAgaGVpZ2h0OiAoX2QgPSAoX2MgPSBfdGhpcy5wcm9wc1NpemUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5oZWlnaHQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6ICdhdXRvJyxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogJ3JpZ2h0JyxcbiAgICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kU3R5bGU6IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuICAgICAgICAgICAgICAgIGN1cnNvcjogJ2F1dG8nLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgICAgICAgICAgekluZGV4OiA5OTk5LFxuICAgICAgICAgICAgICAgIHRvcDogJzAnLFxuICAgICAgICAgICAgICAgIGxlZnQ6ICcwJyxcbiAgICAgICAgICAgICAgICBib3R0b206ICcwJyxcbiAgICAgICAgICAgICAgICByaWdodDogJzAnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZsZXhCYXNpczogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vblJlc2l6ZVN0YXJ0ID0gX3RoaXMub25SZXNpemVTdGFydC5iaW5kKF90aGlzKTtcbiAgICAgICAgX3RoaXMub25Nb3VzZU1vdmUgPSBfdGhpcy5vbk1vdXNlTW92ZS5iaW5kKF90aGlzKTtcbiAgICAgICAgX3RoaXMub25Nb3VzZVVwID0gX3RoaXMub25Nb3VzZVVwLmJpbmQoX3RoaXMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXNpemFibGUucHJvdG90eXBlLCBcInBhcmVudE5vZGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZXNpemFibGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc2l6YWJsZS5wYXJlbnROb2RlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlc2l6YWJsZS5wcm90b3R5cGUsIFwid2luZG93XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVzaXphYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVzaXphYmxlLm93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc2l6YWJsZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlc2l6YWJsZS5wcm90b3R5cGUsIFwicHJvcHNTaXplXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5zaXplIHx8IHRoaXMucHJvcHMuZGVmYXVsdFNpemUgfHwgREVGQVVMVF9TSVpFO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlc2l6YWJsZS5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gMDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzaXphYmxlICYmIHRoaXMud2luZG93KSB7XG4gICAgICAgICAgICAgICAgdmFyIG9yZ1dpZHRoID0gdGhpcy5yZXNpemFibGUub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIG9yZ0hlaWdodCA9IHRoaXMucmVzaXphYmxlLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICAvLyBIQUNLOiBTZXQgcG9zaXRpb24gYHJlbGF0aXZlYCB0byBnZXQgcGFyZW50IHNpemUuXG4gICAgICAgICAgICAgICAgLy8gICAgICAgVGhpcyBpcyBiZWNhdXNlIHdoZW4gcmUtcmVzaXphYmxlIHNldCBgYWJzb2x1dGVgLCBJIGNhbiBub3QgZ2V0IGJhc2Ugd2lkdGggY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgIHZhciBvcmdQb3NpdGlvbiA9IHRoaXMucmVzaXphYmxlLnN0eWxlLnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChvcmdQb3NpdGlvbiAhPT0gJ3JlbGF0aXZlJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2l6YWJsZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElORk86IFVzZSBvcmlnaW5hbCB3aWR0aCBvciBoZWlnaHQgaWYgc2V0IGF1dG8uXG4gICAgICAgICAgICAgICAgd2lkdGggPSB0aGlzLnJlc2l6YWJsZS5zdHlsZS53aWR0aCAhPT0gJ2F1dG8nID8gdGhpcy5yZXNpemFibGUub2Zmc2V0V2lkdGggOiBvcmdXaWR0aDtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLnJlc2l6YWJsZS5zdHlsZS5oZWlnaHQgIT09ICdhdXRvJyA/IHRoaXMucmVzaXphYmxlLm9mZnNldEhlaWdodCA6IG9yZ0hlaWdodDtcbiAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemFibGUuc3R5bGUucG9zaXRpb24gPSBvcmdQb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXNpemFibGUucHJvdG90eXBlLCBcInNpemVTdHlsZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBzaXplID0gdGhpcy5wcm9wcy5zaXplO1xuICAgICAgICAgICAgdmFyIGdldFNpemUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgX3RoaXMuc3RhdGVba2V5XSA9PT0gJ3VuZGVmaW5lZCcgfHwgX3RoaXMuc3RhdGVba2V5XSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnYXV0byc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wc1NpemUgJiYgX3RoaXMucHJvcHNTaXplW2tleV0gJiYgKChfYSA9IF90aGlzLnByb3BzU2l6ZVtrZXldKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9TdHJpbmcoKS5lbmRzV2l0aCgnJScpKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGVba2V5XS50b1N0cmluZygpLmVuZHNXaXRoKCclJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zdGF0ZVtrZXldLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudFNpemUgPSBfdGhpcy5nZXRQYXJlbnRTaXplKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IE51bWJlcihfdGhpcy5zdGF0ZVtrZXldLnRvU3RyaW5nKCkucmVwbGFjZSgncHgnLCAnJykpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGVyY2VudCA9ICh2YWx1ZSAvIHBhcmVudFNpemVba2V5XSkgKiAxMDA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChwZXJjZW50LCBcIiVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdTaXplKF90aGlzLnN0YXRlW2tleV0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHNpemUgJiYgdHlwZW9mIHNpemUud2lkdGggIT09ICd1bmRlZmluZWQnICYmICF0aGlzLnN0YXRlLmlzUmVzaXppbmdcbiAgICAgICAgICAgICAgICA/IGdldFN0cmluZ1NpemUoc2l6ZS53aWR0aClcbiAgICAgICAgICAgICAgICA6IGdldFNpemUoJ3dpZHRoJyk7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc2l6ZSAmJiB0eXBlb2Ygc2l6ZS5oZWlnaHQgIT09ICd1bmRlZmluZWQnICYmICF0aGlzLnN0YXRlLmlzUmVzaXppbmdcbiAgICAgICAgICAgICAgICA/IGdldFN0cmluZ1NpemUoc2l6ZS5oZWlnaHQpXG4gICAgICAgICAgICAgICAgOiBnZXRTaXplKCdoZWlnaHQnKTtcbiAgICAgICAgICAgIHJldHVybiB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFJlc2l6YWJsZS5wcm90b3R5cGUuZ2V0UGFyZW50U2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy53aW5kb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyB3aWR0aDogdGhpcy53aW5kb3cuaW5uZXJXaWR0aCwgaGVpZ2h0OiB0aGlzLndpbmRvdy5pbm5lckhlaWdodCB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBiYXNlID0gdGhpcy5hcHBlbmRCYXNlKCk7XG4gICAgICAgIGlmICghYmFzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIElORk86IFRvIGNhbGN1bGF0ZSBwYXJlbnQgd2lkdGggd2l0aCBmbGV4IGxheW91dFxuICAgICAgICB2YXIgd3JhcENoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHdyYXAgPSB0aGlzLnBhcmVudE5vZGUuc3R5bGUuZmxleFdyYXA7XG4gICAgICAgIGlmICh3cmFwICE9PSAnd3JhcCcpIHtcbiAgICAgICAgICAgIHdyYXBDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5zdHlsZS5mbGV4V3JhcCA9ICd3cmFwJztcbiAgICAgICAgICAgIC8vIEhBQ0s6IFVzZSByZWxhdGl2ZSB0byBnZXQgcGFyZW50IHBhZGRpbmcgc2l6ZVxuICAgICAgICB9XG4gICAgICAgIGJhc2Uuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICBiYXNlLnN0eWxlLm1pbldpZHRoID0gJzEwMCUnO1xuICAgICAgICBiYXNlLnN0eWxlLm1pbkhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgdmFyIHNpemUgPSB7XG4gICAgICAgICAgICB3aWR0aDogYmFzZS5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogYmFzZS5vZmZzZXRIZWlnaHQsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh3cmFwQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLnN0eWxlLmZsZXhXcmFwID0gd3JhcDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUJhc2UoYmFzZSk7XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH07XG4gICAgUmVzaXphYmxlLnByb3RvdHlwZS5iaW5kRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy53aW5kb3cpIHtcbiAgICAgICAgICAgIHRoaXMud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcCk7XG4gICAgICAgICAgICB0aGlzLndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlKTtcbiAgICAgICAgICAgIHRoaXMud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm9uTW91c2VVcCk7XG4gICAgICAgICAgICB0aGlzLndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLCB7XG4gICAgICAgICAgICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm9uTW91c2VVcCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlc2l6YWJsZS5wcm90b3R5cGUudW5iaW5kRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy53aW5kb3cpIHtcbiAgICAgICAgICAgIHRoaXMud2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcCk7XG4gICAgICAgICAgICB0aGlzLndpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlKTtcbiAgICAgICAgICAgIHRoaXMud2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm9uTW91c2VVcCk7XG4gICAgICAgICAgICB0aGlzLndpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMud2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vbk1vdXNlVXApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZXNpemFibGUucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMucmVzaXphYmxlIHx8ICF0aGlzLndpbmRvdykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb21wdXRlZFN0eWxlID0gdGhpcy53aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLnJlc2l6YWJsZSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMuc3RhdGUud2lkdGggfHwgdGhpcy5zaXplLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnN0YXRlLmhlaWdodCB8fCB0aGlzLnNpemUuaGVpZ2h0LFxuICAgICAgICAgICAgZmxleEJhc2lzOiBjb21wdXRlZFN0eWxlLmZsZXhCYXNpcyAhPT0gJ2F1dG8nID8gY29tcHV0ZWRTdHlsZS5mbGV4QmFzaXMgOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVzaXphYmxlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMud2luZG93KSB7XG4gICAgICAgICAgICB0aGlzLnVuYmluZEV2ZW50cygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZXNpemFibGUucHJvdG90eXBlLmNyZWF0ZVNpemVGb3JDc3NQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuZXdTaXplLCBraW5kKSB7XG4gICAgICAgIHZhciBwcm9wc1NpemUgPSB0aGlzLnByb3BzU2l6ZSAmJiB0aGlzLnByb3BzU2l6ZVtraW5kXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVba2luZF0gPT09ICdhdXRvJyAmJlxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5vcmlnaW5hbFtraW5kXSA9PT0gbmV3U2l6ZSAmJlxuICAgICAgICAgICAgKHR5cGVvZiBwcm9wc1NpemUgPT09ICd1bmRlZmluZWQnIHx8IHByb3BzU2l6ZSA9PT0gJ2F1dG8nKVxuICAgICAgICAgICAgPyAnYXV0bydcbiAgICAgICAgICAgIDogbmV3U2l6ZTtcbiAgICB9O1xuICAgIFJlc2l6YWJsZS5wcm90b3R5cGUuY2FsY3VsYXRlTmV3TWF4RnJvbUJvdW5kYXJ5ID0gZnVuY3Rpb24gKG1heFdpZHRoLCBtYXhIZWlnaHQpIHtcbiAgICAgICAgdmFyIGJvdW5kc0J5RGlyZWN0aW9uID0gdGhpcy5wcm9wcy5ib3VuZHNCeURpcmVjdGlvbjtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMuc3RhdGUuZGlyZWN0aW9uO1xuICAgICAgICB2YXIgd2lkdGhCeURpcmVjdGlvbiA9IGJvdW5kc0J5RGlyZWN0aW9uICYmIGhhc0RpcmVjdGlvbignbGVmdCcsIGRpcmVjdGlvbik7XG4gICAgICAgIHZhciBoZWlnaHRCeURpcmVjdGlvbiA9IGJvdW5kc0J5RGlyZWN0aW9uICYmIGhhc0RpcmVjdGlvbigndG9wJywgZGlyZWN0aW9uKTtcbiAgICAgICAgdmFyIGJvdW5kV2lkdGg7XG4gICAgICAgIHZhciBib3VuZEhlaWdodDtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuYm91bmRzID09PSAncGFyZW50Jykge1xuICAgICAgICAgICAgdmFyIHBhcmVudF8xID0gdGhpcy5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKHBhcmVudF8xKSB7XG4gICAgICAgICAgICAgICAgYm91bmRXaWR0aCA9IHdpZHRoQnlEaXJlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnJlc2l6YWJsZVJpZ2h0IC0gdGhpcy5wYXJlbnRMZWZ0XG4gICAgICAgICAgICAgICAgICAgIDogcGFyZW50XzEub2Zmc2V0V2lkdGggKyAodGhpcy5wYXJlbnRMZWZ0IC0gdGhpcy5yZXNpemFibGVMZWZ0KTtcbiAgICAgICAgICAgICAgICBib3VuZEhlaWdodCA9IGhlaWdodEJ5RGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5yZXNpemFibGVCb3R0b20gLSB0aGlzLnBhcmVudFRvcFxuICAgICAgICAgICAgICAgICAgICA6IHBhcmVudF8xLm9mZnNldEhlaWdodCArICh0aGlzLnBhcmVudFRvcCAtIHRoaXMucmVzaXphYmxlVG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnByb3BzLmJvdW5kcyA9PT0gJ3dpbmRvdycpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndpbmRvdykge1xuICAgICAgICAgICAgICAgIGJvdW5kV2lkdGggPSB3aWR0aEJ5RGlyZWN0aW9uID8gdGhpcy5yZXNpemFibGVSaWdodCA6IHRoaXMud2luZG93LmlubmVyV2lkdGggLSB0aGlzLnJlc2l6YWJsZUxlZnQ7XG4gICAgICAgICAgICAgICAgYm91bmRIZWlnaHQgPSBoZWlnaHRCeURpcmVjdGlvbiA/IHRoaXMucmVzaXphYmxlQm90dG9tIDogdGhpcy53aW5kb3cuaW5uZXJIZWlnaHQgLSB0aGlzLnJlc2l6YWJsZVRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnByb3BzLmJvdW5kcykge1xuICAgICAgICAgICAgYm91bmRXaWR0aCA9IHdpZHRoQnlEaXJlY3Rpb25cbiAgICAgICAgICAgICAgICA/IHRoaXMucmVzaXphYmxlUmlnaHQgLSB0aGlzLnRhcmdldExlZnRcbiAgICAgICAgICAgICAgICA6IHRoaXMucHJvcHMuYm91bmRzLm9mZnNldFdpZHRoICsgKHRoaXMudGFyZ2V0TGVmdCAtIHRoaXMucmVzaXphYmxlTGVmdCk7XG4gICAgICAgICAgICBib3VuZEhlaWdodCA9IGhlaWdodEJ5RGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgPyB0aGlzLnJlc2l6YWJsZUJvdHRvbSAtIHRoaXMudGFyZ2V0VG9wXG4gICAgICAgICAgICAgICAgOiB0aGlzLnByb3BzLmJvdW5kcy5vZmZzZXRIZWlnaHQgKyAodGhpcy50YXJnZXRUb3AgLSB0aGlzLnJlc2l6YWJsZVRvcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvdW5kV2lkdGggJiYgTnVtYmVyLmlzRmluaXRlKGJvdW5kV2lkdGgpKSB7XG4gICAgICAgICAgICBtYXhXaWR0aCA9IG1heFdpZHRoICYmIG1heFdpZHRoIDwgYm91bmRXaWR0aCA/IG1heFdpZHRoIDogYm91bmRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYm91bmRIZWlnaHQgJiYgTnVtYmVyLmlzRmluaXRlKGJvdW5kSGVpZ2h0KSkge1xuICAgICAgICAgICAgbWF4SGVpZ2h0ID0gbWF4SGVpZ2h0ICYmIG1heEhlaWdodCA8IGJvdW5kSGVpZ2h0ID8gbWF4SGVpZ2h0IDogYm91bmRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbWF4V2lkdGg6IG1heFdpZHRoLCBtYXhIZWlnaHQ6IG1heEhlaWdodCB9O1xuICAgIH07XG4gICAgUmVzaXphYmxlLnByb3RvdHlwZS5jYWxjdWxhdGVOZXdTaXplRnJvbURpcmVjdGlvbiA9IGZ1bmN0aW9uIChjbGllbnRYLCBjbGllbnRZKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMucHJvcHMuc2NhbGUgfHwgMTtcbiAgICAgICAgdmFyIF9hID0gbm9ybWFsaXplVG9QYWlyKHRoaXMucHJvcHMucmVzaXplUmF0aW8gfHwgMSksIHJlc2l6ZVJhdGlvWCA9IF9hWzBdLCByZXNpemVSYXRpb1kgPSBfYVsxXTtcbiAgICAgICAgdmFyIF9iID0gdGhpcy5zdGF0ZSwgZGlyZWN0aW9uID0gX2IuZGlyZWN0aW9uLCBvcmlnaW5hbCA9IF9iLm9yaWdpbmFsO1xuICAgICAgICB2YXIgX2MgPSB0aGlzLnByb3BzLCBsb2NrQXNwZWN0UmF0aW8gPSBfYy5sb2NrQXNwZWN0UmF0aW8sIGxvY2tBc3BlY3RSYXRpb0V4dHJhSGVpZ2h0ID0gX2MubG9ja0FzcGVjdFJhdGlvRXh0cmFIZWlnaHQsIGxvY2tBc3BlY3RSYXRpb0V4dHJhV2lkdGggPSBfYy5sb2NrQXNwZWN0UmF0aW9FeHRyYVdpZHRoO1xuICAgICAgICB2YXIgbmV3V2lkdGggPSBvcmlnaW5hbC53aWR0aDtcbiAgICAgICAgdmFyIG5ld0hlaWdodCA9IG9yaWdpbmFsLmhlaWdodDtcbiAgICAgICAgdmFyIGV4dHJhSGVpZ2h0ID0gbG9ja0FzcGVjdFJhdGlvRXh0cmFIZWlnaHQgfHwgMDtcbiAgICAgICAgdmFyIGV4dHJhV2lkdGggPSBsb2NrQXNwZWN0UmF0aW9FeHRyYVdpZHRoIHx8IDA7XG4gICAgICAgIGlmIChoYXNEaXJlY3Rpb24oJ3JpZ2h0JywgZGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgbmV3V2lkdGggPSBvcmlnaW5hbC53aWR0aCArICgoY2xpZW50WCAtIG9yaWdpbmFsLngpICogcmVzaXplUmF0aW9YKSAvIHNjYWxlO1xuICAgICAgICAgICAgaWYgKGxvY2tBc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgICAgIG5ld0hlaWdodCA9IChuZXdXaWR0aCAtIGV4dHJhV2lkdGgpIC8gdGhpcy5yYXRpbyArIGV4dHJhSGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNEaXJlY3Rpb24oJ2xlZnQnLCBkaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICBuZXdXaWR0aCA9IG9yaWdpbmFsLndpZHRoIC0gKChjbGllbnRYIC0gb3JpZ2luYWwueCkgKiByZXNpemVSYXRpb1gpIC8gc2NhbGU7XG4gICAgICAgICAgICBpZiAobG9ja0FzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgbmV3SGVpZ2h0ID0gKG5ld1dpZHRoIC0gZXh0cmFXaWR0aCkgLyB0aGlzLnJhdGlvICsgZXh0cmFIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0RpcmVjdGlvbignYm90dG9tJywgZGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgbmV3SGVpZ2h0ID0gb3JpZ2luYWwuaGVpZ2h0ICsgKChjbGllbnRZIC0gb3JpZ2luYWwueSkgKiByZXNpemVSYXRpb1kpIC8gc2NhbGU7XG4gICAgICAgICAgICBpZiAobG9ja0FzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgbmV3V2lkdGggPSAobmV3SGVpZ2h0IC0gZXh0cmFIZWlnaHQpICogdGhpcy5yYXRpbyArIGV4dHJhV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0RpcmVjdGlvbigndG9wJywgZGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgbmV3SGVpZ2h0ID0gb3JpZ2luYWwuaGVpZ2h0IC0gKChjbGllbnRZIC0gb3JpZ2luYWwueSkgKiByZXNpemVSYXRpb1kpIC8gc2NhbGU7XG4gICAgICAgICAgICBpZiAobG9ja0FzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgbmV3V2lkdGggPSAobmV3SGVpZ2h0IC0gZXh0cmFIZWlnaHQpICogdGhpcy5yYXRpbyArIGV4dHJhV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbmV3V2lkdGg6IG5ld1dpZHRoLCBuZXdIZWlnaHQ6IG5ld0hlaWdodCB9O1xuICAgIH07XG4gICAgUmVzaXphYmxlLnByb3RvdHlwZS5jYWxjdWxhdGVOZXdTaXplRnJvbUFzcGVjdFJhdGlvID0gZnVuY3Rpb24gKG5ld1dpZHRoLCBuZXdIZWlnaHQsIG1heCwgbWluKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIGxvY2tBc3BlY3RSYXRpbyA9IF9hLmxvY2tBc3BlY3RSYXRpbywgbG9ja0FzcGVjdFJhdGlvRXh0cmFIZWlnaHQgPSBfYS5sb2NrQXNwZWN0UmF0aW9FeHRyYUhlaWdodCwgbG9ja0FzcGVjdFJhdGlvRXh0cmFXaWR0aCA9IF9hLmxvY2tBc3BlY3RSYXRpb0V4dHJhV2lkdGg7XG4gICAgICAgIHZhciBjb21wdXRlZE1pbldpZHRoID0gdHlwZW9mIG1pbi53aWR0aCA9PT0gJ3VuZGVmaW5lZCcgPyAxMCA6IG1pbi53aWR0aDtcbiAgICAgICAgdmFyIGNvbXB1dGVkTWF4V2lkdGggPSB0eXBlb2YgbWF4LndpZHRoID09PSAndW5kZWZpbmVkJyB8fCBtYXgud2lkdGggPCAwID8gbmV3V2lkdGggOiBtYXgud2lkdGg7XG4gICAgICAgIHZhciBjb21wdXRlZE1pbkhlaWdodCA9IHR5cGVvZiBtaW4uaGVpZ2h0ID09PSAndW5kZWZpbmVkJyA/IDEwIDogbWluLmhlaWdodDtcbiAgICAgICAgdmFyIGNvbXB1dGVkTWF4SGVpZ2h0ID0gdHlwZW9mIG1heC5oZWlnaHQgPT09ICd1bmRlZmluZWQnIHx8IG1heC5oZWlnaHQgPCAwID8gbmV3SGVpZ2h0IDogbWF4LmhlaWdodDtcbiAgICAgICAgdmFyIGV4dHJhSGVpZ2h0ID0gbG9ja0FzcGVjdFJhdGlvRXh0cmFIZWlnaHQgfHwgMDtcbiAgICAgICAgdmFyIGV4dHJhV2lkdGggPSBsb2NrQXNwZWN0UmF0aW9FeHRyYVdpZHRoIHx8IDA7XG4gICAgICAgIGlmIChsb2NrQXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgIHZhciBleHRyYU1pbldpZHRoID0gKGNvbXB1dGVkTWluSGVpZ2h0IC0gZXh0cmFIZWlnaHQpICogdGhpcy5yYXRpbyArIGV4dHJhV2lkdGg7XG4gICAgICAgICAgICB2YXIgZXh0cmFNYXhXaWR0aCA9IChjb21wdXRlZE1heEhlaWdodCAtIGV4dHJhSGVpZ2h0KSAqIHRoaXMucmF0aW8gKyBleHRyYVdpZHRoO1xuICAgICAgICAgICAgdmFyIGV4dHJhTWluSGVpZ2h0ID0gKGNvbXB1dGVkTWluV2lkdGggLSBleHRyYVdpZHRoKSAvIHRoaXMucmF0aW8gKyBleHRyYUhlaWdodDtcbiAgICAgICAgICAgIHZhciBleHRyYU1heEhlaWdodCA9IChjb21wdXRlZE1heFdpZHRoIC0gZXh0cmFXaWR0aCkgLyB0aGlzLnJhdGlvICsgZXh0cmFIZWlnaHQ7XG4gICAgICAgICAgICB2YXIgbG9ja2VkTWluV2lkdGggPSBNYXRoLm1heChjb21wdXRlZE1pbldpZHRoLCBleHRyYU1pbldpZHRoKTtcbiAgICAgICAgICAgIHZhciBsb2NrZWRNYXhXaWR0aCA9IE1hdGgubWluKGNvbXB1dGVkTWF4V2lkdGgsIGV4dHJhTWF4V2lkdGgpO1xuICAgICAgICAgICAgdmFyIGxvY2tlZE1pbkhlaWdodCA9IE1hdGgubWF4KGNvbXB1dGVkTWluSGVpZ2h0LCBleHRyYU1pbkhlaWdodCk7XG4gICAgICAgICAgICB2YXIgbG9ja2VkTWF4SGVpZ2h0ID0gTWF0aC5taW4oY29tcHV0ZWRNYXhIZWlnaHQsIGV4dHJhTWF4SGVpZ2h0KTtcbiAgICAgICAgICAgIG5ld1dpZHRoID0gY2xhbXAobmV3V2lkdGgsIGxvY2tlZE1pbldpZHRoLCBsb2NrZWRNYXhXaWR0aCk7XG4gICAgICAgICAgICBuZXdIZWlnaHQgPSBjbGFtcChuZXdIZWlnaHQsIGxvY2tlZE1pbkhlaWdodCwgbG9ja2VkTWF4SGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld1dpZHRoID0gY2xhbXAobmV3V2lkdGgsIGNvbXB1dGVkTWluV2lkdGgsIGNvbXB1dGVkTWF4V2lkdGgpO1xuICAgICAgICAgICAgbmV3SGVpZ2h0ID0gY2xhbXAobmV3SGVpZ2h0LCBjb21wdXRlZE1pbkhlaWdodCwgY29tcHV0ZWRNYXhIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG5ld1dpZHRoOiBuZXdXaWR0aCwgbmV3SGVpZ2h0OiBuZXdIZWlnaHQgfTtcbiAgICB9O1xuICAgIFJlc2l6YWJsZS5wcm90b3R5cGUuc2V0Qm91bmRpbmdDbGllbnRSZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYWRqdXN0ZWRTY2FsZSA9IDEgLyAodGhpcy5wcm9wcy5zY2FsZSB8fCAxKTtcbiAgICAgICAgLy8gRm9yIHBhcmVudCBib3VuZGFyeVxuICAgICAgICBpZiAodGhpcy5wcm9wcy5ib3VuZHMgPT09ICdwYXJlbnQnKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50XzIgPSB0aGlzLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZiAocGFyZW50XzIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50UmVjdCA9IHBhcmVudF8yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50TGVmdCA9IHBhcmVudFJlY3QubGVmdCAqIGFkanVzdGVkU2NhbGU7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRUb3AgPSBwYXJlbnRSZWN0LnRvcCAqIGFkanVzdGVkU2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIHRhcmdldChodG1sIGVsZW1lbnQpIGJvdW5kYXJ5XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmJvdW5kcyAmJiB0eXBlb2YgdGhpcy5wcm9wcy5ib3VuZHMgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0UmVjdCA9IHRoaXMucHJvcHMuYm91bmRzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRMZWZ0ID0gdGFyZ2V0UmVjdC5sZWZ0ICogYWRqdXN0ZWRTY2FsZTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0VG9wID0gdGFyZ2V0UmVjdC50b3AgKiBhZGp1c3RlZFNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvciBib3VuZGFyeVxuICAgICAgICBpZiAodGhpcy5yZXNpemFibGUpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMucmVzaXphYmxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBsZWZ0ID0gX2EubGVmdCwgdG9wXzEgPSBfYS50b3AsIHJpZ2h0ID0gX2EucmlnaHQsIGJvdHRvbSA9IF9hLmJvdHRvbTtcbiAgICAgICAgICAgIHRoaXMucmVzaXphYmxlTGVmdCA9IGxlZnQgKiBhZGp1c3RlZFNjYWxlO1xuICAgICAgICAgICAgdGhpcy5yZXNpemFibGVSaWdodCA9IHJpZ2h0ICogYWRqdXN0ZWRTY2FsZTtcbiAgICAgICAgICAgIHRoaXMucmVzaXphYmxlVG9wID0gdG9wXzEgKiBhZGp1c3RlZFNjYWxlO1xuICAgICAgICAgICAgdGhpcy5yZXNpemFibGVCb3R0b20gPSBib3R0b20gKiBhZGp1c3RlZFNjYWxlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZXNpemFibGUucHJvdG90eXBlLm9uUmVzaXplU3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQsIGRpcmVjdGlvbikge1xuICAgICAgICBpZiAoIXRoaXMucmVzaXphYmxlIHx8ICF0aGlzLndpbmRvdykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjbGllbnRYID0gMDtcbiAgICAgICAgdmFyIGNsaWVudFkgPSAwO1xuICAgICAgICBpZiAoZXZlbnQubmF0aXZlRXZlbnQgJiYgaXNNb3VzZUV2ZW50KGV2ZW50Lm5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgY2xpZW50WCA9IGV2ZW50Lm5hdGl2ZUV2ZW50LmNsaWVudFg7XG4gICAgICAgICAgICBjbGllbnRZID0gZXZlbnQubmF0aXZlRXZlbnQuY2xpZW50WTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldmVudC5uYXRpdmVFdmVudCAmJiBpc1RvdWNoRXZlbnQoZXZlbnQubmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBjbGllbnRYID0gZXZlbnQubmF0aXZlRXZlbnQudG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgICAgICAgY2xpZW50WSA9IGV2ZW50Lm5hdGl2ZUV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm9wcy5vblJlc2l6ZVN0YXJ0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXNpemFibGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRSZXNpemUgPSB0aGlzLnByb3BzLm9uUmVzaXplU3RhcnQoZXZlbnQsIGRpcmVjdGlvbiwgdGhpcy5yZXNpemFibGUpO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydFJlc2l6ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBGaXggIzE2OFxuICAgICAgICBpZiAodGhpcy5wcm9wcy5zaXplKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJvcHMuc2l6ZS5oZWlnaHQgIT09ICd1bmRlZmluZWQnICYmIHRoaXMucHJvcHMuc2l6ZS5oZWlnaHQgIT09IHRoaXMuc3RhdGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGhlaWdodDogdGhpcy5wcm9wcy5zaXplLmhlaWdodCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcm9wcy5zaXplLndpZHRoICE9PSAndW5kZWZpbmVkJyAmJiB0aGlzLnByb3BzLnNpemUud2lkdGggIT09IHRoaXMuc3RhdGUud2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgd2lkdGg6IHRoaXMucHJvcHMuc2l6ZS53aWR0aCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBGb3IgbG9ja0FzcGVjdFJhdGlvIGNhc2VcbiAgICAgICAgdGhpcy5yYXRpbyA9XG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5wcm9wcy5sb2NrQXNwZWN0UmF0aW8gPT09ICdudW1iZXInID8gdGhpcy5wcm9wcy5sb2NrQXNwZWN0UmF0aW8gOiB0aGlzLnNpemUud2lkdGggLyB0aGlzLnNpemUuaGVpZ2h0O1xuICAgICAgICB2YXIgZmxleEJhc2lzO1xuICAgICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IHRoaXMud2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5yZXNpemFibGUpO1xuICAgICAgICBpZiAoY29tcHV0ZWRTdHlsZS5mbGV4QmFzaXMgIT09ICdhdXRvJykge1xuICAgICAgICAgICAgdmFyIHBhcmVudF8zID0gdGhpcy5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKHBhcmVudF8zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpciA9IHRoaXMud2luZG93LmdldENvbXB1dGVkU3R5bGUocGFyZW50XzMpLmZsZXhEaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgdGhpcy5mbGV4RGlyID0gZGlyLnN0YXJ0c1dpdGgoJ3JvdycpID8gJ3JvdycgOiAnY29sdW1uJztcbiAgICAgICAgICAgICAgICBmbGV4QmFzaXMgPSBjb21wdXRlZFN0eWxlLmZsZXhCYXNpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBGb3IgYm91bmRhcnlcbiAgICAgICAgdGhpcy5zZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gICAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICAgICAgeDogY2xpZW50WCxcbiAgICAgICAgICAgICAgICB5OiBjbGllbnRZLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLnNpemUud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnNpemUuaGVpZ2h0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzUmVzaXppbmc6IHRydWUsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kU3R5bGU6IF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLnN0YXRlLmJhY2tncm91bmRTdHlsZSksIHsgY3Vyc29yOiB0aGlzLndpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGV2ZW50LnRhcmdldCkuY3Vyc29yIHx8ICdhdXRvJyB9KSxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgICAgICAgICAgZmxleEJhc2lzOiBmbGV4QmFzaXMsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoc3RhdGUpO1xuICAgIH07XG4gICAgUmVzaXphYmxlLnByb3RvdHlwZS5vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuc3RhdGUuaXNSZXNpemluZyB8fCAhdGhpcy5yZXNpemFibGUgfHwgIXRoaXMud2luZG93KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMud2luZG93LlRvdWNoRXZlbnQgJiYgaXNUb3VjaEV2ZW50KGV2ZW50KSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgb24gZmFpbFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIG1heFdpZHRoID0gX2EubWF4V2lkdGgsIG1heEhlaWdodCA9IF9hLm1heEhlaWdodCwgbWluV2lkdGggPSBfYS5taW5XaWR0aCwgbWluSGVpZ2h0ID0gX2EubWluSGVpZ2h0O1xuICAgICAgICB2YXIgY2xpZW50WCA9IGlzVG91Y2hFdmVudChldmVudCkgPyBldmVudC50b3VjaGVzWzBdLmNsaWVudFggOiBldmVudC5jbGllbnRYO1xuICAgICAgICB2YXIgY2xpZW50WSA9IGlzVG91Y2hFdmVudChldmVudCkgPyBldmVudC50b3VjaGVzWzBdLmNsaWVudFkgOiBldmVudC5jbGllbnRZO1xuICAgICAgICB2YXIgX2IgPSB0aGlzLnN0YXRlLCBkaXJlY3Rpb24gPSBfYi5kaXJlY3Rpb24sIG9yaWdpbmFsID0gX2Iub3JpZ2luYWwsIHdpZHRoID0gX2Iud2lkdGgsIGhlaWdodCA9IF9iLmhlaWdodDtcbiAgICAgICAgdmFyIHBhcmVudFNpemUgPSB0aGlzLmdldFBhcmVudFNpemUoKTtcbiAgICAgICAgdmFyIG1heCA9IGNhbGN1bGF0ZU5ld01heChwYXJlbnRTaXplLCB0aGlzLndpbmRvdy5pbm5lcldpZHRoLCB0aGlzLndpbmRvdy5pbm5lckhlaWdodCwgbWF4V2lkdGgsIG1heEhlaWdodCwgbWluV2lkdGgsIG1pbkhlaWdodCk7XG4gICAgICAgIG1heFdpZHRoID0gbWF4Lm1heFdpZHRoO1xuICAgICAgICBtYXhIZWlnaHQgPSBtYXgubWF4SGVpZ2h0O1xuICAgICAgICBtaW5XaWR0aCA9IG1heC5taW5XaWR0aDtcbiAgICAgICAgbWluSGVpZ2h0ID0gbWF4Lm1pbkhlaWdodDtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIG5ldyBzaXplXG4gICAgICAgIHZhciBfYyA9IHRoaXMuY2FsY3VsYXRlTmV3U2l6ZUZyb21EaXJlY3Rpb24oY2xpZW50WCwgY2xpZW50WSksIG5ld0hlaWdodCA9IF9jLm5ld0hlaWdodCwgbmV3V2lkdGggPSBfYy5uZXdXaWR0aDtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIG1heCBzaXplIGZyb20gYm91bmRhcnkgc2V0dGluZ3NcbiAgICAgICAgdmFyIGJvdW5kYXJ5TWF4ID0gdGhpcy5jYWxjdWxhdGVOZXdNYXhGcm9tQm91bmRhcnkobWF4V2lkdGgsIG1heEhlaWdodCk7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnNuYXAgJiYgdGhpcy5wcm9wcy5zbmFwLngpIHtcbiAgICAgICAgICAgIG5ld1dpZHRoID0gZmluZENsb3Nlc3RTbmFwKG5ld1dpZHRoLCB0aGlzLnByb3BzLnNuYXAueCwgdGhpcy5wcm9wcy5zbmFwR2FwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm9wcy5zbmFwICYmIHRoaXMucHJvcHMuc25hcC55KSB7XG4gICAgICAgICAgICBuZXdIZWlnaHQgPSBmaW5kQ2xvc2VzdFNuYXAobmV3SGVpZ2h0LCB0aGlzLnByb3BzLnNuYXAueSwgdGhpcy5wcm9wcy5zbmFwR2FwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxjdWxhdGUgbmV3IHNpemUgZnJvbSBhc3BlY3QgcmF0aW9cbiAgICAgICAgdmFyIG5ld1NpemUgPSB0aGlzLmNhbGN1bGF0ZU5ld1NpemVGcm9tQXNwZWN0UmF0aW8obmV3V2lkdGgsIG5ld0hlaWdodCwgeyB3aWR0aDogYm91bmRhcnlNYXgubWF4V2lkdGgsIGhlaWdodDogYm91bmRhcnlNYXgubWF4SGVpZ2h0IH0sIHsgd2lkdGg6IG1pbldpZHRoLCBoZWlnaHQ6IG1pbkhlaWdodCB9KTtcbiAgICAgICAgbmV3V2lkdGggPSBuZXdTaXplLm5ld1dpZHRoO1xuICAgICAgICBuZXdIZWlnaHQgPSBuZXdTaXplLm5ld0hlaWdodDtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZ3JpZCkge1xuICAgICAgICAgICAgdmFyIG5ld0dyaWRXaWR0aCA9IHNuYXAobmV3V2lkdGgsIHRoaXMucHJvcHMuZ3JpZFswXSwgdGhpcy5wcm9wcy5ncmlkR2FwID8gdGhpcy5wcm9wcy5ncmlkR2FwWzBdIDogMCk7XG4gICAgICAgICAgICB2YXIgbmV3R3JpZEhlaWdodCA9IHNuYXAobmV3SGVpZ2h0LCB0aGlzLnByb3BzLmdyaWRbMV0sIHRoaXMucHJvcHMuZ3JpZEdhcCA/IHRoaXMucHJvcHMuZ3JpZEdhcFsxXSA6IDApO1xuICAgICAgICAgICAgdmFyIGdhcCA9IHRoaXMucHJvcHMuc25hcEdhcCB8fCAwO1xuICAgICAgICAgICAgdmFyIHcgPSBnYXAgPT09IDAgfHwgTWF0aC5hYnMobmV3R3JpZFdpZHRoIC0gbmV3V2lkdGgpIDw9IGdhcCA/IG5ld0dyaWRXaWR0aCA6IG5ld1dpZHRoO1xuICAgICAgICAgICAgdmFyIGggPSBnYXAgPT09IDAgfHwgTWF0aC5hYnMobmV3R3JpZEhlaWdodCAtIG5ld0hlaWdodCkgPD0gZ2FwID8gbmV3R3JpZEhlaWdodCA6IG5ld0hlaWdodDtcbiAgICAgICAgICAgIG5ld1dpZHRoID0gdztcbiAgICAgICAgICAgIG5ld0hlaWdodCA9IGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlbHRhID0ge1xuICAgICAgICAgICAgd2lkdGg6IG5ld1dpZHRoIC0gb3JpZ2luYWwud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IG5ld0hlaWdodCAtIG9yaWdpbmFsLmhlaWdodCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWx0YSA9IGRlbHRhO1xuICAgICAgICBpZiAod2lkdGggJiYgdHlwZW9mIHdpZHRoID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHdpZHRoLmVuZHNXaXRoKCclJykpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGVyY2VudCA9IChuZXdXaWR0aCAvIHBhcmVudFNpemUud2lkdGgpICogMTAwO1xuICAgICAgICAgICAgICAgIG5ld1dpZHRoID0gXCJcIi5jb25jYXQocGVyY2VudCwgXCIlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAod2lkdGguZW5kc1dpdGgoJ3Z3JykpIHtcbiAgICAgICAgICAgICAgICB2YXIgdncgPSAobmV3V2lkdGggLyB0aGlzLndpbmRvdy5pbm5lcldpZHRoKSAqIDEwMDtcbiAgICAgICAgICAgICAgICBuZXdXaWR0aCA9IFwiXCIuY29uY2F0KHZ3LCBcInZ3XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAod2lkdGguZW5kc1dpdGgoJ3ZoJykpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmggPSAobmV3V2lkdGggLyB0aGlzLndpbmRvdy5pbm5lckhlaWdodCkgKiAxMDA7XG4gICAgICAgICAgICAgICAgbmV3V2lkdGggPSBcIlwiLmNvbmNhdCh2aCwgXCJ2aFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0ICYmIHR5cGVvZiBoZWlnaHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoaGVpZ2h0LmVuZHNXaXRoKCclJykpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGVyY2VudCA9IChuZXdIZWlnaHQgLyBwYXJlbnRTaXplLmhlaWdodCkgKiAxMDA7XG4gICAgICAgICAgICAgICAgbmV3SGVpZ2h0ID0gXCJcIi5jb25jYXQocGVyY2VudCwgXCIlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGVpZ2h0LmVuZHNXaXRoKCd2dycpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZ3ID0gKG5ld0hlaWdodCAvIHRoaXMud2luZG93LmlubmVyV2lkdGgpICogMTAwO1xuICAgICAgICAgICAgICAgIG5ld0hlaWdodCA9IFwiXCIuY29uY2F0KHZ3LCBcInZ3XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGVpZ2h0LmVuZHNXaXRoKCd2aCcpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZoID0gKG5ld0hlaWdodCAvIHRoaXMud2luZG93LmlubmVySGVpZ2h0KSAqIDEwMDtcbiAgICAgICAgICAgICAgICBuZXdIZWlnaHQgPSBcIlwiLmNvbmNhdCh2aCwgXCJ2aFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3U3RhdGUgPSB7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy5jcmVhdGVTaXplRm9yQ3NzUHJvcGVydHkobmV3V2lkdGgsICd3aWR0aCcpLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmNyZWF0ZVNpemVGb3JDc3NQcm9wZXJ0eShuZXdIZWlnaHQsICdoZWlnaHQnKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuZmxleERpciA9PT0gJ3JvdycpIHtcbiAgICAgICAgICAgIG5ld1N0YXRlLmZsZXhCYXNpcyA9IG5ld1N0YXRlLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZmxleERpciA9PT0gJ2NvbHVtbicpIHtcbiAgICAgICAgICAgIG5ld1N0YXRlLmZsZXhCYXNpcyA9IG5ld1N0YXRlLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2lkdGhDaGFuZ2VkID0gdGhpcy5zdGF0ZS53aWR0aCAhPT0gbmV3U3RhdGUud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHRDaGFuZ2VkID0gdGhpcy5zdGF0ZS5oZWlnaHQgIT09IG5ld1N0YXRlLmhlaWdodDtcbiAgICAgICAgdmFyIGZsZXhCYXNlQ2hhbmdlZCA9IHRoaXMuc3RhdGUuZmxleEJhc2lzICE9PSBuZXdTdGF0ZS5mbGV4QmFzaXM7XG4gICAgICAgIHZhciBjaGFuZ2VkID0gd2lkdGhDaGFuZ2VkIHx8IGhlaWdodENoYW5nZWQgfHwgZmxleEJhc2VDaGFuZ2VkO1xuICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgLy8gRm9yIHYxOCwgdXBkYXRlIHN0YXRlIHN5bmNcbiAgICAgICAgICAgIGZsdXNoU3luYyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUobmV3U3RhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25SZXNpemUpIHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vblJlc2l6ZShldmVudCwgZGlyZWN0aW9uLCB0aGlzLnJlc2l6YWJsZSwgZGVsdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBSZXNpemFibGUucHJvdG90eXBlLm9uTW91c2VVcCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB2YXIgX2MgPSB0aGlzLnN0YXRlLCBpc1Jlc2l6aW5nID0gX2MuaXNSZXNpemluZywgZGlyZWN0aW9uID0gX2MuZGlyZWN0aW9uLCBvcmlnaW5hbCA9IF9jLm9yaWdpbmFsO1xuICAgICAgICBpZiAoIWlzUmVzaXppbmcgfHwgIXRoaXMucmVzaXphYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25SZXNpemVTdG9wKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uUmVzaXplU3RvcChldmVudCwgZGlyZWN0aW9uLCB0aGlzLnJlc2l6YWJsZSwgdGhpcy5kZWx0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvcHMuc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHdpZHRoOiAoX2EgPSB0aGlzLnByb3BzLnNpemUud2lkdGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdhdXRvJywgaGVpZ2h0OiAoX2IgPSB0aGlzLnByb3BzLnNpemUuaGVpZ2h0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnYXV0bycgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bmJpbmRFdmVudHMoKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBpc1Jlc2l6aW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGJhY2tncm91bmRTdHlsZTogX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMuc3RhdGUuYmFja2dyb3VuZFN0eWxlKSwgeyBjdXJzb3I6ICdhdXRvJyB9KSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZXNpemFibGUucHJvdG90eXBlLnVwZGF0ZVNpemUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgd2lkdGg6IChfYSA9IHNpemUud2lkdGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdhdXRvJywgaGVpZ2h0OiAoX2IgPSBzaXplLmhlaWdodCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ2F1dG8nIH0pO1xuICAgIH07XG4gICAgUmVzaXphYmxlLnByb3RvdHlwZS5yZW5kZXJSZXNpemVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBlbmFibGUgPSBfYS5lbmFibGUsIGhhbmRsZVN0eWxlcyA9IF9hLmhhbmRsZVN0eWxlcywgaGFuZGxlQ2xhc3NlcyA9IF9hLmhhbmRsZUNsYXNzZXMsIGhhbmRsZVdyYXBwZXJTdHlsZSA9IF9hLmhhbmRsZVdyYXBwZXJTdHlsZSwgaGFuZGxlV3JhcHBlckNsYXNzID0gX2EuaGFuZGxlV3JhcHBlckNsYXNzLCBoYW5kbGVDb21wb25lbnQgPSBfYS5oYW5kbGVDb21wb25lbnQ7XG4gICAgICAgIGlmICghZW5hYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzaXplcnMgPSBPYmplY3Qua2V5cyhlbmFibGUpLm1hcChmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgICAgICBpZiAoZW5hYmxlW2Rpcl0gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChfanN4KFJlc2l6ZXIsIHsgZGlyZWN0aW9uOiBkaXIsIG9uUmVzaXplU3RhcnQ6IF90aGlzLm9uUmVzaXplU3RhcnQsIHJlcGxhY2VTdHlsZXM6IGhhbmRsZVN0eWxlcyAmJiBoYW5kbGVTdHlsZXNbZGlyXSwgY2xhc3NOYW1lOiBoYW5kbGVDbGFzc2VzICYmIGhhbmRsZUNsYXNzZXNbZGlyXSwgY2hpbGRyZW46IGhhbmRsZUNvbXBvbmVudCAmJiBoYW5kbGVDb21wb25lbnRbZGlyXSA/IGhhbmRsZUNvbXBvbmVudFtkaXJdIDogbnVsbCB9LCBkaXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gIzkzIFdyYXAgdGhlIHJlc2l6ZSBib3ggaW4gc3BhbiAod2lsbCBub3QgYnJlYWsgMTAwJSB3aWR0aC9oZWlnaHQpXG4gICAgICAgIHJldHVybiAoX2pzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogaGFuZGxlV3JhcHBlckNsYXNzLCBzdHlsZTogaGFuZGxlV3JhcHBlclN0eWxlLCBjaGlsZHJlbjogcmVzaXplcnMgfSkpO1xuICAgIH07XG4gICAgUmVzaXphYmxlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBleHRlbmRzUHJvcHMgPSBPYmplY3Qua2V5cyh0aGlzLnByb3BzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgICAgICAgICBpZiAoZGVmaW5lZFByb3BzLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWNjW2tleV0gPSBfdGhpcy5wcm9wc1trZXldO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgICB2YXIgc3R5bGUgPSBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7IHBvc2l0aW9uOiAncmVsYXRpdmUnLCB1c2VyU2VsZWN0OiB0aGlzLnN0YXRlLmlzUmVzaXppbmcgPyAnbm9uZScgOiAnYXV0bycgfSwgdGhpcy5wcm9wcy5zdHlsZSksIHRoaXMuc2l6ZVN0eWxlKSwgeyBtYXhXaWR0aDogdGhpcy5wcm9wcy5tYXhXaWR0aCwgbWF4SGVpZ2h0OiB0aGlzLnByb3BzLm1heEhlaWdodCwgbWluV2lkdGg6IHRoaXMucHJvcHMubWluV2lkdGgsIG1pbkhlaWdodDogdGhpcy5wcm9wcy5taW5IZWlnaHQsIGJveFNpemluZzogJ2JvcmRlci1ib3gnLCBmbGV4U2hyaW5rOiAwIH0pO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5mbGV4QmFzaXMpIHtcbiAgICAgICAgICAgIHN0eWxlLmZsZXhCYXNpcyA9IHRoaXMuc3RhdGUuZmxleEJhc2lzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBXcmFwcGVyID0gdGhpcy5wcm9wcy5hcyB8fCAnZGl2JztcbiAgICAgICAgcmV0dXJuIChfanN4cyhXcmFwcGVyLCBfX2Fzc2lnbih7IHN0eWxlOiBzdHlsZSwgY2xhc3NOYW1lOiB0aGlzLnByb3BzLmNsYXNzTmFtZSB9LCBleHRlbmRzUHJvcHMsIHsgXG4gICAgICAgICAgICAvLyBgcmVmYCBpcyBhZnRlciBgZXh0ZW5kc1Byb3BzYCB0byBlbnN1cmUgdGhpcyBvbmUgd2lucyBvdmVyIGEgdmVyc2lvblxuICAgICAgICAgICAgLy8gcGFzc2VkIGluXG4gICAgICAgICAgICByZWY6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVzaXphYmxlID0gYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBjaGlsZHJlbjogW3RoaXMuc3RhdGUuaXNSZXNpemluZyAmJiBfanN4KFwiZGl2XCIsIHsgc3R5bGU6IHRoaXMuc3RhdGUuYmFja2dyb3VuZFN0eWxlIH0pLCB0aGlzLnByb3BzLmNoaWxkcmVuLCB0aGlzLnJlbmRlclJlc2l6ZXIoKV0gfSkpKTtcbiAgICB9O1xuICAgIFJlc2l6YWJsZS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGFzOiAnZGl2JyxcbiAgICAgICAgb25SZXNpemVTdGFydDogZnVuY3Rpb24gKCkgeyB9LFxuICAgICAgICBvblJlc2l6ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgICAgICBvblJlc2l6ZVN0b3A6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICAgICAgZW5hYmxlOiB7XG4gICAgICAgICAgICB0b3A6IHRydWUsXG4gICAgICAgICAgICByaWdodDogdHJ1ZSxcbiAgICAgICAgICAgIGJvdHRvbTogdHJ1ZSxcbiAgICAgICAgICAgIGxlZnQ6IHRydWUsXG4gICAgICAgICAgICB0b3BSaWdodDogdHJ1ZSxcbiAgICAgICAgICAgIGJvdHRvbVJpZ2h0OiB0cnVlLFxuICAgICAgICAgICAgYm90dG9tTGVmdDogdHJ1ZSxcbiAgICAgICAgICAgIHRvcExlZnQ6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiB7fSxcbiAgICAgICAgZ3JpZDogWzEsIDFdLFxuICAgICAgICBncmlkR2FwOiBbMCwgMF0sXG4gICAgICAgIGxvY2tBc3BlY3RSYXRpbzogZmFsc2UsXG4gICAgICAgIGxvY2tBc3BlY3RSYXRpb0V4dHJhV2lkdGg6IDAsXG4gICAgICAgIGxvY2tBc3BlY3RSYXRpb0V4dHJhSGVpZ2h0OiAwLFxuICAgICAgICBzY2FsZTogMSxcbiAgICAgICAgcmVzaXplUmF0aW86IDEsXG4gICAgICAgIHNuYXBHYXA6IDAsXG4gICAgfTtcbiAgICByZXR1cm4gUmVzaXphYmxlO1xufShQdXJlQ29tcG9uZW50KSk7XG5leHBvcnQgeyBSZXNpemFibGUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/re-resizable/lib/index.js\n"));

/***/ }),

/***/ "./node_modules/re-resizable/lib/resizer.js":
/*!**************************************************!*\
  !*** ./node_modules/re-resizable/lib/resizer.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Resizer\": function() { return /* binding */ Resizer; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\n\nvar rowSizeBase = {\n    width: '100%',\n    height: '10px',\n    top: '0px',\n    left: '0px',\n    cursor: 'row-resize',\n};\nvar colSizeBase = {\n    width: '10px',\n    height: '100%',\n    top: '0px',\n    left: '0px',\n    cursor: 'col-resize',\n};\nvar edgeBase = {\n    width: '20px',\n    height: '20px',\n    position: 'absolute',\n    zIndex: 1,\n};\nvar styles = {\n    top: __assign(__assign({}, rowSizeBase), { top: '-5px' }),\n    right: __assign(__assign({}, colSizeBase), { left: undefined, right: '-5px' }),\n    bottom: __assign(__assign({}, rowSizeBase), { top: undefined, bottom: '-5px' }),\n    left: __assign(__assign({}, colSizeBase), { left: '-5px' }),\n    topRight: __assign(__assign({}, edgeBase), { right: '-10px', top: '-10px', cursor: 'ne-resize' }),\n    bottomRight: __assign(__assign({}, edgeBase), { right: '-10px', bottom: '-10px', cursor: 'se-resize' }),\n    bottomLeft: __assign(__assign({}, edgeBase), { left: '-10px', bottom: '-10px', cursor: 'sw-resize' }),\n    topLeft: __assign(__assign({}, edgeBase), { left: '-10px', top: '-10px', cursor: 'nw-resize' }),\n};\nvar Resizer = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(function (props) {\n    var onResizeStart = props.onResizeStart, direction = props.direction, children = props.children, replaceStyles = props.replaceStyles, className = props.className;\n    var onMouseDown = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function (e) {\n        onResizeStart(e, direction);\n    }, [onResizeStart, direction]);\n    var onTouchStart = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function (e) {\n        onResizeStart(e, direction);\n    }, [onResizeStart, direction]);\n    var style = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function () {\n        return __assign(__assign({ position: 'absolute', userSelect: 'none' }, styles[direction]), (replaceStyles !== null && replaceStyles !== void 0 ? replaceStyles : {}));\n    }, [replaceStyles, direction]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: className || undefined, style: style, onMouseDown: onMouseDown, onTouchStart: onTouchStart, children: children }));\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmUtcmVzaXphYmxlL2xpYi9yZXNpemVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsZ0JBQWdCLFNBQUksSUFBSSxTQUFJO0FBQzVCO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNnRDtBQUNHO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0IsYUFBYTtBQUM1RCwrQkFBK0Isa0JBQWtCLGdDQUFnQztBQUNqRixnQ0FBZ0Msa0JBQWtCLGdDQUFnQztBQUNsRiw4QkFBOEIsa0JBQWtCLGNBQWM7QUFDOUQsa0NBQWtDLGVBQWUsbURBQW1EO0FBQ3BHLHFDQUFxQyxlQUFlLHNEQUFzRDtBQUMxRyxvQ0FBb0MsZUFBZSxxREFBcUQ7QUFDeEcsaUNBQWlDLGVBQWUsa0RBQWtEO0FBQ2xHO0FBQ08sY0FBYywyQ0FBSTtBQUN6QjtBQUNBLHNCQUFzQixrREFBVztBQUNqQztBQUNBLEtBQUs7QUFDTCx1QkFBdUIsa0RBQVc7QUFDbEM7QUFDQSxLQUFLO0FBQ0wsZ0JBQWdCLDhDQUFPO0FBQ3ZCLG1DQUFtQywwQ0FBMEMsOEZBQThGO0FBQzNLLEtBQUs7QUFDTCxZQUFZLHNEQUFJLFVBQVUsMkhBQTJIO0FBQ3JKLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlLXJlc2l6YWJsZS9saWIvcmVzaXplci5qcz9jYTBmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5pbXBvcnQgeyBqc3ggYXMgX2pzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgbWVtbywgdXNlQ2FsbGJhY2ssIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG52YXIgcm93U2l6ZUJhc2UgPSB7XG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBoZWlnaHQ6ICcxMHB4JyxcbiAgICB0b3A6ICcwcHgnLFxuICAgIGxlZnQ6ICcwcHgnLFxuICAgIGN1cnNvcjogJ3Jvdy1yZXNpemUnLFxufTtcbnZhciBjb2xTaXplQmFzZSA9IHtcbiAgICB3aWR0aDogJzEwcHgnLFxuICAgIGhlaWdodDogJzEwMCUnLFxuICAgIHRvcDogJzBweCcsXG4gICAgbGVmdDogJzBweCcsXG4gICAgY3Vyc29yOiAnY29sLXJlc2l6ZScsXG59O1xudmFyIGVkZ2VCYXNlID0ge1xuICAgIHdpZHRoOiAnMjBweCcsXG4gICAgaGVpZ2h0OiAnMjBweCcsXG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgekluZGV4OiAxLFxufTtcbnZhciBzdHlsZXMgPSB7XG4gICAgdG9wOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcm93U2l6ZUJhc2UpLCB7IHRvcDogJy01cHgnIH0pLFxuICAgIHJpZ2h0OiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY29sU2l6ZUJhc2UpLCB7IGxlZnQ6IHVuZGVmaW5lZCwgcmlnaHQ6ICctNXB4JyB9KSxcbiAgICBib3R0b206IF9fYXNzaWduKF9fYXNzaWduKHt9LCByb3dTaXplQmFzZSksIHsgdG9wOiB1bmRlZmluZWQsIGJvdHRvbTogJy01cHgnIH0pLFxuICAgIGxlZnQ6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBjb2xTaXplQmFzZSksIHsgbGVmdDogJy01cHgnIH0pLFxuICAgIHRvcFJpZ2h0OiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZWRnZUJhc2UpLCB7IHJpZ2h0OiAnLTEwcHgnLCB0b3A6ICctMTBweCcsIGN1cnNvcjogJ25lLXJlc2l6ZScgfSksXG4gICAgYm90dG9tUmlnaHQ6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBlZGdlQmFzZSksIHsgcmlnaHQ6ICctMTBweCcsIGJvdHRvbTogJy0xMHB4JywgY3Vyc29yOiAnc2UtcmVzaXplJyB9KSxcbiAgICBib3R0b21MZWZ0OiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZWRnZUJhc2UpLCB7IGxlZnQ6ICctMTBweCcsIGJvdHRvbTogJy0xMHB4JywgY3Vyc29yOiAnc3ctcmVzaXplJyB9KSxcbiAgICB0b3BMZWZ0OiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZWRnZUJhc2UpLCB7IGxlZnQ6ICctMTBweCcsIHRvcDogJy0xMHB4JywgY3Vyc29yOiAnbnctcmVzaXplJyB9KSxcbn07XG5leHBvcnQgdmFyIFJlc2l6ZXIgPSBtZW1vKGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHZhciBvblJlc2l6ZVN0YXJ0ID0gcHJvcHMub25SZXNpemVTdGFydCwgZGlyZWN0aW9uID0gcHJvcHMuZGlyZWN0aW9uLCBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLCByZXBsYWNlU3R5bGVzID0gcHJvcHMucmVwbGFjZVN0eWxlcywgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lO1xuICAgIHZhciBvbk1vdXNlRG93biA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIG9uUmVzaXplU3RhcnQoZSwgZGlyZWN0aW9uKTtcbiAgICB9LCBbb25SZXNpemVTdGFydCwgZGlyZWN0aW9uXSk7XG4gICAgdmFyIG9uVG91Y2hTdGFydCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIG9uUmVzaXplU3RhcnQoZSwgZGlyZWN0aW9uKTtcbiAgICB9LCBbb25SZXNpemVTdGFydCwgZGlyZWN0aW9uXSk7XG4gICAgdmFyIHN0eWxlID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7IHBvc2l0aW9uOiAnYWJzb2x1dGUnLCB1c2VyU2VsZWN0OiAnbm9uZScgfSwgc3R5bGVzW2RpcmVjdGlvbl0pLCAocmVwbGFjZVN0eWxlcyAhPT0gbnVsbCAmJiByZXBsYWNlU3R5bGVzICE9PSB2b2lkIDAgPyByZXBsYWNlU3R5bGVzIDoge30pKTtcbiAgICB9LCBbcmVwbGFjZVN0eWxlcywgZGlyZWN0aW9uXSk7XG4gICAgcmV0dXJuIChfanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWUgfHwgdW5kZWZpbmVkLCBzdHlsZTogc3R5bGUsIG9uTW91c2VEb3duOiBvbk1vdXNlRG93biwgb25Ub3VjaFN0YXJ0OiBvblRvdWNoU3RhcnQsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/re-resizable/lib/resizer.js\n"));

/***/ }),

/***/ "./node_modules/react-draggable/build/cjs/Draggable.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-draggable/build/cjs/Draggable.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"DraggableCore\", ({\n  enumerable: true,\n  get: function () {\n    return _DraggableCore.default;\n  }\n}));\nexports[\"default\"] = void 0;\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\"));\nvar _reactDom = _interopRequireDefault(__webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"./node_modules/clsx/dist/clsx.m.js\"));\nvar _domFns = __webpack_require__(/*! ./utils/domFns */ \"./node_modules/react-draggable/build/cjs/utils/domFns.js\");\nvar _positionFns = __webpack_require__(/*! ./utils/positionFns */ \"./node_modules/react-draggable/build/cjs/utils/positionFns.js\");\nvar _shims = __webpack_require__(/*! ./utils/shims */ \"./node_modules/react-draggable/build/cjs/utils/shims.js\");\nvar _DraggableCore = _interopRequireDefault(__webpack_require__(/*! ./DraggableCore */ \"./node_modules/react-draggable/build/cjs/DraggableCore.js\"));\nvar _log = _interopRequireDefault(__webpack_require__(/*! ./utils/log */ \"./node_modules/react-draggable/build/cjs/utils/log.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); } /*:: import type {ControlPosition, PositionOffsetControlPosition, DraggableCoreProps, DraggableCoreDefaultProps} from './DraggableCore';*/\n/*:: import type {Bounds, DraggableEventHandler} from './utils/types';*/\n/*:: import type {Element as ReactElement} from 'react';*/\n/*:: type DraggableState = {\n  dragging: boolean,\n  dragged: boolean,\n  x: number, y: number,\n  slackX: number, slackY: number,\n  isElementSVG: boolean,\n  prevPropsPosition: ?ControlPosition,\n};*/\n/*:: export type DraggableDefaultProps = {\n  ...DraggableCoreDefaultProps,\n  axis: 'both' | 'x' | 'y' | 'none',\n  bounds: Bounds | string | false,\n  defaultClassName: string,\n  defaultClassNameDragging: string,\n  defaultClassNameDragged: string,\n  defaultPosition: ControlPosition,\n  scale: number,\n};*/\n/*:: export type DraggableProps = {\n  ...DraggableCoreProps,\n  ...DraggableDefaultProps,\n  positionOffset: PositionOffsetControlPosition,\n  position: ControlPosition,\n};*/\n//\n// Define <Draggable>\n//\nclass Draggable extends React.Component /*:: <DraggableProps, DraggableState>*/{\n  // React 16.3+\n  // Arity (props, state)\n  static getDerivedStateFromProps(_ref /*:: */, _ref2 /*:: */) /*: ?Partial<DraggableState>*/{\n    let {\n      position\n    } /*: DraggableProps*/ = _ref /*: DraggableProps*/;\n    let {\n      prevPropsPosition\n    } /*: DraggableState*/ = _ref2 /*: DraggableState*/;\n    // Set x/y if a new position is provided in props that is different than the previous.\n    if (position && (!prevPropsPosition || position.x !== prevPropsPosition.x || position.y !== prevPropsPosition.y)) {\n      (0, _log.default)('Draggable: getDerivedStateFromProps %j', {\n        position,\n        prevPropsPosition\n      });\n      return {\n        x: position.x,\n        y: position.y,\n        prevPropsPosition: {\n          ...position\n        }\n      };\n    }\n    return null;\n  }\n  constructor(props /*: DraggableProps*/) {\n    super(props);\n    _defineProperty(this, \"onDragStart\", (e, coreData) => {\n      (0, _log.default)('Draggable: onDragStart: %j', coreData);\n\n      // Short-circuit if user's callback killed it.\n      const shouldStart = this.props.onStart(e, (0, _positionFns.createDraggableData)(this, coreData));\n      // Kills start event on core as well, so move handlers are never bound.\n      if (shouldStart === false) return false;\n      this.setState({\n        dragging: true,\n        dragged: true\n      });\n    });\n    _defineProperty(this, \"onDrag\", (e, coreData) => {\n      if (!this.state.dragging) return false;\n      (0, _log.default)('Draggable: onDrag: %j', coreData);\n      const uiData = (0, _positionFns.createDraggableData)(this, coreData);\n      const newState = {\n        x: uiData.x,\n        y: uiData.y,\n        slackX: 0,\n        slackY: 0\n      };\n\n      // Keep within bounds.\n      if (this.props.bounds) {\n        // Save original x and y.\n        const {\n          x,\n          y\n        } = newState;\n\n        // Add slack to the values used to calculate bound position. This will ensure that if\n        // we start removing slack, the element won't react to it right away until it's been\n        // completely removed.\n        newState.x += this.state.slackX;\n        newState.y += this.state.slackY;\n\n        // Get bound position. This will ceil/floor the x and y within the boundaries.\n        const [newStateX, newStateY] = (0, _positionFns.getBoundPosition)(this, newState.x, newState.y);\n        newState.x = newStateX;\n        newState.y = newStateY;\n\n        // Recalculate slack by noting how much was shaved by the boundPosition handler.\n        newState.slackX = this.state.slackX + (x - newState.x);\n        newState.slackY = this.state.slackY + (y - newState.y);\n\n        // Update the event we fire to reflect what really happened after bounds took effect.\n        uiData.x = newState.x;\n        uiData.y = newState.y;\n        uiData.deltaX = newState.x - this.state.x;\n        uiData.deltaY = newState.y - this.state.y;\n      }\n\n      // Short-circuit if user's callback killed it.\n      const shouldUpdate = this.props.onDrag(e, uiData);\n      if (shouldUpdate === false) return false;\n      this.setState(newState);\n    });\n    _defineProperty(this, \"onDragStop\", (e, coreData) => {\n      if (!this.state.dragging) return false;\n\n      // Short-circuit if user's callback killed it.\n      const shouldContinue = this.props.onStop(e, (0, _positionFns.createDraggableData)(this, coreData));\n      if (shouldContinue === false) return false;\n      (0, _log.default)('Draggable: onDragStop: %j', coreData);\n      const newState /*: Partial<DraggableState>*/ = {\n        dragging: false,\n        slackX: 0,\n        slackY: 0\n      };\n\n      // If this is a controlled component, the result of this operation will be to\n      // revert back to the old position. We expect a handler on `onDragStop`, at the least.\n      const controlled = Boolean(this.props.position);\n      if (controlled) {\n        const {\n          x,\n          y\n        } = this.props.position;\n        newState.x = x;\n        newState.y = y;\n      }\n      this.setState(newState);\n    });\n    this.state = {\n      // Whether or not we are currently dragging.\n      dragging: false,\n      // Whether or not we have been dragged before.\n      dragged: false,\n      // Current transform x and y.\n      x: props.position ? props.position.x : props.defaultPosition.x,\n      y: props.position ? props.position.y : props.defaultPosition.y,\n      prevPropsPosition: {\n        ...props.position\n      },\n      // Used for compensating for out-of-bounds drags\n      slackX: 0,\n      slackY: 0,\n      // Can only determine if SVG after mounting\n      isElementSVG: false\n    };\n    if (props.position && !(props.onDrag || props.onStop)) {\n      // eslint-disable-next-line no-console\n      console.warn('A `position` was applied to this <Draggable>, without drag handlers. This will make this ' + 'component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the ' + '`position` of this element.');\n    }\n  }\n  componentDidMount() {\n    // Check to see if the element passed is an instanceof SVGElement\n    if (typeof window.SVGElement !== 'undefined' && this.findDOMNode() instanceof window.SVGElement) {\n      this.setState({\n        isElementSVG: true\n      });\n    }\n  }\n  componentWillUnmount() {\n    this.setState({\n      dragging: false\n    }); // prevents invariant if unmounted while dragging\n  }\n\n  // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find\n  // the underlying DOM node ourselves. See the README for more information.\n  findDOMNode() /*: ?HTMLElement*/{\n    var _this$props$nodeRef$c, _this$props;\n    return (_this$props$nodeRef$c = (_this$props = this.props) === null || _this$props === void 0 || (_this$props = _this$props.nodeRef) === null || _this$props === void 0 ? void 0 : _this$props.current) !== null && _this$props$nodeRef$c !== void 0 ? _this$props$nodeRef$c : _reactDom.default.findDOMNode(this);\n  }\n  render() /*: ReactElement<any>*/{\n    const {\n      axis,\n      bounds,\n      children,\n      defaultPosition,\n      defaultClassName,\n      defaultClassNameDragging,\n      defaultClassNameDragged,\n      position,\n      positionOffset,\n      scale,\n      ...draggableCoreProps\n    } = this.props;\n    let style = {};\n    let svgTransform = null;\n\n    // If this is controlled, we don't want to move it - unless it's dragging.\n    const controlled = Boolean(position);\n    const draggable = !controlled || this.state.dragging;\n    const validPosition = position || defaultPosition;\n    const transformOpts = {\n      // Set left if horizontal drag is enabled\n      x: (0, _positionFns.canDragX)(this) && draggable ? this.state.x : validPosition.x,\n      // Set top if vertical drag is enabled\n      y: (0, _positionFns.canDragY)(this) && draggable ? this.state.y : validPosition.y\n    };\n\n    // If this element was SVG, we use the `transform` attribute.\n    if (this.state.isElementSVG) {\n      svgTransform = (0, _domFns.createSVGTransform)(transformOpts, positionOffset);\n    } else {\n      // Add a CSS transform to move the element around. This allows us to move the element around\n      // without worrying about whether or not it is relatively or absolutely positioned.\n      // If the item you are dragging already has a transform set, wrap it in a <span> so <Draggable>\n      // has a clean slate.\n      style = (0, _domFns.createCSSTransform)(transformOpts, positionOffset);\n    }\n\n    // Mark with class while dragging\n    const className = (0, _clsx.default)(children.props.className || '', defaultClassName, {\n      [defaultClassNameDragging]: this.state.dragging,\n      [defaultClassNameDragged]: this.state.dragged\n    });\n\n    // Reuse the child provided\n    // This makes it flexible to use whatever element is wanted (div, ul, etc)\n    return /*#__PURE__*/React.createElement(_DraggableCore.default, _extends({}, draggableCoreProps, {\n      onStart: this.onDragStart,\n      onDrag: this.onDrag,\n      onStop: this.onDragStop\n    }), /*#__PURE__*/React.cloneElement(React.Children.only(children), {\n      className: className,\n      style: {\n        ...children.props.style,\n        ...style\n      },\n      transform: svgTransform\n    }));\n  }\n}\nexports[\"default\"] = Draggable;\n_defineProperty(Draggable, \"displayName\", 'Draggable');\n_defineProperty(Draggable, \"propTypes\", {\n  // Accepts all props <DraggableCore> accepts.\n  ..._DraggableCore.default.propTypes,\n  /**\n   * `axis` determines which axis the draggable can move.\n   *\n   *  Note that all callbacks will still return data as normal. This only\n   *  controls flushing to the DOM.\n   *\n   * 'both' allows movement horizontally and vertically.\n   * 'x' limits movement to horizontal axis.\n   * 'y' limits movement to vertical axis.\n   * 'none' limits all movement.\n   *\n   * Defaults to 'both'.\n   */\n  axis: _propTypes.default.oneOf(['both', 'x', 'y', 'none']),\n  /**\n   * `bounds` determines the range of movement available to the element.\n   * Available values are:\n   *\n   * 'parent' restricts movement within the Draggable's parent node.\n   *\n   * Alternatively, pass an object with the following properties, all of which are optional:\n   *\n   * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}\n   *\n   * All values are in px.\n   *\n   * Example:\n   *\n   * ```jsx\n   *   let App = React.createClass({\n   *       render: function () {\n   *         return (\n   *            <Draggable bounds={{right: 300, bottom: 300}}>\n   *              <div>Content</div>\n   *           </Draggable>\n   *         );\n   *       }\n   *   });\n   * ```\n   */\n  bounds: _propTypes.default.oneOfType([_propTypes.default.shape({\n    left: _propTypes.default.number,\n    right: _propTypes.default.number,\n    top: _propTypes.default.number,\n    bottom: _propTypes.default.number\n  }), _propTypes.default.string, _propTypes.default.oneOf([false])]),\n  defaultClassName: _propTypes.default.string,\n  defaultClassNameDragging: _propTypes.default.string,\n  defaultClassNameDragged: _propTypes.default.string,\n  /**\n   * `defaultPosition` specifies the x and y that the dragged item should start at\n   *\n   * Example:\n   *\n   * ```jsx\n   *      let App = React.createClass({\n   *          render: function () {\n   *              return (\n   *                  <Draggable defaultPosition={{x: 25, y: 25}}>\n   *                      <div>I start with transformX: 25px and transformY: 25px;</div>\n   *                  </Draggable>\n   *              );\n   *          }\n   *      });\n   * ```\n   */\n  defaultPosition: _propTypes.default.shape({\n    x: _propTypes.default.number,\n    y: _propTypes.default.number\n  }),\n  positionOffset: _propTypes.default.shape({\n    x: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),\n    y: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string])\n  }),\n  /**\n   * `position`, if present, defines the current position of the element.\n   *\n   *  This is similar to how form elements in React work - if no `position` is supplied, the component\n   *  is uncontrolled.\n   *\n   * Example:\n   *\n   * ```jsx\n   *      let App = React.createClass({\n   *          render: function () {\n   *              return (\n   *                  <Draggable position={{x: 25, y: 25}}>\n   *                      <div>I start with transformX: 25px and transformY: 25px;</div>\n   *                  </Draggable>\n   *              );\n   *          }\n   *      });\n   * ```\n   */\n  position: _propTypes.default.shape({\n    x: _propTypes.default.number,\n    y: _propTypes.default.number\n  }),\n  /**\n   * These properties should be defined on the child, not here.\n   */\n  className: _shims.dontSetMe,\n  style: _shims.dontSetMe,\n  transform: _shims.dontSetMe\n});\n_defineProperty(Draggable, \"defaultProps\", {\n  ..._DraggableCore.default.defaultProps,\n  axis: 'both',\n  bounds: false,\n  defaultClassName: 'react-draggable',\n  defaultClassNameDragging: 'react-draggable-dragging',\n  defaultClassNameDragged: 'react-draggable-dragged',\n  defaultPosition: {\n    x: 0,\n    y: 0\n  },\n  scale: 1\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy9EcmFnZ2FibGUuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaURBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixvQ0FBb0MsbUJBQU8sQ0FBQyw0Q0FBTztBQUNuRCx3Q0FBd0MsbUJBQU8sQ0FBQyxzREFBWTtBQUM1RCx1Q0FBdUMsbUJBQU8sQ0FBQyxvREFBVztBQUMxRCxtQ0FBbUMsbUJBQU8sQ0FBQyxnREFBTTtBQUNqRCxjQUFjLG1CQUFPLENBQUMsZ0ZBQWdCO0FBQ3RDLG1CQUFtQixtQkFBTyxDQUFDLDBGQUFxQjtBQUNoRCxhQUFhLG1CQUFPLENBQUMsOEVBQWU7QUFDcEMsNENBQTRDLG1CQUFPLENBQUMsa0ZBQWlCO0FBQ3JFLGtDQUFrQyxtQkFBTyxDQUFDLDBFQUFhO0FBQ3ZELHVDQUF1Qyx1Q0FBdUM7QUFDOUUsaURBQWlELGdEQUFnRCx1Q0FBdUMsc0NBQXNDLDREQUE0RCw0REFBNEQ7QUFDdFMscURBQXFELDZDQUE2QyxjQUFjLDRFQUE0RSxTQUFTLGtCQUFrQixtREFBbUQsK0JBQStCLHlCQUF5QixpQkFBaUIsc0ZBQXNGLHVCQUF1QiwyRUFBMkUscUZBQXFGLHNDQUFzQyw0Q0FBNEMsT0FBTyw4QkFBOEIsc0JBQXNCLGFBQWEsMEJBQTBCO0FBQ3B4QixzQkFBc0Isc0VBQXNFLGdCQUFnQixzQkFBc0IsT0FBTywyQkFBMkIsMEJBQTBCLHlEQUF5RCxpQ0FBaUMsa0JBQWtCO0FBQzFTLDRDQUE0QywyQkFBMkIsa0JBQWtCLGtDQUFrQyxvRUFBb0UsS0FBSyxPQUFPLG9CQUFvQjtBQUMvTiwrQkFBK0IsdUNBQXVDO0FBQ3RFLHFDQUFxQywrREFBK0Qsc0NBQXNDLDBCQUEwQiwrQ0FBK0MseUNBQXlDLHVFQUF1RSx1REFBdUQsa0JBQWtCLCtGQUErRix1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QUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxjQUFjO0FBQzFELGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL0RyYWdnYWJsZS5qcz83ZTJjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRHJhZ2dhYmxlQ29yZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfRHJhZ2dhYmxlQ29yZS5kZWZhdWx0O1xuICB9XG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBSZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX3Byb3BUeXBlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xudmFyIF9yZWFjdERvbSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0LWRvbVwiKSk7XG52YXIgX2Nsc3ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcbnZhciBfZG9tRm5zID0gcmVxdWlyZShcIi4vdXRpbHMvZG9tRm5zXCIpO1xudmFyIF9wb3NpdGlvbkZucyA9IHJlcXVpcmUoXCIuL3V0aWxzL3Bvc2l0aW9uRm5zXCIpO1xudmFyIF9zaGltcyA9IHJlcXVpcmUoXCIuL3V0aWxzL3NoaW1zXCIpO1xudmFyIF9EcmFnZ2FibGVDb3JlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9EcmFnZ2FibGVDb3JlXCIpKTtcbnZhciBfbG9nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlscy9sb2dcIikpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiAobm9kZUludGVyb3ApIHsgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wOyB9KShub2RlSW50ZXJvcCk7IH1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHsgaWYgKCFub2RlSW50ZXJvcCAmJiBvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTsgcmV0dXJuIHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7IGlmICh0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAodHlwZW9mIHJlcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlczsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpOyB9IC8qOjogaW1wb3J0IHR5cGUge0NvbnRyb2xQb3NpdGlvbiwgUG9zaXRpb25PZmZzZXRDb250cm9sUG9zaXRpb24sIERyYWdnYWJsZUNvcmVQcm9wcywgRHJhZ2dhYmxlQ29yZURlZmF1bHRQcm9wc30gZnJvbSAnLi9EcmFnZ2FibGVDb3JlJzsqL1xuLyo6OiBpbXBvcnQgdHlwZSB7Qm91bmRzLCBEcmFnZ2FibGVFdmVudEhhbmRsZXJ9IGZyb20gJy4vdXRpbHMvdHlwZXMnOyovXG4vKjo6IGltcG9ydCB0eXBlIHtFbGVtZW50IGFzIFJlYWN0RWxlbWVudH0gZnJvbSAncmVhY3QnOyovXG4vKjo6IHR5cGUgRHJhZ2dhYmxlU3RhdGUgPSB7XG4gIGRyYWdnaW5nOiBib29sZWFuLFxuICBkcmFnZ2VkOiBib29sZWFuLFxuICB4OiBudW1iZXIsIHk6IG51bWJlcixcbiAgc2xhY2tYOiBudW1iZXIsIHNsYWNrWTogbnVtYmVyLFxuICBpc0VsZW1lbnRTVkc6IGJvb2xlYW4sXG4gIHByZXZQcm9wc1Bvc2l0aW9uOiA/Q29udHJvbFBvc2l0aW9uLFxufTsqL1xuLyo6OiBleHBvcnQgdHlwZSBEcmFnZ2FibGVEZWZhdWx0UHJvcHMgPSB7XG4gIC4uLkRyYWdnYWJsZUNvcmVEZWZhdWx0UHJvcHMsXG4gIGF4aXM6ICdib3RoJyB8ICd4JyB8ICd5JyB8ICdub25lJyxcbiAgYm91bmRzOiBCb3VuZHMgfCBzdHJpbmcgfCBmYWxzZSxcbiAgZGVmYXVsdENsYXNzTmFtZTogc3RyaW5nLFxuICBkZWZhdWx0Q2xhc3NOYW1lRHJhZ2dpbmc6IHN0cmluZyxcbiAgZGVmYXVsdENsYXNzTmFtZURyYWdnZWQ6IHN0cmluZyxcbiAgZGVmYXVsdFBvc2l0aW9uOiBDb250cm9sUG9zaXRpb24sXG4gIHNjYWxlOiBudW1iZXIsXG59OyovXG4vKjo6IGV4cG9ydCB0eXBlIERyYWdnYWJsZVByb3BzID0ge1xuICAuLi5EcmFnZ2FibGVDb3JlUHJvcHMsXG4gIC4uLkRyYWdnYWJsZURlZmF1bHRQcm9wcyxcbiAgcG9zaXRpb25PZmZzZXQ6IFBvc2l0aW9uT2Zmc2V0Q29udHJvbFBvc2l0aW9uLFxuICBwb3NpdGlvbjogQ29udHJvbFBvc2l0aW9uLFxufTsqL1xuLy9cbi8vIERlZmluZSA8RHJhZ2dhYmxlPlxuLy9cbmNsYXNzIERyYWdnYWJsZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCAvKjo6IDxEcmFnZ2FibGVQcm9wcywgRHJhZ2dhYmxlU3RhdGU+Ki97XG4gIC8vIFJlYWN0IDE2LjMrXG4gIC8vIEFyaXR5IChwcm9wcywgc3RhdGUpXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoX3JlZiAvKjo6ICovLCBfcmVmMiAvKjo6ICovKSAvKjogP1BhcnRpYWw8RHJhZ2dhYmxlU3RhdGU+Ki97XG4gICAgbGV0IHtcbiAgICAgIHBvc2l0aW9uXG4gICAgfSAvKjogRHJhZ2dhYmxlUHJvcHMqLyA9IF9yZWYgLyo6IERyYWdnYWJsZVByb3BzKi87XG4gICAgbGV0IHtcbiAgICAgIHByZXZQcm9wc1Bvc2l0aW9uXG4gICAgfSAvKjogRHJhZ2dhYmxlU3RhdGUqLyA9IF9yZWYyIC8qOiBEcmFnZ2FibGVTdGF0ZSovO1xuICAgIC8vIFNldCB4L3kgaWYgYSBuZXcgcG9zaXRpb24gaXMgcHJvdmlkZWQgaW4gcHJvcHMgdGhhdCBpcyBkaWZmZXJlbnQgdGhhbiB0aGUgcHJldmlvdXMuXG4gICAgaWYgKHBvc2l0aW9uICYmICghcHJldlByb3BzUG9zaXRpb24gfHwgcG9zaXRpb24ueCAhPT0gcHJldlByb3BzUG9zaXRpb24ueCB8fCBwb3NpdGlvbi55ICE9PSBwcmV2UHJvcHNQb3NpdGlvbi55KSkge1xuICAgICAgKDAsIF9sb2cuZGVmYXVsdCkoJ0RyYWdnYWJsZTogZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICVqJywge1xuICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgcHJldlByb3BzUG9zaXRpb25cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcG9zaXRpb24ueCxcbiAgICAgICAgeTogcG9zaXRpb24ueSxcbiAgICAgICAgcHJldlByb3BzUG9zaXRpb246IHtcbiAgICAgICAgICAuLi5wb3NpdGlvblxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdHJ1Y3Rvcihwcm9wcyAvKjogRHJhZ2dhYmxlUHJvcHMqLykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkRyYWdTdGFydFwiLCAoZSwgY29yZURhdGEpID0+IHtcbiAgICAgICgwLCBfbG9nLmRlZmF1bHQpKCdEcmFnZ2FibGU6IG9uRHJhZ1N0YXJ0OiAlaicsIGNvcmVEYXRhKTtcblxuICAgICAgLy8gU2hvcnQtY2lyY3VpdCBpZiB1c2VyJ3MgY2FsbGJhY2sga2lsbGVkIGl0LlxuICAgICAgY29uc3Qgc2hvdWxkU3RhcnQgPSB0aGlzLnByb3BzLm9uU3RhcnQoZSwgKDAsIF9wb3NpdGlvbkZucy5jcmVhdGVEcmFnZ2FibGVEYXRhKSh0aGlzLCBjb3JlRGF0YSkpO1xuICAgICAgLy8gS2lsbHMgc3RhcnQgZXZlbnQgb24gY29yZSBhcyB3ZWxsLCBzbyBtb3ZlIGhhbmRsZXJzIGFyZSBuZXZlciBib3VuZC5cbiAgICAgIGlmIChzaG91bGRTdGFydCA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBkcmFnZ2luZzogdHJ1ZSxcbiAgICAgICAgZHJhZ2dlZDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib25EcmFnXCIsIChlLCBjb3JlRGF0YSkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnN0YXRlLmRyYWdnaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgICAoMCwgX2xvZy5kZWZhdWx0KSgnRHJhZ2dhYmxlOiBvbkRyYWc6ICVqJywgY29yZURhdGEpO1xuICAgICAgY29uc3QgdWlEYXRhID0gKDAsIF9wb3NpdGlvbkZucy5jcmVhdGVEcmFnZ2FibGVEYXRhKSh0aGlzLCBjb3JlRGF0YSk7XG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAgICAgeDogdWlEYXRhLngsXG4gICAgICAgIHk6IHVpRGF0YS55LFxuICAgICAgICBzbGFja1g6IDAsXG4gICAgICAgIHNsYWNrWTogMFxuICAgICAgfTtcblxuICAgICAgLy8gS2VlcCB3aXRoaW4gYm91bmRzLlxuICAgICAgaWYgKHRoaXMucHJvcHMuYm91bmRzKSB7XG4gICAgICAgIC8vIFNhdmUgb3JpZ2luYWwgeCBhbmQgeS5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHgsXG4gICAgICAgICAgeVxuICAgICAgICB9ID0gbmV3U3RhdGU7XG5cbiAgICAgICAgLy8gQWRkIHNsYWNrIHRvIHRoZSB2YWx1ZXMgdXNlZCB0byBjYWxjdWxhdGUgYm91bmQgcG9zaXRpb24uIFRoaXMgd2lsbCBlbnN1cmUgdGhhdCBpZlxuICAgICAgICAvLyB3ZSBzdGFydCByZW1vdmluZyBzbGFjaywgdGhlIGVsZW1lbnQgd29uJ3QgcmVhY3QgdG8gaXQgcmlnaHQgYXdheSB1bnRpbCBpdCdzIGJlZW5cbiAgICAgICAgLy8gY29tcGxldGVseSByZW1vdmVkLlxuICAgICAgICBuZXdTdGF0ZS54ICs9IHRoaXMuc3RhdGUuc2xhY2tYO1xuICAgICAgICBuZXdTdGF0ZS55ICs9IHRoaXMuc3RhdGUuc2xhY2tZO1xuXG4gICAgICAgIC8vIEdldCBib3VuZCBwb3NpdGlvbi4gVGhpcyB3aWxsIGNlaWwvZmxvb3IgdGhlIHggYW5kIHkgd2l0aGluIHRoZSBib3VuZGFyaWVzLlxuICAgICAgICBjb25zdCBbbmV3U3RhdGVYLCBuZXdTdGF0ZVldID0gKDAsIF9wb3NpdGlvbkZucy5nZXRCb3VuZFBvc2l0aW9uKSh0aGlzLCBuZXdTdGF0ZS54LCBuZXdTdGF0ZS55KTtcbiAgICAgICAgbmV3U3RhdGUueCA9IG5ld1N0YXRlWDtcbiAgICAgICAgbmV3U3RhdGUueSA9IG5ld1N0YXRlWTtcblxuICAgICAgICAvLyBSZWNhbGN1bGF0ZSBzbGFjayBieSBub3RpbmcgaG93IG11Y2ggd2FzIHNoYXZlZCBieSB0aGUgYm91bmRQb3NpdGlvbiBoYW5kbGVyLlxuICAgICAgICBuZXdTdGF0ZS5zbGFja1ggPSB0aGlzLnN0YXRlLnNsYWNrWCArICh4IC0gbmV3U3RhdGUueCk7XG4gICAgICAgIG5ld1N0YXRlLnNsYWNrWSA9IHRoaXMuc3RhdGUuc2xhY2tZICsgKHkgLSBuZXdTdGF0ZS55KTtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIGV2ZW50IHdlIGZpcmUgdG8gcmVmbGVjdCB3aGF0IHJlYWxseSBoYXBwZW5lZCBhZnRlciBib3VuZHMgdG9vayBlZmZlY3QuXG4gICAgICAgIHVpRGF0YS54ID0gbmV3U3RhdGUueDtcbiAgICAgICAgdWlEYXRhLnkgPSBuZXdTdGF0ZS55O1xuICAgICAgICB1aURhdGEuZGVsdGFYID0gbmV3U3RhdGUueCAtIHRoaXMuc3RhdGUueDtcbiAgICAgICAgdWlEYXRhLmRlbHRhWSA9IG5ld1N0YXRlLnkgLSB0aGlzLnN0YXRlLnk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNob3J0LWNpcmN1aXQgaWYgdXNlcidzIGNhbGxiYWNrIGtpbGxlZCBpdC5cbiAgICAgIGNvbnN0IHNob3VsZFVwZGF0ZSA9IHRoaXMucHJvcHMub25EcmFnKGUsIHVpRGF0YSk7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgdGhpcy5zZXRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib25EcmFnU3RvcFwiLCAoZSwgY29yZURhdGEpID0+IHtcbiAgICAgIGlmICghdGhpcy5zdGF0ZS5kcmFnZ2luZykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBTaG9ydC1jaXJjdWl0IGlmIHVzZXIncyBjYWxsYmFjayBraWxsZWQgaXQuXG4gICAgICBjb25zdCBzaG91bGRDb250aW51ZSA9IHRoaXMucHJvcHMub25TdG9wKGUsICgwLCBfcG9zaXRpb25GbnMuY3JlYXRlRHJhZ2dhYmxlRGF0YSkodGhpcywgY29yZURhdGEpKTtcbiAgICAgIGlmIChzaG91bGRDb250aW51ZSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICgwLCBfbG9nLmRlZmF1bHQpKCdEcmFnZ2FibGU6IG9uRHJhZ1N0b3A6ICVqJywgY29yZURhdGEpO1xuICAgICAgY29uc3QgbmV3U3RhdGUgLyo6IFBhcnRpYWw8RHJhZ2dhYmxlU3RhdGU+Ki8gPSB7XG4gICAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgc2xhY2tYOiAwLFxuICAgICAgICBzbGFja1k6IDBcbiAgICAgIH07XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgYSBjb250cm9sbGVkIGNvbXBvbmVudCwgdGhlIHJlc3VsdCBvZiB0aGlzIG9wZXJhdGlvbiB3aWxsIGJlIHRvXG4gICAgICAvLyByZXZlcnQgYmFjayB0byB0aGUgb2xkIHBvc2l0aW9uLiBXZSBleHBlY3QgYSBoYW5kbGVyIG9uIGBvbkRyYWdTdG9wYCwgYXQgdGhlIGxlYXN0LlxuICAgICAgY29uc3QgY29udHJvbGxlZCA9IEJvb2xlYW4odGhpcy5wcm9wcy5wb3NpdGlvbik7XG4gICAgICBpZiAoY29udHJvbGxlZCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgeCxcbiAgICAgICAgICB5XG4gICAgICAgIH0gPSB0aGlzLnByb3BzLnBvc2l0aW9uO1xuICAgICAgICBuZXdTdGF0ZS54ID0geDtcbiAgICAgICAgbmV3U3RhdGUueSA9IHk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcbiAgICB9KTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgLy8gV2hldGhlciBvciBub3Qgd2UgYXJlIGN1cnJlbnRseSBkcmFnZ2luZy5cbiAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgIC8vIFdoZXRoZXIgb3Igbm90IHdlIGhhdmUgYmVlbiBkcmFnZ2VkIGJlZm9yZS5cbiAgICAgIGRyYWdnZWQ6IGZhbHNlLFxuICAgICAgLy8gQ3VycmVudCB0cmFuc2Zvcm0geCBhbmQgeS5cbiAgICAgIHg6IHByb3BzLnBvc2l0aW9uID8gcHJvcHMucG9zaXRpb24ueCA6IHByb3BzLmRlZmF1bHRQb3NpdGlvbi54LFxuICAgICAgeTogcHJvcHMucG9zaXRpb24gPyBwcm9wcy5wb3NpdGlvbi55IDogcHJvcHMuZGVmYXVsdFBvc2l0aW9uLnksXG4gICAgICBwcmV2UHJvcHNQb3NpdGlvbjoge1xuICAgICAgICAuLi5wcm9wcy5wb3NpdGlvblxuICAgICAgfSxcbiAgICAgIC8vIFVzZWQgZm9yIGNvbXBlbnNhdGluZyBmb3Igb3V0LW9mLWJvdW5kcyBkcmFnc1xuICAgICAgc2xhY2tYOiAwLFxuICAgICAgc2xhY2tZOiAwLFxuICAgICAgLy8gQ2FuIG9ubHkgZGV0ZXJtaW5lIGlmIFNWRyBhZnRlciBtb3VudGluZ1xuICAgICAgaXNFbGVtZW50U1ZHOiBmYWxzZVxuICAgIH07XG4gICAgaWYgKHByb3BzLnBvc2l0aW9uICYmICEocHJvcHMub25EcmFnIHx8IHByb3BzLm9uU3RvcCkpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oJ0EgYHBvc2l0aW9uYCB3YXMgYXBwbGllZCB0byB0aGlzIDxEcmFnZ2FibGU+LCB3aXRob3V0IGRyYWcgaGFuZGxlcnMuIFRoaXMgd2lsbCBtYWtlIHRoaXMgJyArICdjb21wb25lbnQgZWZmZWN0aXZlbHkgdW5kcmFnZ2FibGUuIFBsZWFzZSBhdHRhY2ggYG9uRHJhZ2Agb3IgYG9uU3RvcGAgaGFuZGxlcnMgc28geW91IGNhbiBhZGp1c3QgdGhlICcgKyAnYHBvc2l0aW9uYCBvZiB0aGlzIGVsZW1lbnQuJyk7XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgZWxlbWVudCBwYXNzZWQgaXMgYW4gaW5zdGFuY2VvZiBTVkdFbGVtZW50XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuU1ZHRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5maW5kRE9NTm9kZSgpIGluc3RhbmNlb2Ygd2luZG93LlNWR0VsZW1lbnQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpc0VsZW1lbnRTVkc6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGRyYWdnaW5nOiBmYWxzZVxuICAgIH0pOyAvLyBwcmV2ZW50cyBpbnZhcmlhbnQgaWYgdW5tb3VudGVkIHdoaWxlIGRyYWdnaW5nXG4gIH1cblxuICAvLyBSZWFjdCBTdHJpY3QgTW9kZSBjb21wYXRpYmlsaXR5OiBpZiBgbm9kZVJlZmAgaXMgcGFzc2VkLCB3ZSB3aWxsIHVzZSBpdCBpbnN0ZWFkIG9mIHRyeWluZyB0byBmaW5kXG4gIC8vIHRoZSB1bmRlcmx5aW5nIERPTSBub2RlIG91cnNlbHZlcy4gU2VlIHRoZSBSRUFETUUgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gIGZpbmRET01Ob2RlKCkgLyo6ID9IVE1MRWxlbWVudCove1xuICAgIHZhciBfdGhpcyRwcm9wcyRub2RlUmVmJGMsIF90aGlzJHByb3BzO1xuICAgIHJldHVybiAoX3RoaXMkcHJvcHMkbm9kZVJlZiRjID0gKF90aGlzJHByb3BzID0gdGhpcy5wcm9wcykgPT09IG51bGwgfHwgX3RoaXMkcHJvcHMgPT09IHZvaWQgMCB8fCAoX3RoaXMkcHJvcHMgPSBfdGhpcyRwcm9wcy5ub2RlUmVmKSA9PT0gbnVsbCB8fCBfdGhpcyRwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkcHJvcHMuY3VycmVudCkgIT09IG51bGwgJiYgX3RoaXMkcHJvcHMkbm9kZVJlZiRjICE9PSB2b2lkIDAgPyBfdGhpcyRwcm9wcyRub2RlUmVmJGMgOiBfcmVhY3REb20uZGVmYXVsdC5maW5kRE9NTm9kZSh0aGlzKTtcbiAgfVxuICByZW5kZXIoKSAvKjogUmVhY3RFbGVtZW50PGFueT4qL3tcbiAgICBjb25zdCB7XG4gICAgICBheGlzLFxuICAgICAgYm91bmRzLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBkZWZhdWx0UG9zaXRpb24sXG4gICAgICBkZWZhdWx0Q2xhc3NOYW1lLFxuICAgICAgZGVmYXVsdENsYXNzTmFtZURyYWdnaW5nLFxuICAgICAgZGVmYXVsdENsYXNzTmFtZURyYWdnZWQsXG4gICAgICBwb3NpdGlvbixcbiAgICAgIHBvc2l0aW9uT2Zmc2V0LFxuICAgICAgc2NhbGUsXG4gICAgICAuLi5kcmFnZ2FibGVDb3JlUHJvcHNcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBsZXQgc3R5bGUgPSB7fTtcbiAgICBsZXQgc3ZnVHJhbnNmb3JtID0gbnVsbDtcblxuICAgIC8vIElmIHRoaXMgaXMgY29udHJvbGxlZCwgd2UgZG9uJ3Qgd2FudCB0byBtb3ZlIGl0IC0gdW5sZXNzIGl0J3MgZHJhZ2dpbmcuXG4gICAgY29uc3QgY29udHJvbGxlZCA9IEJvb2xlYW4ocG9zaXRpb24pO1xuICAgIGNvbnN0IGRyYWdnYWJsZSA9ICFjb250cm9sbGVkIHx8IHRoaXMuc3RhdGUuZHJhZ2dpbmc7XG4gICAgY29uc3QgdmFsaWRQb3NpdGlvbiA9IHBvc2l0aW9uIHx8IGRlZmF1bHRQb3NpdGlvbjtcbiAgICBjb25zdCB0cmFuc2Zvcm1PcHRzID0ge1xuICAgICAgLy8gU2V0IGxlZnQgaWYgaG9yaXpvbnRhbCBkcmFnIGlzIGVuYWJsZWRcbiAgICAgIHg6ICgwLCBfcG9zaXRpb25GbnMuY2FuRHJhZ1gpKHRoaXMpICYmIGRyYWdnYWJsZSA/IHRoaXMuc3RhdGUueCA6IHZhbGlkUG9zaXRpb24ueCxcbiAgICAgIC8vIFNldCB0b3AgaWYgdmVydGljYWwgZHJhZyBpcyBlbmFibGVkXG4gICAgICB5OiAoMCwgX3Bvc2l0aW9uRm5zLmNhbkRyYWdZKSh0aGlzKSAmJiBkcmFnZ2FibGUgPyB0aGlzLnN0YXRlLnkgOiB2YWxpZFBvc2l0aW9uLnlcbiAgICB9O1xuXG4gICAgLy8gSWYgdGhpcyBlbGVtZW50IHdhcyBTVkcsIHdlIHVzZSB0aGUgYHRyYW5zZm9ybWAgYXR0cmlidXRlLlxuICAgIGlmICh0aGlzLnN0YXRlLmlzRWxlbWVudFNWRykge1xuICAgICAgc3ZnVHJhbnNmb3JtID0gKDAsIF9kb21GbnMuY3JlYXRlU1ZHVHJhbnNmb3JtKSh0cmFuc2Zvcm1PcHRzLCBwb3NpdGlvbk9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFkZCBhIENTUyB0cmFuc2Zvcm0gdG8gbW92ZSB0aGUgZWxlbWVudCBhcm91bmQuIFRoaXMgYWxsb3dzIHVzIHRvIG1vdmUgdGhlIGVsZW1lbnQgYXJvdW5kXG4gICAgICAvLyB3aXRob3V0IHdvcnJ5aW5nIGFib3V0IHdoZXRoZXIgb3Igbm90IGl0IGlzIHJlbGF0aXZlbHkgb3IgYWJzb2x1dGVseSBwb3NpdGlvbmVkLlxuICAgICAgLy8gSWYgdGhlIGl0ZW0geW91IGFyZSBkcmFnZ2luZyBhbHJlYWR5IGhhcyBhIHRyYW5zZm9ybSBzZXQsIHdyYXAgaXQgaW4gYSA8c3Bhbj4gc28gPERyYWdnYWJsZT5cbiAgICAgIC8vIGhhcyBhIGNsZWFuIHNsYXRlLlxuICAgICAgc3R5bGUgPSAoMCwgX2RvbUZucy5jcmVhdGVDU1NUcmFuc2Zvcm0pKHRyYW5zZm9ybU9wdHMsIHBvc2l0aW9uT2Zmc2V0KTtcbiAgICB9XG5cbiAgICAvLyBNYXJrIHdpdGggY2xhc3Mgd2hpbGUgZHJhZ2dpbmdcbiAgICBjb25zdCBjbGFzc05hbWUgPSAoMCwgX2Nsc3guZGVmYXVsdCkoY2hpbGRyZW4ucHJvcHMuY2xhc3NOYW1lIHx8ICcnLCBkZWZhdWx0Q2xhc3NOYW1lLCB7XG4gICAgICBbZGVmYXVsdENsYXNzTmFtZURyYWdnaW5nXTogdGhpcy5zdGF0ZS5kcmFnZ2luZyxcbiAgICAgIFtkZWZhdWx0Q2xhc3NOYW1lRHJhZ2dlZF06IHRoaXMuc3RhdGUuZHJhZ2dlZFxuICAgIH0pO1xuXG4gICAgLy8gUmV1c2UgdGhlIGNoaWxkIHByb3ZpZGVkXG4gICAgLy8gVGhpcyBtYWtlcyBpdCBmbGV4aWJsZSB0byB1c2Ugd2hhdGV2ZXIgZWxlbWVudCBpcyB3YW50ZWQgKGRpdiwgdWwsIGV0YylcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoX0RyYWdnYWJsZUNvcmUuZGVmYXVsdCwgX2V4dGVuZHMoe30sIGRyYWdnYWJsZUNvcmVQcm9wcywge1xuICAgICAgb25TdGFydDogdGhpcy5vbkRyYWdTdGFydCxcbiAgICAgIG9uRHJhZzogdGhpcy5vbkRyYWcsXG4gICAgICBvblN0b3A6IHRoaXMub25EcmFnU3RvcFxuICAgIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KFJlYWN0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pLCB7XG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIC4uLmNoaWxkcmVuLnByb3BzLnN0eWxlLFxuICAgICAgICAuLi5zdHlsZVxuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybTogc3ZnVHJhbnNmb3JtXG4gICAgfSkpO1xuICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBEcmFnZ2FibGU7XG5fZGVmaW5lUHJvcGVydHkoRHJhZ2dhYmxlLCBcImRpc3BsYXlOYW1lXCIsICdEcmFnZ2FibGUnKTtcbl9kZWZpbmVQcm9wZXJ0eShEcmFnZ2FibGUsIFwicHJvcFR5cGVzXCIsIHtcbiAgLy8gQWNjZXB0cyBhbGwgcHJvcHMgPERyYWdnYWJsZUNvcmU+IGFjY2VwdHMuXG4gIC4uLl9EcmFnZ2FibGVDb3JlLmRlZmF1bHQucHJvcFR5cGVzLFxuICAvKipcbiAgICogYGF4aXNgIGRldGVybWluZXMgd2hpY2ggYXhpcyB0aGUgZHJhZ2dhYmxlIGNhbiBtb3ZlLlxuICAgKlxuICAgKiAgTm90ZSB0aGF0IGFsbCBjYWxsYmFja3Mgd2lsbCBzdGlsbCByZXR1cm4gZGF0YSBhcyBub3JtYWwuIFRoaXMgb25seVxuICAgKiAgY29udHJvbHMgZmx1c2hpbmcgdG8gdGhlIERPTS5cbiAgICpcbiAgICogJ2JvdGgnIGFsbG93cyBtb3ZlbWVudCBob3Jpem9udGFsbHkgYW5kIHZlcnRpY2FsbHkuXG4gICAqICd4JyBsaW1pdHMgbW92ZW1lbnQgdG8gaG9yaXpvbnRhbCBheGlzLlxuICAgKiAneScgbGltaXRzIG1vdmVtZW50IHRvIHZlcnRpY2FsIGF4aXMuXG4gICAqICdub25lJyBsaW1pdHMgYWxsIG1vdmVtZW50LlxuICAgKlxuICAgKiBEZWZhdWx0cyB0byAnYm90aCcuXG4gICAqL1xuICBheGlzOiBfcHJvcFR5cGVzLmRlZmF1bHQub25lT2YoWydib3RoJywgJ3gnLCAneScsICdub25lJ10pLFxuICAvKipcbiAgICogYGJvdW5kc2AgZGV0ZXJtaW5lcyB0aGUgcmFuZ2Ugb2YgbW92ZW1lbnQgYXZhaWxhYmxlIHRvIHRoZSBlbGVtZW50LlxuICAgKiBBdmFpbGFibGUgdmFsdWVzIGFyZTpcbiAgICpcbiAgICogJ3BhcmVudCcgcmVzdHJpY3RzIG1vdmVtZW50IHdpdGhpbiB0aGUgRHJhZ2dhYmxlJ3MgcGFyZW50IG5vZGUuXG4gICAqXG4gICAqIEFsdGVybmF0aXZlbHksIHBhc3MgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzLCBhbGwgb2Ygd2hpY2ggYXJlIG9wdGlvbmFsOlxuICAgKlxuICAgKiB7bGVmdDogTEVGVF9CT1VORCwgcmlnaHQ6IFJJR0hUX0JPVU5ELCBib3R0b206IEJPVFRPTV9CT1VORCwgdG9wOiBUT1BfQk9VTkR9XG4gICAqXG4gICAqIEFsbCB2YWx1ZXMgYXJlIGluIHB4LlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGBqc3hcbiAgICogICBsZXQgQXBwID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICogICAgICAgICByZXR1cm4gKFxuICAgKiAgICAgICAgICAgIDxEcmFnZ2FibGUgYm91bmRzPXt7cmlnaHQ6IDMwMCwgYm90dG9tOiAzMDB9fT5cbiAgICogICAgICAgICAgICAgIDxkaXY+Q29udGVudDwvZGl2PlxuICAgKiAgICAgICAgICAgPC9EcmFnZ2FibGU+XG4gICAqICAgICAgICAgKTtcbiAgICogICAgICAgfVxuICAgKiAgIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIGJvdW5kczogX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlcy5kZWZhdWx0LnNoYXBlKHtcbiAgICBsZWZ0OiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAgIHJpZ2h0OiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAgIHRvcDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgICBib3R0b206IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXJcbiAgfSksIF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsIF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZihbZmFsc2VdKV0pLFxuICBkZWZhdWx0Q2xhc3NOYW1lOiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLFxuICBkZWZhdWx0Q2xhc3NOYW1lRHJhZ2dpbmc6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gIGRlZmF1bHRDbGFzc05hbWVEcmFnZ2VkOiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLFxuICAvKipcbiAgICogYGRlZmF1bHRQb3NpdGlvbmAgc3BlY2lmaWVzIHRoZSB4IGFuZCB5IHRoYXQgdGhlIGRyYWdnZWQgaXRlbSBzaG91bGQgc3RhcnQgYXRcbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogYGBganN4XG4gICAqICAgICAgbGV0IEFwcCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAqICAgICAgICAgICAgICByZXR1cm4gKFxuICAgKiAgICAgICAgICAgICAgICAgIDxEcmFnZ2FibGUgZGVmYXVsdFBvc2l0aW9uPXt7eDogMjUsIHk6IDI1fX0+XG4gICAqICAgICAgICAgICAgICAgICAgICAgIDxkaXY+SSBzdGFydCB3aXRoIHRyYW5zZm9ybVg6IDI1cHggYW5kIHRyYW5zZm9ybVk6IDI1cHg7PC9kaXY+XG4gICAqICAgICAgICAgICAgICAgICAgPC9EcmFnZ2FibGU+XG4gICAqICAgICAgICAgICAgICApO1xuICAgKiAgICAgICAgICB9XG4gICAqICAgICAgfSk7XG4gICAqIGBgYFxuICAgKi9cbiAgZGVmYXVsdFBvc2l0aW9uOiBfcHJvcFR5cGVzLmRlZmF1bHQuc2hhcGUoe1xuICAgIHg6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsXG4gICAgeTogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlclxuICB9KSxcbiAgcG9zaXRpb25PZmZzZXQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5zaGFwZSh7XG4gICAgeDogX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlciwgX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZ10pLFxuICAgIHk6IF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsIF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmddKVxuICB9KSxcbiAgLyoqXG4gICAqIGBwb3NpdGlvbmAsIGlmIHByZXNlbnQsIGRlZmluZXMgdGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQuXG4gICAqXG4gICAqICBUaGlzIGlzIHNpbWlsYXIgdG8gaG93IGZvcm0gZWxlbWVudHMgaW4gUmVhY3Qgd29yayAtIGlmIG5vIGBwb3NpdGlvbmAgaXMgc3VwcGxpZWQsIHRoZSBjb21wb25lbnRcbiAgICogIGlzIHVuY29udHJvbGxlZC5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogYGBganN4XG4gICAqICAgICAgbGV0IEFwcCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAqICAgICAgICAgICAgICByZXR1cm4gKFxuICAgKiAgICAgICAgICAgICAgICAgIDxEcmFnZ2FibGUgcG9zaXRpb249e3t4OiAyNSwgeTogMjV9fT5cbiAgICogICAgICAgICAgICAgICAgICAgICAgPGRpdj5JIHN0YXJ0IHdpdGggdHJhbnNmb3JtWDogMjVweCBhbmQgdHJhbnNmb3JtWTogMjVweDs8L2Rpdj5cbiAgICogICAgICAgICAgICAgICAgICA8L0RyYWdnYWJsZT5cbiAgICogICAgICAgICAgICAgICk7XG4gICAqICAgICAgICAgIH1cbiAgICogICAgICB9KTtcbiAgICogYGBgXG4gICAqL1xuICBwb3NpdGlvbjogX3Byb3BUeXBlcy5kZWZhdWx0LnNoYXBlKHtcbiAgICB4OiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAgIHk6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXJcbiAgfSksXG4gIC8qKlxuICAgKiBUaGVzZSBwcm9wZXJ0aWVzIHNob3VsZCBiZSBkZWZpbmVkIG9uIHRoZSBjaGlsZCwgbm90IGhlcmUuXG4gICAqL1xuICBjbGFzc05hbWU6IF9zaGltcy5kb250U2V0TWUsXG4gIHN0eWxlOiBfc2hpbXMuZG9udFNldE1lLFxuICB0cmFuc2Zvcm06IF9zaGltcy5kb250U2V0TWVcbn0pO1xuX2RlZmluZVByb3BlcnR5KERyYWdnYWJsZSwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICAuLi5fRHJhZ2dhYmxlQ29yZS5kZWZhdWx0LmRlZmF1bHRQcm9wcyxcbiAgYXhpczogJ2JvdGgnLFxuICBib3VuZHM6IGZhbHNlLFxuICBkZWZhdWx0Q2xhc3NOYW1lOiAncmVhY3QtZHJhZ2dhYmxlJyxcbiAgZGVmYXVsdENsYXNzTmFtZURyYWdnaW5nOiAncmVhY3QtZHJhZ2dhYmxlLWRyYWdnaW5nJyxcbiAgZGVmYXVsdENsYXNzTmFtZURyYWdnZWQ6ICdyZWFjdC1kcmFnZ2FibGUtZHJhZ2dlZCcsXG4gIGRlZmF1bHRQb3NpdGlvbjoge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9LFxuICBzY2FsZTogMVxufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-draggable/build/cjs/Draggable.js\n"));

/***/ }),

/***/ "./node_modules/react-draggable/build/cjs/DraggableCore.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react-draggable/build/cjs/DraggableCore.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\"));\nvar _reactDom = _interopRequireDefault(__webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\"));\nvar _domFns = __webpack_require__(/*! ./utils/domFns */ \"./node_modules/react-draggable/build/cjs/utils/domFns.js\");\nvar _positionFns = __webpack_require__(/*! ./utils/positionFns */ \"./node_modules/react-draggable/build/cjs/utils/positionFns.js\");\nvar _shims = __webpack_require__(/*! ./utils/shims */ \"./node_modules/react-draggable/build/cjs/utils/shims.js\");\nvar _log = _interopRequireDefault(__webpack_require__(/*! ./utils/log */ \"./node_modules/react-draggable/build/cjs/utils/log.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*:: import type {EventHandler, MouseTouchEvent} from './utils/types';*/\n/*:: import type {Element as ReactElement} from 'react';*/\n// Simple abstraction for dragging events names.\nconst eventsFor = {\n  touch: {\n    start: 'touchstart',\n    move: 'touchmove',\n    stop: 'touchend'\n  },\n  mouse: {\n    start: 'mousedown',\n    move: 'mousemove',\n    stop: 'mouseup'\n  }\n};\n\n// Default to mouse events.\nlet dragEventFor = eventsFor.mouse;\n/*:: export type DraggableData = {\n  node: HTMLElement,\n  x: number, y: number,\n  deltaX: number, deltaY: number,\n  lastX: number, lastY: number,\n};*/\n/*:: export type DraggableEventHandler = (e: MouseEvent, data: DraggableData) => void | false;*/\n/*:: export type ControlPosition = {x: number, y: number};*/\n/*:: export type PositionOffsetControlPosition = {x: number|string, y: number|string};*/\n/*:: export type DraggableCoreDefaultProps = {\n  allowAnyClick: boolean,\n  disabled: boolean,\n  enableUserSelectHack: boolean,\n  onStart: DraggableEventHandler,\n  onDrag: DraggableEventHandler,\n  onStop: DraggableEventHandler,\n  onMouseDown: (e: MouseEvent) => void,\n  scale: number,\n};*/\n/*:: export type DraggableCoreProps = {\n  ...DraggableCoreDefaultProps,\n  cancel: string,\n  children: ReactElement<any>,\n  offsetParent: HTMLElement,\n  grid: [number, number],\n  handle: string,\n  nodeRef?: ?React.ElementRef<any>,\n};*/\n//\n// Define <DraggableCore>.\n//\n// <DraggableCore> is for advanced usage of <Draggable>. It maintains minimal internal state so it can\n// work well with libraries that require more control over the element.\n//\n\nclass DraggableCore extends React.Component /*:: <DraggableCoreProps>*/{\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"dragging\", false);\n    // Used while dragging to determine deltas.\n    _defineProperty(this, \"lastX\", NaN);\n    _defineProperty(this, \"lastY\", NaN);\n    _defineProperty(this, \"touchIdentifier\", null);\n    _defineProperty(this, \"mounted\", false);\n    _defineProperty(this, \"handleDragStart\", e => {\n      // Make it possible to attach event handlers on top of this one.\n      this.props.onMouseDown(e);\n\n      // Only accept left-clicks.\n      if (!this.props.allowAnyClick && typeof e.button === 'number' && e.button !== 0) return false;\n\n      // Get nodes. Be sure to grab relative document (could be iframed)\n      const thisNode = this.findDOMNode();\n      if (!thisNode || !thisNode.ownerDocument || !thisNode.ownerDocument.body) {\n        throw new Error('<DraggableCore> not mounted on DragStart!');\n      }\n      const {\n        ownerDocument\n      } = thisNode;\n\n      // Short circuit if handle or cancel prop was provided and selector doesn't match.\n      if (this.props.disabled || !(e.target instanceof ownerDocument.defaultView.Node) || this.props.handle && !(0, _domFns.matchesSelectorAndParentsTo)(e.target, this.props.handle, thisNode) || this.props.cancel && (0, _domFns.matchesSelectorAndParentsTo)(e.target, this.props.cancel, thisNode)) {\n        return;\n      }\n\n      // Prevent scrolling on mobile devices, like ipad/iphone.\n      // Important that this is after handle/cancel.\n      if (e.type === 'touchstart') e.preventDefault();\n\n      // Set touch identifier in component state if this is a touch event. This allows us to\n      // distinguish between individual touches on multitouch screens by identifying which\n      // touchpoint was set to this element.\n      const touchIdentifier = (0, _domFns.getTouchIdentifier)(e);\n      this.touchIdentifier = touchIdentifier;\n\n      // Get the current drag point from the event. This is used as the offset.\n      const position = (0, _positionFns.getControlPosition)(e, touchIdentifier, this);\n      if (position == null) return; // not possible but satisfies flow\n      const {\n        x,\n        y\n      } = position;\n\n      // Create an event object with all the data parents need to make a decision here.\n      const coreEvent = (0, _positionFns.createCoreData)(this, x, y);\n      (0, _log.default)('DraggableCore: handleDragStart: %j', coreEvent);\n\n      // Call event handler. If it returns explicit false, cancel.\n      (0, _log.default)('calling', this.props.onStart);\n      const shouldUpdate = this.props.onStart(e, coreEvent);\n      if (shouldUpdate === false || this.mounted === false) return;\n\n      // Add a style to the body to disable user-select. This prevents text from\n      // being selected all over the page.\n      if (this.props.enableUserSelectHack) (0, _domFns.addUserSelectStyles)(ownerDocument);\n\n      // Initiate dragging. Set the current x and y as offsets\n      // so we know how much we've moved during the drag. This allows us\n      // to drag elements around even if they have been moved, without issue.\n      this.dragging = true;\n      this.lastX = x;\n      this.lastY = y;\n\n      // Add events to the document directly so we catch when the user's mouse/touch moves outside of\n      // this element. We use different events depending on whether or not we have detected that this\n      // is a touch-capable device.\n      (0, _domFns.addEvent)(ownerDocument, dragEventFor.move, this.handleDrag);\n      (0, _domFns.addEvent)(ownerDocument, dragEventFor.stop, this.handleDragStop);\n    });\n    _defineProperty(this, \"handleDrag\", e => {\n      // Get the current drag point from the event. This is used as the offset.\n      const position = (0, _positionFns.getControlPosition)(e, this.touchIdentifier, this);\n      if (position == null) return;\n      let {\n        x,\n        y\n      } = position;\n\n      // Snap to grid if prop has been provided\n      if (Array.isArray(this.props.grid)) {\n        let deltaX = x - this.lastX,\n          deltaY = y - this.lastY;\n        [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);\n        if (!deltaX && !deltaY) return; // skip useless drag\n        x = this.lastX + deltaX, y = this.lastY + deltaY;\n      }\n      const coreEvent = (0, _positionFns.createCoreData)(this, x, y);\n      (0, _log.default)('DraggableCore: handleDrag: %j', coreEvent);\n\n      // Call event handler. If it returns explicit false, trigger end.\n      const shouldUpdate = this.props.onDrag(e, coreEvent);\n      if (shouldUpdate === false || this.mounted === false) {\n        try {\n          // $FlowIgnore\n          this.handleDragStop(new MouseEvent('mouseup'));\n        } catch (err) {\n          // Old browsers\n          const event = ((document.createEvent('MouseEvents') /*: any*/) /*: MouseTouchEvent*/);\n          // I see why this insanity was deprecated\n          // $FlowIgnore\n          event.initMouseEvent('mouseup', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n          this.handleDragStop(event);\n        }\n        return;\n      }\n      this.lastX = x;\n      this.lastY = y;\n    });\n    _defineProperty(this, \"handleDragStop\", e => {\n      if (!this.dragging) return;\n      const position = (0, _positionFns.getControlPosition)(e, this.touchIdentifier, this);\n      if (position == null) return;\n      let {\n        x,\n        y\n      } = position;\n\n      // Snap to grid if prop has been provided\n      if (Array.isArray(this.props.grid)) {\n        let deltaX = x - this.lastX || 0;\n        let deltaY = y - this.lastY || 0;\n        [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);\n        x = this.lastX + deltaX, y = this.lastY + deltaY;\n      }\n      const coreEvent = (0, _positionFns.createCoreData)(this, x, y);\n\n      // Call event handler\n      const shouldContinue = this.props.onStop(e, coreEvent);\n      if (shouldContinue === false || this.mounted === false) return false;\n      const thisNode = this.findDOMNode();\n      if (thisNode) {\n        // Remove user-select hack\n        if (this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(thisNode.ownerDocument);\n      }\n      (0, _log.default)('DraggableCore: handleDragStop: %j', coreEvent);\n\n      // Reset the el.\n      this.dragging = false;\n      this.lastX = NaN;\n      this.lastY = NaN;\n      if (thisNode) {\n        // Remove event handlers\n        (0, _log.default)('DraggableCore: Removing handlers');\n        (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.move, this.handleDrag);\n        (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.stop, this.handleDragStop);\n      }\n    });\n    _defineProperty(this, \"onMouseDown\", e => {\n      dragEventFor = eventsFor.mouse; // on touchscreen laptops we could switch back to mouse\n\n      return this.handleDragStart(e);\n    });\n    _defineProperty(this, \"onMouseUp\", e => {\n      dragEventFor = eventsFor.mouse;\n      return this.handleDragStop(e);\n    });\n    // Same as onMouseDown (start drag), but now consider this a touch device.\n    _defineProperty(this, \"onTouchStart\", e => {\n      // We're on a touch device now, so change the event handlers\n      dragEventFor = eventsFor.touch;\n      return this.handleDragStart(e);\n    });\n    _defineProperty(this, \"onTouchEnd\", e => {\n      // We're on a touch device now, so change the event handlers\n      dragEventFor = eventsFor.touch;\n      return this.handleDragStop(e);\n    });\n  }\n  componentDidMount() {\n    this.mounted = true;\n    // Touch handlers must be added with {passive: false} to be cancelable.\n    // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n    const thisNode = this.findDOMNode();\n    if (thisNode) {\n      (0, _domFns.addEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {\n        passive: false\n      });\n    }\n  }\n  componentWillUnmount() {\n    this.mounted = false;\n    // Remove any leftover event handlers. Remove both touch and mouse handlers in case\n    // some browser quirk caused a touch event to fire during a mouse move, or vice versa.\n    const thisNode = this.findDOMNode();\n    if (thisNode) {\n      const {\n        ownerDocument\n      } = thisNode;\n      (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.move, this.handleDrag);\n      (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.move, this.handleDrag);\n      (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);\n      (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.stop, this.handleDragStop);\n      (0, _domFns.removeEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {\n        passive: false\n      });\n      if (this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(ownerDocument);\n    }\n  }\n\n  // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find\n  // the underlying DOM node ourselves. See the README for more information.\n  findDOMNode() /*: ?HTMLElement*/{\n    var _this$props, _this$props2;\n    return (_this$props = this.props) !== null && _this$props !== void 0 && _this$props.nodeRef ? (_this$props2 = this.props) === null || _this$props2 === void 0 || (_this$props2 = _this$props2.nodeRef) === null || _this$props2 === void 0 ? void 0 : _this$props2.current : _reactDom.default.findDOMNode(this);\n  }\n  render() /*: React.Element<any>*/{\n    // Reuse the child provided\n    // This makes it flexible to use whatever element is wanted (div, ul, etc)\n    return /*#__PURE__*/React.cloneElement(React.Children.only(this.props.children), {\n      // Note: mouseMove handler is attached to document so it will still function\n      // when the user drags quickly and leaves the bounds of the element.\n      onMouseDown: this.onMouseDown,\n      onMouseUp: this.onMouseUp,\n      // onTouchStart is added on `componentDidMount` so they can be added with\n      // {passive: false}, which allows it to cancel. See\n      // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n      onTouchEnd: this.onTouchEnd\n    });\n  }\n}\nexports[\"default\"] = DraggableCore;\n_defineProperty(DraggableCore, \"displayName\", 'DraggableCore');\n_defineProperty(DraggableCore, \"propTypes\", {\n  /**\n   * `allowAnyClick` allows dragging using any mouse button.\n   * By default, we only accept the left button.\n   *\n   * Defaults to `false`.\n   */\n  allowAnyClick: _propTypes.default.bool,\n  children: _propTypes.default.node.isRequired,\n  /**\n   * `disabled`, if true, stops the <Draggable> from dragging. All handlers,\n   * with the exception of `onMouseDown`, will not fire.\n   */\n  disabled: _propTypes.default.bool,\n  /**\n   * By default, we add 'user-select:none' attributes to the document body\n   * to prevent ugly text selection during drag. If this is causing problems\n   * for your app, set this to `false`.\n   */\n  enableUserSelectHack: _propTypes.default.bool,\n  /**\n   * `offsetParent`, if set, uses the passed DOM node to compute drag offsets\n   * instead of using the parent node.\n   */\n  offsetParent: function (props /*: DraggableCoreProps*/, propName /*: $Keys<DraggableCoreProps>*/) {\n    if (props[propName] && props[propName].nodeType !== 1) {\n      throw new Error('Draggable\\'s offsetParent must be a DOM Node.');\n    }\n  },\n  /**\n   * `grid` specifies the x and y that dragging should snap to.\n   */\n  grid: _propTypes.default.arrayOf(_propTypes.default.number),\n  /**\n   * `handle` specifies a selector to be used as the handle that initiates drag.\n   *\n   * Example:\n   *\n   * ```jsx\n   *   let App = React.createClass({\n   *       render: function () {\n   *         return (\n   *            <Draggable handle=\".handle\">\n   *              <div>\n   *                  <div className=\"handle\">Click me to drag</div>\n   *                  <div>This is some other content</div>\n   *              </div>\n   *           </Draggable>\n   *         );\n   *       }\n   *   });\n   * ```\n   */\n  handle: _propTypes.default.string,\n  /**\n   * `cancel` specifies a selector to be used to prevent drag initialization.\n   *\n   * Example:\n   *\n   * ```jsx\n   *   let App = React.createClass({\n   *       render: function () {\n   *           return(\n   *               <Draggable cancel=\".cancel\">\n   *                   <div>\n   *                     <div className=\"cancel\">You can't drag from here</div>\n   *                     <div>Dragging here works fine</div>\n   *                   </div>\n   *               </Draggable>\n   *           );\n   *       }\n   *   });\n   * ```\n   */\n  cancel: _propTypes.default.string,\n  /* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.\n   * Unfortunately, in order for <Draggable> to work properly, we need raw access\n   * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`\n   * as in this example:\n   *\n   * function MyComponent() {\n   *   const nodeRef = React.useRef(null);\n   *   return (\n   *     <Draggable nodeRef={nodeRef}>\n   *       <div ref={nodeRef}>Example Target</div>\n   *     </Draggable>\n   *   );\n   * }\n   *\n   * This can be used for arbitrarily nested components, so long as the ref ends up\n   * pointing to the actual child DOM node and not a custom component.\n   */\n  nodeRef: _propTypes.default.object,\n  /**\n   * Called when dragging starts.\n   * If this function returns the boolean false, dragging will be canceled.\n   */\n  onStart: _propTypes.default.func,\n  /**\n   * Called while dragging.\n   * If this function returns the boolean false, dragging will be canceled.\n   */\n  onDrag: _propTypes.default.func,\n  /**\n   * Called when dragging stops.\n   * If this function returns the boolean false, the drag will remain active.\n   */\n  onStop: _propTypes.default.func,\n  /**\n   * A workaround option which can be passed if onMouseDown needs to be accessed,\n   * since it'll always be blocked (as there is internal use of onMouseDown)\n   */\n  onMouseDown: _propTypes.default.func,\n  /**\n   * `scale`, if set, applies scaling while dragging an element\n   */\n  scale: _propTypes.default.number,\n  /**\n   * These properties should be defined on the child, not here.\n   */\n  className: _shims.dontSetMe,\n  style: _shims.dontSetMe,\n  transform: _shims.dontSetMe\n});\n_defineProperty(DraggableCore, \"defaultProps\", {\n  allowAnyClick: false,\n  // by default only accept left click\n  disabled: false,\n  enableUserSelectHack: true,\n  onStart: function () {},\n  onDrag: function () {},\n  onStop: function () {},\n  onMouseDown: function () {},\n  scale: 1\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy9EcmFnZ2FibGVDb3JlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2Ysb0NBQW9DLG1CQUFPLENBQUMsNENBQU87QUFDbkQsd0NBQXdDLG1CQUFPLENBQUMsc0RBQVk7QUFDNUQsdUNBQXVDLG1CQUFPLENBQUMsb0RBQVc7QUFDMUQsY0FBYyxtQkFBTyxDQUFDLGdGQUFnQjtBQUN0QyxtQkFBbUIsbUJBQU8sQ0FBQywwRkFBcUI7QUFDaEQsYUFBYSxtQkFBTyxDQUFDLDhFQUFlO0FBQ3BDLGtDQUFrQyxtQkFBTyxDQUFDLDBFQUFhO0FBQ3ZELHVDQUF1Qyx1Q0FBdUM7QUFDOUUsaURBQWlELGdEQUFnRCx1Q0FBdUMsc0NBQXNDLDREQUE0RCw0REFBNEQ7QUFDdFMscURBQXFELDZDQUE2QyxjQUFjLDRFQUE0RSxTQUFTLGtCQUFrQixtREFBbUQsK0JBQStCLHlCQUF5QixpQkFBaUIsc0ZBQXNGLHVCQUF1QiwyRUFBMkUscUZBQXFGLHNDQUFzQyw0Q0FBNEMsT0FBTyw4QkFBOEIsc0JBQXNCLGFBQWEsMEJBQTBCO0FBQ3B4Qiw0Q0FBNEMsMkJBQTJCLGtCQUFrQixrQ0FBa0Msb0VBQW9FLEtBQUssT0FBTyxvQkFBb0I7QUFDL04sK0JBQStCLHVDQUF1QztBQUN0RSxxQ0FBcUMsK0RBQStELHNDQUFzQywwQkFBMEIsK0NBQStDLHlDQUF5Qyx1RUFBdUU7QUFDblUsa0JBQWtCLCtCQUErQixxQkFBcUI7QUFDdEUsa0JBQWtCLHlCQUF5QixhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsOEZBQThGO0FBQzlGLG9DQUFvQyxzQkFBc0I7QUFDMUQsa0RBQWtELG9DQUFvQztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGdCQUFnQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckMscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsNkJBQTZCO0FBQzdCO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy9EcmFnZ2FibGVDb3JlLmpzP2VkZTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgUmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9wcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcbnZhciBfcmVhY3REb20gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdC1kb21cIikpO1xudmFyIF9kb21GbnMgPSByZXF1aXJlKFwiLi91dGlscy9kb21GbnNcIik7XG52YXIgX3Bvc2l0aW9uRm5zID0gcmVxdWlyZShcIi4vdXRpbHMvcG9zaXRpb25GbnNcIik7XG52YXIgX3NoaW1zID0gcmVxdWlyZShcIi4vdXRpbHMvc2hpbXNcIik7XG52YXIgX2xvZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbHMvbG9nXCIpKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpOyB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gKG5vZGVJbnRlcm9wKSB7IHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDsgfSkobm9kZUludGVyb3ApOyB9XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7IGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHsgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbi8qOjogaW1wb3J0IHR5cGUge0V2ZW50SGFuZGxlciwgTW91c2VUb3VjaEV2ZW50fSBmcm9tICcuL3V0aWxzL3R5cGVzJzsqL1xuLyo6OiBpbXBvcnQgdHlwZSB7RWxlbWVudCBhcyBSZWFjdEVsZW1lbnR9IGZyb20gJ3JlYWN0JzsqL1xuLy8gU2ltcGxlIGFic3RyYWN0aW9uIGZvciBkcmFnZ2luZyBldmVudHMgbmFtZXMuXG5jb25zdCBldmVudHNGb3IgPSB7XG4gIHRvdWNoOiB7XG4gICAgc3RhcnQ6ICd0b3VjaHN0YXJ0JyxcbiAgICBtb3ZlOiAndG91Y2htb3ZlJyxcbiAgICBzdG9wOiAndG91Y2hlbmQnXG4gIH0sXG4gIG1vdXNlOiB7XG4gICAgc3RhcnQ6ICdtb3VzZWRvd24nLFxuICAgIG1vdmU6ICdtb3VzZW1vdmUnLFxuICAgIHN0b3A6ICdtb3VzZXVwJ1xuICB9XG59O1xuXG4vLyBEZWZhdWx0IHRvIG1vdXNlIGV2ZW50cy5cbmxldCBkcmFnRXZlbnRGb3IgPSBldmVudHNGb3IubW91c2U7XG4vKjo6IGV4cG9ydCB0eXBlIERyYWdnYWJsZURhdGEgPSB7XG4gIG5vZGU6IEhUTUxFbGVtZW50LFxuICB4OiBudW1iZXIsIHk6IG51bWJlcixcbiAgZGVsdGFYOiBudW1iZXIsIGRlbHRhWTogbnVtYmVyLFxuICBsYXN0WDogbnVtYmVyLCBsYXN0WTogbnVtYmVyLFxufTsqL1xuLyo6OiBleHBvcnQgdHlwZSBEcmFnZ2FibGVFdmVudEhhbmRsZXIgPSAoZTogTW91c2VFdmVudCwgZGF0YTogRHJhZ2dhYmxlRGF0YSkgPT4gdm9pZCB8IGZhbHNlOyovXG4vKjo6IGV4cG9ydCB0eXBlIENvbnRyb2xQb3NpdGlvbiA9IHt4OiBudW1iZXIsIHk6IG51bWJlcn07Ki9cbi8qOjogZXhwb3J0IHR5cGUgUG9zaXRpb25PZmZzZXRDb250cm9sUG9zaXRpb24gPSB7eDogbnVtYmVyfHN0cmluZywgeTogbnVtYmVyfHN0cmluZ307Ki9cbi8qOjogZXhwb3J0IHR5cGUgRHJhZ2dhYmxlQ29yZURlZmF1bHRQcm9wcyA9IHtcbiAgYWxsb3dBbnlDbGljazogYm9vbGVhbixcbiAgZGlzYWJsZWQ6IGJvb2xlYW4sXG4gIGVuYWJsZVVzZXJTZWxlY3RIYWNrOiBib29sZWFuLFxuICBvblN0YXJ0OiBEcmFnZ2FibGVFdmVudEhhbmRsZXIsXG4gIG9uRHJhZzogRHJhZ2dhYmxlRXZlbnRIYW5kbGVyLFxuICBvblN0b3A6IERyYWdnYWJsZUV2ZW50SGFuZGxlcixcbiAgb25Nb3VzZURvd246IChlOiBNb3VzZUV2ZW50KSA9PiB2b2lkLFxuICBzY2FsZTogbnVtYmVyLFxufTsqL1xuLyo6OiBleHBvcnQgdHlwZSBEcmFnZ2FibGVDb3JlUHJvcHMgPSB7XG4gIC4uLkRyYWdnYWJsZUNvcmVEZWZhdWx0UHJvcHMsXG4gIGNhbmNlbDogc3RyaW5nLFxuICBjaGlsZHJlbjogUmVhY3RFbGVtZW50PGFueT4sXG4gIG9mZnNldFBhcmVudDogSFRNTEVsZW1lbnQsXG4gIGdyaWQ6IFtudW1iZXIsIG51bWJlcl0sXG4gIGhhbmRsZTogc3RyaW5nLFxuICBub2RlUmVmPzogP1JlYWN0LkVsZW1lbnRSZWY8YW55Pixcbn07Ki9cbi8vXG4vLyBEZWZpbmUgPERyYWdnYWJsZUNvcmU+LlxuLy9cbi8vIDxEcmFnZ2FibGVDb3JlPiBpcyBmb3IgYWR2YW5jZWQgdXNhZ2Ugb2YgPERyYWdnYWJsZT4uIEl0IG1haW50YWlucyBtaW5pbWFsIGludGVybmFsIHN0YXRlIHNvIGl0IGNhblxuLy8gd29yayB3ZWxsIHdpdGggbGlicmFyaWVzIHRoYXQgcmVxdWlyZSBtb3JlIGNvbnRyb2wgb3ZlciB0aGUgZWxlbWVudC5cbi8vXG5cbmNsYXNzIERyYWdnYWJsZUNvcmUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQgLyo6OiA8RHJhZ2dhYmxlQ29yZVByb3BzPiove1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRyYWdnaW5nXCIsIGZhbHNlKTtcbiAgICAvLyBVc2VkIHdoaWxlIGRyYWdnaW5nIHRvIGRldGVybWluZSBkZWx0YXMuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibGFzdFhcIiwgTmFOKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJsYXN0WVwiLCBOYU4pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvdWNoSWRlbnRpZmllclwiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJtb3VudGVkXCIsIGZhbHNlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYW5kbGVEcmFnU3RhcnRcIiwgZSA9PiB7XG4gICAgICAvLyBNYWtlIGl0IHBvc3NpYmxlIHRvIGF0dGFjaCBldmVudCBoYW5kbGVycyBvbiB0b3Agb2YgdGhpcyBvbmUuXG4gICAgICB0aGlzLnByb3BzLm9uTW91c2VEb3duKGUpO1xuXG4gICAgICAvLyBPbmx5IGFjY2VwdCBsZWZ0LWNsaWNrcy5cbiAgICAgIGlmICghdGhpcy5wcm9wcy5hbGxvd0FueUNsaWNrICYmIHR5cGVvZiBlLmJ1dHRvbiA9PT0gJ251bWJlcicgJiYgZS5idXR0b24gIT09IDApIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gR2V0IG5vZGVzLiBCZSBzdXJlIHRvIGdyYWIgcmVsYXRpdmUgZG9jdW1lbnQgKGNvdWxkIGJlIGlmcmFtZWQpXG4gICAgICBjb25zdCB0aGlzTm9kZSA9IHRoaXMuZmluZERPTU5vZGUoKTtcbiAgICAgIGlmICghdGhpc05vZGUgfHwgIXRoaXNOb2RlLm93bmVyRG9jdW1lbnQgfHwgIXRoaXNOb2RlLm93bmVyRG9jdW1lbnQuYm9keSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJzxEcmFnZ2FibGVDb3JlPiBub3QgbW91bnRlZCBvbiBEcmFnU3RhcnQhJyk7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIG93bmVyRG9jdW1lbnRcbiAgICAgIH0gPSB0aGlzTm9kZTtcblxuICAgICAgLy8gU2hvcnQgY2lyY3VpdCBpZiBoYW5kbGUgb3IgY2FuY2VsIHByb3Agd2FzIHByb3ZpZGVkIGFuZCBzZWxlY3RvciBkb2Vzbid0IG1hdGNoLlxuICAgICAgaWYgKHRoaXMucHJvcHMuZGlzYWJsZWQgfHwgIShlLnRhcmdldCBpbnN0YW5jZW9mIG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuTm9kZSkgfHwgdGhpcy5wcm9wcy5oYW5kbGUgJiYgISgwLCBfZG9tRm5zLm1hdGNoZXNTZWxlY3RvckFuZFBhcmVudHNUbykoZS50YXJnZXQsIHRoaXMucHJvcHMuaGFuZGxlLCB0aGlzTm9kZSkgfHwgdGhpcy5wcm9wcy5jYW5jZWwgJiYgKDAsIF9kb21GbnMubWF0Y2hlc1NlbGVjdG9yQW5kUGFyZW50c1RvKShlLnRhcmdldCwgdGhpcy5wcm9wcy5jYW5jZWwsIHRoaXNOb2RlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXZlbnQgc2Nyb2xsaW5nIG9uIG1vYmlsZSBkZXZpY2VzLCBsaWtlIGlwYWQvaXBob25lLlxuICAgICAgLy8gSW1wb3J0YW50IHRoYXQgdGhpcyBpcyBhZnRlciBoYW5kbGUvY2FuY2VsLlxuICAgICAgaWYgKGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIC8vIFNldCB0b3VjaCBpZGVudGlmaWVyIGluIGNvbXBvbmVudCBzdGF0ZSBpZiB0aGlzIGlzIGEgdG91Y2ggZXZlbnQuIFRoaXMgYWxsb3dzIHVzIHRvXG4gICAgICAvLyBkaXN0aW5ndWlzaCBiZXR3ZWVuIGluZGl2aWR1YWwgdG91Y2hlcyBvbiBtdWx0aXRvdWNoIHNjcmVlbnMgYnkgaWRlbnRpZnlpbmcgd2hpY2hcbiAgICAgIC8vIHRvdWNocG9pbnQgd2FzIHNldCB0byB0aGlzIGVsZW1lbnQuXG4gICAgICBjb25zdCB0b3VjaElkZW50aWZpZXIgPSAoMCwgX2RvbUZucy5nZXRUb3VjaElkZW50aWZpZXIpKGUpO1xuICAgICAgdGhpcy50b3VjaElkZW50aWZpZXIgPSB0b3VjaElkZW50aWZpZXI7XG5cbiAgICAgIC8vIEdldCB0aGUgY3VycmVudCBkcmFnIHBvaW50IGZyb20gdGhlIGV2ZW50LiBUaGlzIGlzIHVzZWQgYXMgdGhlIG9mZnNldC5cbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gKDAsIF9wb3NpdGlvbkZucy5nZXRDb250cm9sUG9zaXRpb24pKGUsIHRvdWNoSWRlbnRpZmllciwgdGhpcyk7XG4gICAgICBpZiAocG9zaXRpb24gPT0gbnVsbCkgcmV0dXJuOyAvLyBub3QgcG9zc2libGUgYnV0IHNhdGlzZmllcyBmbG93XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSBwb3NpdGlvbjtcblxuICAgICAgLy8gQ3JlYXRlIGFuIGV2ZW50IG9iamVjdCB3aXRoIGFsbCB0aGUgZGF0YSBwYXJlbnRzIG5lZWQgdG8gbWFrZSBhIGRlY2lzaW9uIGhlcmUuXG4gICAgICBjb25zdCBjb3JlRXZlbnQgPSAoMCwgX3Bvc2l0aW9uRm5zLmNyZWF0ZUNvcmVEYXRhKSh0aGlzLCB4LCB5KTtcbiAgICAgICgwLCBfbG9nLmRlZmF1bHQpKCdEcmFnZ2FibGVDb3JlOiBoYW5kbGVEcmFnU3RhcnQ6ICVqJywgY29yZUV2ZW50KTtcblxuICAgICAgLy8gQ2FsbCBldmVudCBoYW5kbGVyLiBJZiBpdCByZXR1cm5zIGV4cGxpY2l0IGZhbHNlLCBjYW5jZWwuXG4gICAgICAoMCwgX2xvZy5kZWZhdWx0KSgnY2FsbGluZycsIHRoaXMucHJvcHMub25TdGFydCk7XG4gICAgICBjb25zdCBzaG91bGRVcGRhdGUgPSB0aGlzLnByb3BzLm9uU3RhcnQoZSwgY29yZUV2ZW50KTtcbiAgICAgIGlmIChzaG91bGRVcGRhdGUgPT09IGZhbHNlIHx8IHRoaXMubW91bnRlZCA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgLy8gQWRkIGEgc3R5bGUgdG8gdGhlIGJvZHkgdG8gZGlzYWJsZSB1c2VyLXNlbGVjdC4gVGhpcyBwcmV2ZW50cyB0ZXh0IGZyb21cbiAgICAgIC8vIGJlaW5nIHNlbGVjdGVkIGFsbCBvdmVyIHRoZSBwYWdlLlxuICAgICAgaWYgKHRoaXMucHJvcHMuZW5hYmxlVXNlclNlbGVjdEhhY2spICgwLCBfZG9tRm5zLmFkZFVzZXJTZWxlY3RTdHlsZXMpKG93bmVyRG9jdW1lbnQpO1xuXG4gICAgICAvLyBJbml0aWF0ZSBkcmFnZ2luZy4gU2V0IHRoZSBjdXJyZW50IHggYW5kIHkgYXMgb2Zmc2V0c1xuICAgICAgLy8gc28gd2Uga25vdyBob3cgbXVjaCB3ZSd2ZSBtb3ZlZCBkdXJpbmcgdGhlIGRyYWcuIFRoaXMgYWxsb3dzIHVzXG4gICAgICAvLyB0byBkcmFnIGVsZW1lbnRzIGFyb3VuZCBldmVuIGlmIHRoZXkgaGF2ZSBiZWVuIG1vdmVkLCB3aXRob3V0IGlzc3VlLlxuICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICB0aGlzLmxhc3RYID0geDtcbiAgICAgIHRoaXMubGFzdFkgPSB5O1xuXG4gICAgICAvLyBBZGQgZXZlbnRzIHRvIHRoZSBkb2N1bWVudCBkaXJlY3RseSBzbyB3ZSBjYXRjaCB3aGVuIHRoZSB1c2VyJ3MgbW91c2UvdG91Y2ggbW92ZXMgb3V0c2lkZSBvZlxuICAgICAgLy8gdGhpcyBlbGVtZW50LiBXZSB1c2UgZGlmZmVyZW50IGV2ZW50cyBkZXBlbmRpbmcgb24gd2hldGhlciBvciBub3Qgd2UgaGF2ZSBkZXRlY3RlZCB0aGF0IHRoaXNcbiAgICAgIC8vIGlzIGEgdG91Y2gtY2FwYWJsZSBkZXZpY2UuXG4gICAgICAoMCwgX2RvbUZucy5hZGRFdmVudCkob3duZXJEb2N1bWVudCwgZHJhZ0V2ZW50Rm9yLm1vdmUsIHRoaXMuaGFuZGxlRHJhZyk7XG4gICAgICAoMCwgX2RvbUZucy5hZGRFdmVudCkob3duZXJEb2N1bWVudCwgZHJhZ0V2ZW50Rm9yLnN0b3AsIHRoaXMuaGFuZGxlRHJhZ1N0b3ApO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZURyYWdcIiwgZSA9PiB7XG4gICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgZHJhZyBwb2ludCBmcm9tIHRoZSBldmVudC4gVGhpcyBpcyB1c2VkIGFzIHRoZSBvZmZzZXQuXG4gICAgICBjb25zdCBwb3NpdGlvbiA9ICgwLCBfcG9zaXRpb25GbnMuZ2V0Q29udHJvbFBvc2l0aW9uKShlLCB0aGlzLnRvdWNoSWRlbnRpZmllciwgdGhpcyk7XG4gICAgICBpZiAocG9zaXRpb24gPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgbGV0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IHBvc2l0aW9uO1xuXG4gICAgICAvLyBTbmFwIHRvIGdyaWQgaWYgcHJvcCBoYXMgYmVlbiBwcm92aWRlZFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5wcm9wcy5ncmlkKSkge1xuICAgICAgICBsZXQgZGVsdGFYID0geCAtIHRoaXMubGFzdFgsXG4gICAgICAgICAgZGVsdGFZID0geSAtIHRoaXMubGFzdFk7XG4gICAgICAgIFtkZWx0YVgsIGRlbHRhWV0gPSAoMCwgX3Bvc2l0aW9uRm5zLnNuYXBUb0dyaWQpKHRoaXMucHJvcHMuZ3JpZCwgZGVsdGFYLCBkZWx0YVkpO1xuICAgICAgICBpZiAoIWRlbHRhWCAmJiAhZGVsdGFZKSByZXR1cm47IC8vIHNraXAgdXNlbGVzcyBkcmFnXG4gICAgICAgIHggPSB0aGlzLmxhc3RYICsgZGVsdGFYLCB5ID0gdGhpcy5sYXN0WSArIGRlbHRhWTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvcmVFdmVudCA9ICgwLCBfcG9zaXRpb25GbnMuY3JlYXRlQ29yZURhdGEpKHRoaXMsIHgsIHkpO1xuICAgICAgKDAsIF9sb2cuZGVmYXVsdCkoJ0RyYWdnYWJsZUNvcmU6IGhhbmRsZURyYWc6ICVqJywgY29yZUV2ZW50KTtcblxuICAgICAgLy8gQ2FsbCBldmVudCBoYW5kbGVyLiBJZiBpdCByZXR1cm5zIGV4cGxpY2l0IGZhbHNlLCB0cmlnZ2VyIGVuZC5cbiAgICAgIGNvbnN0IHNob3VsZFVwZGF0ZSA9IHRoaXMucHJvcHMub25EcmFnKGUsIGNvcmVFdmVudCk7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlID09PSBmYWxzZSB8fCB0aGlzLm1vdW50ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gJEZsb3dJZ25vcmVcbiAgICAgICAgICB0aGlzLmhhbmRsZURyYWdTdG9wKG5ldyBNb3VzZUV2ZW50KCdtb3VzZXVwJykpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAvLyBPbGQgYnJvd3NlcnNcbiAgICAgICAgICBjb25zdCBldmVudCA9ICgoZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnRzJykgLyo6IGFueSovKSAvKjogTW91c2VUb3VjaEV2ZW50Ki8pO1xuICAgICAgICAgIC8vIEkgc2VlIHdoeSB0aGlzIGluc2FuaXR5IHdhcyBkZXByZWNhdGVkXG4gICAgICAgICAgLy8gJEZsb3dJZ25vcmVcbiAgICAgICAgICBldmVudC5pbml0TW91c2VFdmVudCgnbW91c2V1cCcsIHRydWUsIHRydWUsIHdpbmRvdywgMCwgMCwgMCwgMCwgMCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuICAgICAgICAgIHRoaXMuaGFuZGxlRHJhZ1N0b3AoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdFggPSB4O1xuICAgICAgdGhpcy5sYXN0WSA9IHk7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlRHJhZ1N0b3BcIiwgZSA9PiB7XG4gICAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHJldHVybjtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gKDAsIF9wb3NpdGlvbkZucy5nZXRDb250cm9sUG9zaXRpb24pKGUsIHRoaXMudG91Y2hJZGVudGlmaWVyLCB0aGlzKTtcbiAgICAgIGlmIChwb3NpdGlvbiA9PSBudWxsKSByZXR1cm47XG4gICAgICBsZXQge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gcG9zaXRpb247XG5cbiAgICAgIC8vIFNuYXAgdG8gZ3JpZCBpZiBwcm9wIGhhcyBiZWVuIHByb3ZpZGVkXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnByb3BzLmdyaWQpKSB7XG4gICAgICAgIGxldCBkZWx0YVggPSB4IC0gdGhpcy5sYXN0WCB8fCAwO1xuICAgICAgICBsZXQgZGVsdGFZID0geSAtIHRoaXMubGFzdFkgfHwgMDtcbiAgICAgICAgW2RlbHRhWCwgZGVsdGFZXSA9ICgwLCBfcG9zaXRpb25GbnMuc25hcFRvR3JpZCkodGhpcy5wcm9wcy5ncmlkLCBkZWx0YVgsIGRlbHRhWSk7XG4gICAgICAgIHggPSB0aGlzLmxhc3RYICsgZGVsdGFYLCB5ID0gdGhpcy5sYXN0WSArIGRlbHRhWTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvcmVFdmVudCA9ICgwLCBfcG9zaXRpb25GbnMuY3JlYXRlQ29yZURhdGEpKHRoaXMsIHgsIHkpO1xuXG4gICAgICAvLyBDYWxsIGV2ZW50IGhhbmRsZXJcbiAgICAgIGNvbnN0IHNob3VsZENvbnRpbnVlID0gdGhpcy5wcm9wcy5vblN0b3AoZSwgY29yZUV2ZW50KTtcbiAgICAgIGlmIChzaG91bGRDb250aW51ZSA9PT0gZmFsc2UgfHwgdGhpcy5tb3VudGVkID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgY29uc3QgdGhpc05vZGUgPSB0aGlzLmZpbmRET01Ob2RlKCk7XG4gICAgICBpZiAodGhpc05vZGUpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHVzZXItc2VsZWN0IGhhY2tcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZW5hYmxlVXNlclNlbGVjdEhhY2spICgwLCBfZG9tRm5zLnJlbW92ZVVzZXJTZWxlY3RTdHlsZXMpKHRoaXNOb2RlLm93bmVyRG9jdW1lbnQpO1xuICAgICAgfVxuICAgICAgKDAsIF9sb2cuZGVmYXVsdCkoJ0RyYWdnYWJsZUNvcmU6IGhhbmRsZURyYWdTdG9wOiAlaicsIGNvcmVFdmVudCk7XG5cbiAgICAgIC8vIFJlc2V0IHRoZSBlbC5cbiAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMubGFzdFggPSBOYU47XG4gICAgICB0aGlzLmxhc3RZID0gTmFOO1xuICAgICAgaWYgKHRoaXNOb2RlKSB7XG4gICAgICAgIC8vIFJlbW92ZSBldmVudCBoYW5kbGVyc1xuICAgICAgICAoMCwgX2xvZy5kZWZhdWx0KSgnRHJhZ2dhYmxlQ29yZTogUmVtb3ZpbmcgaGFuZGxlcnMnKTtcbiAgICAgICAgKDAsIF9kb21GbnMucmVtb3ZlRXZlbnQpKHRoaXNOb2RlLm93bmVyRG9jdW1lbnQsIGRyYWdFdmVudEZvci5tb3ZlLCB0aGlzLmhhbmRsZURyYWcpO1xuICAgICAgICAoMCwgX2RvbUZucy5yZW1vdmVFdmVudCkodGhpc05vZGUub3duZXJEb2N1bWVudCwgZHJhZ0V2ZW50Rm9yLnN0b3AsIHRoaXMuaGFuZGxlRHJhZ1N0b3ApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uTW91c2VEb3duXCIsIGUgPT4ge1xuICAgICAgZHJhZ0V2ZW50Rm9yID0gZXZlbnRzRm9yLm1vdXNlOyAvLyBvbiB0b3VjaHNjcmVlbiBsYXB0b3BzIHdlIGNvdWxkIHN3aXRjaCBiYWNrIHRvIG1vdXNlXG5cbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZURyYWdTdGFydChlKTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbk1vdXNlVXBcIiwgZSA9PiB7XG4gICAgICBkcmFnRXZlbnRGb3IgPSBldmVudHNGb3IubW91c2U7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVEcmFnU3RvcChlKTtcbiAgICB9KTtcbiAgICAvLyBTYW1lIGFzIG9uTW91c2VEb3duIChzdGFydCBkcmFnKSwgYnV0IG5vdyBjb25zaWRlciB0aGlzIGEgdG91Y2ggZGV2aWNlLlxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uVG91Y2hTdGFydFwiLCBlID0+IHtcbiAgICAgIC8vIFdlJ3JlIG9uIGEgdG91Y2ggZGV2aWNlIG5vdywgc28gY2hhbmdlIHRoZSBldmVudCBoYW5kbGVyc1xuICAgICAgZHJhZ0V2ZW50Rm9yID0gZXZlbnRzRm9yLnRvdWNoO1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0KGUpO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uVG91Y2hFbmRcIiwgZSA9PiB7XG4gICAgICAvLyBXZSdyZSBvbiBhIHRvdWNoIGRldmljZSBub3csIHNvIGNoYW5nZSB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICAgIGRyYWdFdmVudEZvciA9IGV2ZW50c0Zvci50b3VjaDtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZURyYWdTdG9wKGUpO1xuICAgIH0pO1xuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMubW91bnRlZCA9IHRydWU7XG4gICAgLy8gVG91Y2ggaGFuZGxlcnMgbXVzdCBiZSBhZGRlZCB3aXRoIHtwYXNzaXZlOiBmYWxzZX0gdG8gYmUgY2FuY2VsYWJsZS5cbiAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdXBkYXRlcy8yMDE3LzAxL3Njcm9sbGluZy1pbnRlcnZlbnRpb25cbiAgICBjb25zdCB0aGlzTm9kZSA9IHRoaXMuZmluZERPTU5vZGUoKTtcbiAgICBpZiAodGhpc05vZGUpIHtcbiAgICAgICgwLCBfZG9tRm5zLmFkZEV2ZW50KSh0aGlzTm9kZSwgZXZlbnRzRm9yLnRvdWNoLnN0YXJ0LCB0aGlzLm9uVG91Y2hTdGFydCwge1xuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMubW91bnRlZCA9IGZhbHNlO1xuICAgIC8vIFJlbW92ZSBhbnkgbGVmdG92ZXIgZXZlbnQgaGFuZGxlcnMuIFJlbW92ZSBib3RoIHRvdWNoIGFuZCBtb3VzZSBoYW5kbGVycyBpbiBjYXNlXG4gICAgLy8gc29tZSBicm93c2VyIHF1aXJrIGNhdXNlZCBhIHRvdWNoIGV2ZW50IHRvIGZpcmUgZHVyaW5nIGEgbW91c2UgbW92ZSwgb3IgdmljZSB2ZXJzYS5cbiAgICBjb25zdCB0aGlzTm9kZSA9IHRoaXMuZmluZERPTU5vZGUoKTtcbiAgICBpZiAodGhpc05vZGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb3duZXJEb2N1bWVudFxuICAgICAgfSA9IHRoaXNOb2RlO1xuICAgICAgKDAsIF9kb21GbnMucmVtb3ZlRXZlbnQpKG93bmVyRG9jdW1lbnQsIGV2ZW50c0Zvci5tb3VzZS5tb3ZlLCB0aGlzLmhhbmRsZURyYWcpO1xuICAgICAgKDAsIF9kb21GbnMucmVtb3ZlRXZlbnQpKG93bmVyRG9jdW1lbnQsIGV2ZW50c0Zvci50b3VjaC5tb3ZlLCB0aGlzLmhhbmRsZURyYWcpO1xuICAgICAgKDAsIF9kb21GbnMucmVtb3ZlRXZlbnQpKG93bmVyRG9jdW1lbnQsIGV2ZW50c0Zvci5tb3VzZS5zdG9wLCB0aGlzLmhhbmRsZURyYWdTdG9wKTtcbiAgICAgICgwLCBfZG9tRm5zLnJlbW92ZUV2ZW50KShvd25lckRvY3VtZW50LCBldmVudHNGb3IudG91Y2guc3RvcCwgdGhpcy5oYW5kbGVEcmFnU3RvcCk7XG4gICAgICAoMCwgX2RvbUZucy5yZW1vdmVFdmVudCkodGhpc05vZGUsIGV2ZW50c0Zvci50b3VjaC5zdGFydCwgdGhpcy5vblRvdWNoU3RhcnQsIHtcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMucHJvcHMuZW5hYmxlVXNlclNlbGVjdEhhY2spICgwLCBfZG9tRm5zLnJlbW92ZVVzZXJTZWxlY3RTdHlsZXMpKG93bmVyRG9jdW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlYWN0IFN0cmljdCBNb2RlIGNvbXBhdGliaWxpdHk6IGlmIGBub2RlUmVmYCBpcyBwYXNzZWQsIHdlIHdpbGwgdXNlIGl0IGluc3RlYWQgb2YgdHJ5aW5nIHRvIGZpbmRcbiAgLy8gdGhlIHVuZGVybHlpbmcgRE9NIG5vZGUgb3Vyc2VsdmVzLiBTZWUgdGhlIFJFQURNRSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgZmluZERPTU5vZGUoKSAvKjogP0hUTUxFbGVtZW50Ki97XG4gICAgdmFyIF90aGlzJHByb3BzLCBfdGhpcyRwcm9wczI7XG4gICAgcmV0dXJuIChfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMpICE9PSBudWxsICYmIF90aGlzJHByb3BzICE9PSB2b2lkIDAgJiYgX3RoaXMkcHJvcHMubm9kZVJlZiA/IChfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzKSA9PT0gbnVsbCB8fCBfdGhpcyRwcm9wczIgPT09IHZvaWQgMCB8fCAoX3RoaXMkcHJvcHMyID0gX3RoaXMkcHJvcHMyLm5vZGVSZWYpID09PSBudWxsIHx8IF90aGlzJHByb3BzMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkcHJvcHMyLmN1cnJlbnQgOiBfcmVhY3REb20uZGVmYXVsdC5maW5kRE9NTm9kZSh0aGlzKTtcbiAgfVxuICByZW5kZXIoKSAvKjogUmVhY3QuRWxlbWVudDxhbnk+Ki97XG4gICAgLy8gUmV1c2UgdGhlIGNoaWxkIHByb3ZpZGVkXG4gICAgLy8gVGhpcyBtYWtlcyBpdCBmbGV4aWJsZSB0byB1c2Ugd2hhdGV2ZXIgZWxlbWVudCBpcyB3YW50ZWQgKGRpdiwgdWwsIGV0YylcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChSZWFjdC5DaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pLCB7XG4gICAgICAvLyBOb3RlOiBtb3VzZU1vdmUgaGFuZGxlciBpcyBhdHRhY2hlZCB0byBkb2N1bWVudCBzbyBpdCB3aWxsIHN0aWxsIGZ1bmN0aW9uXG4gICAgICAvLyB3aGVuIHRoZSB1c2VyIGRyYWdzIHF1aWNrbHkgYW5kIGxlYXZlcyB0aGUgYm91bmRzIG9mIHRoZSBlbGVtZW50LlxuICAgICAgb25Nb3VzZURvd246IHRoaXMub25Nb3VzZURvd24sXG4gICAgICBvbk1vdXNlVXA6IHRoaXMub25Nb3VzZVVwLFxuICAgICAgLy8gb25Ub3VjaFN0YXJ0IGlzIGFkZGVkIG9uIGBjb21wb25lbnREaWRNb3VudGAgc28gdGhleSBjYW4gYmUgYWRkZWQgd2l0aFxuICAgICAgLy8ge3Bhc3NpdmU6IGZhbHNlfSwgd2hpY2ggYWxsb3dzIGl0IHRvIGNhbmNlbC4gU2VlXG4gICAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdXBkYXRlcy8yMDE3LzAxL3Njcm9sbGluZy1pbnRlcnZlbnRpb25cbiAgICAgIG9uVG91Y2hFbmQ6IHRoaXMub25Ub3VjaEVuZFxuICAgIH0pO1xuICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBEcmFnZ2FibGVDb3JlO1xuX2RlZmluZVByb3BlcnR5KERyYWdnYWJsZUNvcmUsIFwiZGlzcGxheU5hbWVcIiwgJ0RyYWdnYWJsZUNvcmUnKTtcbl9kZWZpbmVQcm9wZXJ0eShEcmFnZ2FibGVDb3JlLCBcInByb3BUeXBlc1wiLCB7XG4gIC8qKlxuICAgKiBgYWxsb3dBbnlDbGlja2AgYWxsb3dzIGRyYWdnaW5nIHVzaW5nIGFueSBtb3VzZSBidXR0b24uXG4gICAqIEJ5IGRlZmF1bHQsIHdlIG9ubHkgYWNjZXB0IHRoZSBsZWZ0IGJ1dHRvbi5cbiAgICpcbiAgICogRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgICovXG4gIGFsbG93QW55Q2xpY2s6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuICBjaGlsZHJlbjogX3Byb3BUeXBlcy5kZWZhdWx0Lm5vZGUuaXNSZXF1aXJlZCxcbiAgLyoqXG4gICAqIGBkaXNhYmxlZGAsIGlmIHRydWUsIHN0b3BzIHRoZSA8RHJhZ2dhYmxlPiBmcm9tIGRyYWdnaW5nLiBBbGwgaGFuZGxlcnMsXG4gICAqIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBgb25Nb3VzZURvd25gLCB3aWxsIG5vdCBmaXJlLlxuICAgKi9cbiAgZGlzYWJsZWQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuICAvKipcbiAgICogQnkgZGVmYXVsdCwgd2UgYWRkICd1c2VyLXNlbGVjdDpub25lJyBhdHRyaWJ1dGVzIHRvIHRoZSBkb2N1bWVudCBib2R5XG4gICAqIHRvIHByZXZlbnQgdWdseSB0ZXh0IHNlbGVjdGlvbiBkdXJpbmcgZHJhZy4gSWYgdGhpcyBpcyBjYXVzaW5nIHByb2JsZW1zXG4gICAqIGZvciB5b3VyIGFwcCwgc2V0IHRoaXMgdG8gYGZhbHNlYC5cbiAgICovXG4gIGVuYWJsZVVzZXJTZWxlY3RIYWNrOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcbiAgLyoqXG4gICAqIGBvZmZzZXRQYXJlbnRgLCBpZiBzZXQsIHVzZXMgdGhlIHBhc3NlZCBET00gbm9kZSB0byBjb21wdXRlIGRyYWcgb2Zmc2V0c1xuICAgKiBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBwYXJlbnQgbm9kZS5cbiAgICovXG4gIG9mZnNldFBhcmVudDogZnVuY3Rpb24gKHByb3BzIC8qOiBEcmFnZ2FibGVDb3JlUHJvcHMqLywgcHJvcE5hbWUgLyo6ICRLZXlzPERyYWdnYWJsZUNvcmVQcm9wcz4qLykge1xuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gJiYgcHJvcHNbcHJvcE5hbWVdLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RyYWdnYWJsZVxcJ3Mgb2Zmc2V0UGFyZW50IG11c3QgYmUgYSBET00gTm9kZS4nKTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBgZ3JpZGAgc3BlY2lmaWVzIHRoZSB4IGFuZCB5IHRoYXQgZHJhZ2dpbmcgc2hvdWxkIHNuYXAgdG8uXG4gICAqL1xuICBncmlkOiBfcHJvcFR5cGVzLmRlZmF1bHQuYXJyYXlPZihfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyKSxcbiAgLyoqXG4gICAqIGBoYW5kbGVgIHNwZWNpZmllcyBhIHNlbGVjdG9yIHRvIGJlIHVzZWQgYXMgdGhlIGhhbmRsZSB0aGF0IGluaXRpYXRlcyBkcmFnLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGBqc3hcbiAgICogICBsZXQgQXBwID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICogICAgICAgICByZXR1cm4gKFxuICAgKiAgICAgICAgICAgIDxEcmFnZ2FibGUgaGFuZGxlPVwiLmhhbmRsZVwiPlxuICAgKiAgICAgICAgICAgICAgPGRpdj5cbiAgICogICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImhhbmRsZVwiPkNsaWNrIG1lIHRvIGRyYWc8L2Rpdj5cbiAgICogICAgICAgICAgICAgICAgICA8ZGl2PlRoaXMgaXMgc29tZSBvdGhlciBjb250ZW50PC9kaXY+XG4gICAqICAgICAgICAgICAgICA8L2Rpdj5cbiAgICogICAgICAgICAgIDwvRHJhZ2dhYmxlPlxuICAgKiAgICAgICAgICk7XG4gICAqICAgICAgIH1cbiAgICogICB9KTtcbiAgICogYGBgXG4gICAqL1xuICBoYW5kbGU6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gIC8qKlxuICAgKiBgY2FuY2VsYCBzcGVjaWZpZXMgYSBzZWxlY3RvciB0byBiZSB1c2VkIHRvIHByZXZlbnQgZHJhZyBpbml0aWFsaXphdGlvbi5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogYGBganN4XG4gICAqICAgbGV0IEFwcCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAqICAgICAgICAgICByZXR1cm4oXG4gICAqICAgICAgICAgICAgICAgPERyYWdnYWJsZSBjYW5jZWw9XCIuY2FuY2VsXCI+XG4gICAqICAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAqICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYW5jZWxcIj5Zb3UgY2FuJ3QgZHJhZyBmcm9tIGhlcmU8L2Rpdj5cbiAgICogICAgICAgICAgICAgICAgICAgICA8ZGl2PkRyYWdnaW5nIGhlcmUgd29ya3MgZmluZTwvZGl2PlxuICAgKiAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICogICAgICAgICAgICAgICA8L0RyYWdnYWJsZT5cbiAgICogICAgICAgICAgICk7XG4gICAqICAgICAgIH1cbiAgICogICB9KTtcbiAgICogYGBgXG4gICAqL1xuICBjYW5jZWw6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gIC8qIElmIHJ1bm5pbmcgaW4gUmVhY3QgU3RyaWN0IG1vZGUsIFJlYWN0RE9NLmZpbmRET01Ob2RlKCkgaXMgZGVwcmVjYXRlZC5cbiAgICogVW5mb3J0dW5hdGVseSwgaW4gb3JkZXIgZm9yIDxEcmFnZ2FibGU+IHRvIHdvcmsgcHJvcGVybHksIHdlIG5lZWQgcmF3IGFjY2Vzc1xuICAgKiB0byB0aGUgdW5kZXJseWluZyBET00gbm9kZS4gSWYgeW91IHdhbnQgdG8gYXZvaWQgdGhlIHdhcm5pbmcsIHBhc3MgYSBgbm9kZVJlZmBcbiAgICogYXMgaW4gdGhpcyBleGFtcGxlOlxuICAgKlxuICAgKiBmdW5jdGlvbiBNeUNvbXBvbmVudCgpIHtcbiAgICogICBjb25zdCBub2RlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgKiAgIHJldHVybiAoXG4gICAqICAgICA8RHJhZ2dhYmxlIG5vZGVSZWY9e25vZGVSZWZ9PlxuICAgKiAgICAgICA8ZGl2IHJlZj17bm9kZVJlZn0+RXhhbXBsZSBUYXJnZXQ8L2Rpdj5cbiAgICogICAgIDwvRHJhZ2dhYmxlPlxuICAgKiAgICk7XG4gICAqIH1cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCBmb3IgYXJiaXRyYXJpbHkgbmVzdGVkIGNvbXBvbmVudHMsIHNvIGxvbmcgYXMgdGhlIHJlZiBlbmRzIHVwXG4gICAqIHBvaW50aW5nIHRvIHRoZSBhY3R1YWwgY2hpbGQgRE9NIG5vZGUgYW5kIG5vdCBhIGN1c3RvbSBjb21wb25lbnQuXG4gICAqL1xuICBub2RlUmVmOiBfcHJvcFR5cGVzLmRlZmF1bHQub2JqZWN0LFxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gZHJhZ2dpbmcgc3RhcnRzLlxuICAgKiBJZiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGJvb2xlYW4gZmFsc2UsIGRyYWdnaW5nIHdpbGwgYmUgY2FuY2VsZWQuXG4gICAqL1xuICBvblN0YXJ0OiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgLyoqXG4gICAqIENhbGxlZCB3aGlsZSBkcmFnZ2luZy5cbiAgICogSWYgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBib29sZWFuIGZhbHNlLCBkcmFnZ2luZyB3aWxsIGJlIGNhbmNlbGVkLlxuICAgKi9cbiAgb25EcmFnOiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGRyYWdnaW5nIHN0b3BzLlxuICAgKiBJZiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGJvb2xlYW4gZmFsc2UsIHRoZSBkcmFnIHdpbGwgcmVtYWluIGFjdGl2ZS5cbiAgICovXG4gIG9uU3RvcDogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIC8qKlxuICAgKiBBIHdvcmthcm91bmQgb3B0aW9uIHdoaWNoIGNhbiBiZSBwYXNzZWQgaWYgb25Nb3VzZURvd24gbmVlZHMgdG8gYmUgYWNjZXNzZWQsXG4gICAqIHNpbmNlIGl0J2xsIGFsd2F5cyBiZSBibG9ja2VkIChhcyB0aGVyZSBpcyBpbnRlcm5hbCB1c2Ugb2Ygb25Nb3VzZURvd24pXG4gICAqL1xuICBvbk1vdXNlRG93bjogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIC8qKlxuICAgKiBgc2NhbGVgLCBpZiBzZXQsIGFwcGxpZXMgc2NhbGluZyB3aGlsZSBkcmFnZ2luZyBhbiBlbGVtZW50XG4gICAqL1xuICBzY2FsZTogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgLyoqXG4gICAqIFRoZXNlIHByb3BlcnRpZXMgc2hvdWxkIGJlIGRlZmluZWQgb24gdGhlIGNoaWxkLCBub3QgaGVyZS5cbiAgICovXG4gIGNsYXNzTmFtZTogX3NoaW1zLmRvbnRTZXRNZSxcbiAgc3R5bGU6IF9zaGltcy5kb250U2V0TWUsXG4gIHRyYW5zZm9ybTogX3NoaW1zLmRvbnRTZXRNZVxufSk7XG5fZGVmaW5lUHJvcGVydHkoRHJhZ2dhYmxlQ29yZSwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICBhbGxvd0FueUNsaWNrOiBmYWxzZSxcbiAgLy8gYnkgZGVmYXVsdCBvbmx5IGFjY2VwdCBsZWZ0IGNsaWNrXG4gIGRpc2FibGVkOiBmYWxzZSxcbiAgZW5hYmxlVXNlclNlbGVjdEhhY2s6IHRydWUsXG4gIG9uU3RhcnQ6IGZ1bmN0aW9uICgpIHt9LFxuICBvbkRyYWc6IGZ1bmN0aW9uICgpIHt9LFxuICBvblN0b3A6IGZ1bmN0aW9uICgpIHt9LFxuICBvbk1vdXNlRG93bjogZnVuY3Rpb24gKCkge30sXG4gIHNjYWxlOiAxXG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-draggable/build/cjs/DraggableCore.js\n"));

/***/ }),

/***/ "./node_modules/react-draggable/build/cjs/cjs.js":
/*!*******************************************************!*\
  !*** ./node_modules/react-draggable/build/cjs/cjs.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nconst {\n  default: Draggable,\n  DraggableCore\n} = __webpack_require__(/*! ./Draggable */ \"./node_modules/react-draggable/build/cjs/Draggable.js\");\n\n// Previous versions of this lib exported <Draggable> as the root export. As to no-// them, or TypeScript, we export *both* as the root and as 'default'.\n// See https://github.com/mzabriskie/react-draggable/pull/254\n// and https://github.com/mzabriskie/react-draggable/issues/266\nmodule.exports = Draggable;\nmodule.exports[\"default\"] = Draggable;\nmodule.exports.DraggableCore = DraggableCore;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy9janMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsMEVBQWE7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXNCO0FBQ3RCLDRCQUE0QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy9janMuanM/Nzc2MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuY29uc3Qge1xuICBkZWZhdWx0OiBEcmFnZ2FibGUsXG4gIERyYWdnYWJsZUNvcmVcbn0gPSByZXF1aXJlKCcuL0RyYWdnYWJsZScpO1xuXG4vLyBQcmV2aW91cyB2ZXJzaW9ucyBvZiB0aGlzIGxpYiBleHBvcnRlZCA8RHJhZ2dhYmxlPiBhcyB0aGUgcm9vdCBleHBvcnQuIEFzIHRvIG5vLS8vIHRoZW0sIG9yIFR5cGVTY3JpcHQsIHdlIGV4cG9ydCAqYm90aCogYXMgdGhlIHJvb3QgYW5kIGFzICdkZWZhdWx0Jy5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbXphYnJpc2tpZS9yZWFjdC1kcmFnZ2FibGUvcHVsbC8yNTRcbi8vIGFuZCBodHRwczovL2dpdGh1Yi5jb20vbXphYnJpc2tpZS9yZWFjdC1kcmFnZ2FibGUvaXNzdWVzLzI2NlxubW9kdWxlLmV4cG9ydHMgPSBEcmFnZ2FibGU7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gRHJhZ2dhYmxlO1xubW9kdWxlLmV4cG9ydHMuRHJhZ2dhYmxlQ29yZSA9IERyYWdnYWJsZUNvcmU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-draggable/build/cjs/cjs.js\n"));

/***/ }),

/***/ "./node_modules/react-draggable/build/cjs/utils/domFns.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-draggable/build/cjs/utils/domFns.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.addClassName = addClassName;\nexports.addEvent = addEvent;\nexports.addUserSelectStyles = addUserSelectStyles;\nexports.createCSSTransform = createCSSTransform;\nexports.createSVGTransform = createSVGTransform;\nexports.getTouch = getTouch;\nexports.getTouchIdentifier = getTouchIdentifier;\nexports.getTranslation = getTranslation;\nexports.innerHeight = innerHeight;\nexports.innerWidth = innerWidth;\nexports.matchesSelector = matchesSelector;\nexports.matchesSelectorAndParentsTo = matchesSelectorAndParentsTo;\nexports.offsetXYFromParent = offsetXYFromParent;\nexports.outerHeight = outerHeight;\nexports.outerWidth = outerWidth;\nexports.removeClassName = removeClassName;\nexports.removeEvent = removeEvent;\nexports.removeUserSelectStyles = removeUserSelectStyles;\nvar _shims = __webpack_require__(/*! ./shims */ \"./node_modules/react-draggable/build/cjs/utils/shims.js\");\nvar _getPrefix = _interopRequireWildcard(__webpack_require__(/*! ./getPrefix */ \"./node_modules/react-draggable/build/cjs/utils/getPrefix.js\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/*:: import type {ControlPosition, PositionOffsetControlPosition, MouseTouchEvent} from './types';*/\nlet matchesSelectorFunc = '';\nfunction matchesSelector(el /*: Node*/, selector /*: string*/) /*: boolean*/{\n  if (!matchesSelectorFunc) {\n    matchesSelectorFunc = (0, _shims.findInArray)(['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector'], function (method) {\n      // $FlowIgnore: Doesn't think elements are indexable\n      return (0, _shims.isFunction)(el[method]);\n    });\n  }\n\n  // Might not be found entirely (not an Element?) - in that case, bail\n  // $FlowIgnore: Doesn't think elements are indexable\n  if (!(0, _shims.isFunction)(el[matchesSelectorFunc])) return false;\n\n  // $FlowIgnore: Doesn't think elements are indexable\n  return el[matchesSelectorFunc](selector);\n}\n\n// Works up the tree to the draggable itself attempting to match selector.\nfunction matchesSelectorAndParentsTo(el /*: Node*/, selector /*: string*/, baseNode /*: Node*/) /*: boolean*/{\n  let node = el;\n  do {\n    if (matchesSelector(node, selector)) return true;\n    if (node === baseNode) return false;\n    // $FlowIgnore[incompatible-type]\n    node = node.parentNode;\n  } while (node);\n  return false;\n}\nfunction addEvent(el /*: ?Node*/, event /*: string*/, handler /*: Function*/, inputOptions /*: Object*/) /*: void*/{\n  if (!el) return;\n  const options = {\n    capture: true,\n    ...inputOptions\n  };\n  // $FlowIgnore[method-unbinding]\n  if (el.addEventListener) {\n    el.addEventListener(event, handler, options);\n  } else if (el.attachEvent) {\n    el.attachEvent('on' + event, handler);\n  } else {\n    // $FlowIgnore: Doesn't think elements are indexable\n    el['on' + event] = handler;\n  }\n}\nfunction removeEvent(el /*: ?Node*/, event /*: string*/, handler /*: Function*/, inputOptions /*: Object*/) /*: void*/{\n  if (!el) return;\n  const options = {\n    capture: true,\n    ...inputOptions\n  };\n  // $FlowIgnore[method-unbinding]\n  if (el.removeEventListener) {\n    el.removeEventListener(event, handler, options);\n  } else if (el.detachEvent) {\n    el.detachEvent('on' + event, handler);\n  } else {\n    // $FlowIgnore: Doesn't think elements are indexable\n    el['on' + event] = null;\n  }\n}\nfunction outerHeight(node /*: HTMLElement*/) /*: number*/{\n  // This is deliberately excluding margin for our calculations, since we are using\n  // offsetTop which is including margin. See getBoundPosition\n  let height = node.clientHeight;\n  const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n  height += (0, _shims.int)(computedStyle.borderTopWidth);\n  height += (0, _shims.int)(computedStyle.borderBottomWidth);\n  return height;\n}\nfunction outerWidth(node /*: HTMLElement*/) /*: number*/{\n  // This is deliberately excluding margin for our calculations, since we are using\n  // offsetLeft which is including margin. See getBoundPosition\n  let width = node.clientWidth;\n  const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n  width += (0, _shims.int)(computedStyle.borderLeftWidth);\n  width += (0, _shims.int)(computedStyle.borderRightWidth);\n  return width;\n}\nfunction innerHeight(node /*: HTMLElement*/) /*: number*/{\n  let height = node.clientHeight;\n  const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n  height -= (0, _shims.int)(computedStyle.paddingTop);\n  height -= (0, _shims.int)(computedStyle.paddingBottom);\n  return height;\n}\nfunction innerWidth(node /*: HTMLElement*/) /*: number*/{\n  let width = node.clientWidth;\n  const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n  width -= (0, _shims.int)(computedStyle.paddingLeft);\n  width -= (0, _shims.int)(computedStyle.paddingRight);\n  return width;\n}\n/*:: interface EventWithOffset {\n  clientX: number, clientY: number\n}*/\n// Get from offsetParent\nfunction offsetXYFromParent(evt /*: EventWithOffset*/, offsetParent /*: HTMLElement*/, scale /*: number*/) /*: ControlPosition*/{\n  const isBody = offsetParent === offsetParent.ownerDocument.body;\n  const offsetParentRect = isBody ? {\n    left: 0,\n    top: 0\n  } : offsetParent.getBoundingClientRect();\n  const x = (evt.clientX + offsetParent.scrollLeft - offsetParentRect.left) / scale;\n  const y = (evt.clientY + offsetParent.scrollTop - offsetParentRect.top) / scale;\n  return {\n    x,\n    y\n  };\n}\nfunction createCSSTransform(controlPos /*: ControlPosition*/, positionOffset /*: PositionOffsetControlPosition*/) /*: Object*/{\n  const translation = getTranslation(controlPos, positionOffset, 'px');\n  return {\n    [(0, _getPrefix.browserPrefixToKey)('transform', _getPrefix.default)]: translation\n  };\n}\nfunction createSVGTransform(controlPos /*: ControlPosition*/, positionOffset /*: PositionOffsetControlPosition*/) /*: string*/{\n  const translation = getTranslation(controlPos, positionOffset, '');\n  return translation;\n}\nfunction getTranslation(_ref /*:: */, positionOffset /*: PositionOffsetControlPosition*/, unitSuffix /*: string*/) /*: string*/{\n  let {\n    x,\n    y\n  } /*: ControlPosition*/ = _ref /*: ControlPosition*/;\n  let translation = \"translate(\".concat(x).concat(unitSuffix, \",\").concat(y).concat(unitSuffix, \")\");\n  if (positionOffset) {\n    const defaultX = \"\".concat(typeof positionOffset.x === 'string' ? positionOffset.x : positionOffset.x + unitSuffix);\n    const defaultY = \"\".concat(typeof positionOffset.y === 'string' ? positionOffset.y : positionOffset.y + unitSuffix);\n    translation = \"translate(\".concat(defaultX, \", \").concat(defaultY, \")\") + translation;\n  }\n  return translation;\n}\nfunction getTouch(e /*: MouseTouchEvent*/, identifier /*: number*/) /*: ?{clientX: number, clientY: number}*/{\n  return e.targetTouches && (0, _shims.findInArray)(e.targetTouches, t => identifier === t.identifier) || e.changedTouches && (0, _shims.findInArray)(e.changedTouches, t => identifier === t.identifier);\n}\nfunction getTouchIdentifier(e /*: MouseTouchEvent*/) /*: ?number*/{\n  if (e.targetTouches && e.targetTouches[0]) return e.targetTouches[0].identifier;\n  if (e.changedTouches && e.changedTouches[0]) return e.changedTouches[0].identifier;\n}\n\n// User-select Hacks:\n//\n// Useful for preventing blue highlights all over everything when dragging.\n\n// Note we're passing `document` b/c we could be iframed\nfunction addUserSelectStyles(doc /*: ?Document*/) {\n  if (!doc) return;\n  let styleEl = doc.getElementById('react-draggable-style-el');\n  if (!styleEl) {\n    styleEl = doc.createElement('style');\n    styleEl.type = 'text/css';\n    styleEl.id = 'react-draggable-style-el';\n    styleEl.innerHTML = '.react-draggable-transparent-selection *::-moz-selection {all: inherit;}\\n';\n    styleEl.innerHTML += '.react-draggable-transparent-selection *::selection {all: inherit;}\\n';\n    doc.getElementsByTagName('head')[0].appendChild(styleEl);\n  }\n  if (doc.body) addClassName(doc.body, 'react-draggable-transparent-selection');\n}\nfunction removeUserSelectStyles(doc /*: ?Document*/) {\n  if (!doc) return;\n  try {\n    if (doc.body) removeClassName(doc.body, 'react-draggable-transparent-selection');\n    // $FlowIgnore: IE\n    if (doc.selection) {\n      // $FlowIgnore: IE\n      doc.selection.empty();\n    } else {\n      // Remove selection caused by scroll, unless it's a focused input\n      // (we use doc.defaultView in case we're in an iframe)\n      const selection = (doc.defaultView || window).getSelection();\n      if (selection && selection.type !== 'Caret') {\n        selection.removeAllRanges();\n      }\n    }\n  } catch (e) {\n    // probably IE\n  }\n}\nfunction addClassName(el /*: HTMLElement*/, className /*: string*/) {\n  if (el.classList) {\n    el.classList.add(className);\n  } else {\n    if (!el.className.match(new RegExp(\"(?:^|\\\\s)\".concat(className, \"(?!\\\\S)\")))) {\n      el.className += \" \".concat(className);\n    }\n  }\n}\nfunction removeClassName(el /*: HTMLElement*/, className /*: string*/) {\n  if (el.classList) {\n    el.classList.remove(className);\n  } else {\n    el.className = el.className.replace(new RegExp(\"(?:^|\\\\s)\".concat(className, \"(?!\\\\S)\"), 'g'), '');\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy91dGlscy9kb21GbnMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0JBQW9CO0FBQ3BCLGdCQUFnQjtBQUNoQiwyQkFBMkI7QUFDM0IsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQixnQkFBZ0I7QUFDaEIsMEJBQTBCO0FBQzFCLHNCQUFzQjtBQUN0QixtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCLHVCQUF1QjtBQUN2QixtQ0FBbUM7QUFDbkMsMEJBQTBCO0FBQzFCLG1CQUFtQjtBQUNuQixrQkFBa0I7QUFDbEIsdUJBQXVCO0FBQ3ZCLG1CQUFtQjtBQUNuQiw4QkFBOEI7QUFDOUIsYUFBYSxtQkFBTyxDQUFDLHdFQUFTO0FBQzlCLHlDQUF5QyxtQkFBTyxDQUFDLGdGQUFhO0FBQzlELGlEQUFpRCxnREFBZ0QsdUNBQXVDLHNDQUFzQyw0REFBNEQsNERBQTREO0FBQ3RTLHFEQUFxRCw2Q0FBNkMsY0FBYyw0RUFBNEUsU0FBUyxrQkFBa0IsbURBQW1ELCtCQUErQix5QkFBeUIsaUJBQWlCLHNGQUFzRix1QkFBdUIsMkVBQTJFLHFGQUFxRixzQ0FBc0MsNENBQTRDLE9BQU8sOEJBQThCLHNCQUFzQixhQUFhLDBCQUEwQjtBQUNweEIsa0JBQWtCLGlFQUFpRSxlQUFlO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxpQ0FBaUM7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLGNBQWM7QUFDakcsK0VBQStFLGNBQWM7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy91dGlscy9kb21GbnMuanM/MzlhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYWRkQ2xhc3NOYW1lID0gYWRkQ2xhc3NOYW1lO1xuZXhwb3J0cy5hZGRFdmVudCA9IGFkZEV2ZW50O1xuZXhwb3J0cy5hZGRVc2VyU2VsZWN0U3R5bGVzID0gYWRkVXNlclNlbGVjdFN0eWxlcztcbmV4cG9ydHMuY3JlYXRlQ1NTVHJhbnNmb3JtID0gY3JlYXRlQ1NTVHJhbnNmb3JtO1xuZXhwb3J0cy5jcmVhdGVTVkdUcmFuc2Zvcm0gPSBjcmVhdGVTVkdUcmFuc2Zvcm07XG5leHBvcnRzLmdldFRvdWNoID0gZ2V0VG91Y2g7XG5leHBvcnRzLmdldFRvdWNoSWRlbnRpZmllciA9IGdldFRvdWNoSWRlbnRpZmllcjtcbmV4cG9ydHMuZ2V0VHJhbnNsYXRpb24gPSBnZXRUcmFuc2xhdGlvbjtcbmV4cG9ydHMuaW5uZXJIZWlnaHQgPSBpbm5lckhlaWdodDtcbmV4cG9ydHMuaW5uZXJXaWR0aCA9IGlubmVyV2lkdGg7XG5leHBvcnRzLm1hdGNoZXNTZWxlY3RvciA9IG1hdGNoZXNTZWxlY3RvcjtcbmV4cG9ydHMubWF0Y2hlc1NlbGVjdG9yQW5kUGFyZW50c1RvID0gbWF0Y2hlc1NlbGVjdG9yQW5kUGFyZW50c1RvO1xuZXhwb3J0cy5vZmZzZXRYWUZyb21QYXJlbnQgPSBvZmZzZXRYWUZyb21QYXJlbnQ7XG5leHBvcnRzLm91dGVySGVpZ2h0ID0gb3V0ZXJIZWlnaHQ7XG5leHBvcnRzLm91dGVyV2lkdGggPSBvdXRlcldpZHRoO1xuZXhwb3J0cy5yZW1vdmVDbGFzc05hbWUgPSByZW1vdmVDbGFzc05hbWU7XG5leHBvcnRzLnJlbW92ZUV2ZW50ID0gcmVtb3ZlRXZlbnQ7XG5leHBvcnRzLnJlbW92ZVVzZXJTZWxlY3RTdHlsZXMgPSByZW1vdmVVc2VyU2VsZWN0U3R5bGVzO1xudmFyIF9zaGltcyA9IHJlcXVpcmUoXCIuL3NoaW1zXCIpO1xudmFyIF9nZXRQcmVmaXggPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9nZXRQcmVmaXhcIikpO1xuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlQmFiZWxJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgdmFyIGNhY2hlTm9kZUludGVyb3AgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIChub2RlSW50ZXJvcCkgeyByZXR1cm4gbm9kZUludGVyb3AgPyBjYWNoZU5vZGVJbnRlcm9wIDogY2FjaGVCYWJlbEludGVyb3A7IH0pKG5vZGVJbnRlcm9wKTsgfVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqLCBub2RlSW50ZXJvcCkgeyBpZiAoIW5vZGVJbnRlcm9wICYmIG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoa2V5ICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG4vKjo6IGltcG9ydCB0eXBlIHtDb250cm9sUG9zaXRpb24sIFBvc2l0aW9uT2Zmc2V0Q29udHJvbFBvc2l0aW9uLCBNb3VzZVRvdWNoRXZlbnR9IGZyb20gJy4vdHlwZXMnOyovXG5sZXQgbWF0Y2hlc1NlbGVjdG9yRnVuYyA9ICcnO1xuZnVuY3Rpb24gbWF0Y2hlc1NlbGVjdG9yKGVsIC8qOiBOb2RlKi8sIHNlbGVjdG9yIC8qOiBzdHJpbmcqLykgLyo6IGJvb2xlYW4qL3tcbiAgaWYgKCFtYXRjaGVzU2VsZWN0b3JGdW5jKSB7XG4gICAgbWF0Y2hlc1NlbGVjdG9yRnVuYyA9ICgwLCBfc2hpbXMuZmluZEluQXJyYXkpKFsnbWF0Y2hlcycsICd3ZWJraXRNYXRjaGVzU2VsZWN0b3InLCAnbW96TWF0Y2hlc1NlbGVjdG9yJywgJ21zTWF0Y2hlc1NlbGVjdG9yJywgJ29NYXRjaGVzU2VsZWN0b3InXSwgZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgLy8gJEZsb3dJZ25vcmU6IERvZXNuJ3QgdGhpbmsgZWxlbWVudHMgYXJlIGluZGV4YWJsZVxuICAgICAgcmV0dXJuICgwLCBfc2hpbXMuaXNGdW5jdGlvbikoZWxbbWV0aG9kXSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBNaWdodCBub3QgYmUgZm91bmQgZW50aXJlbHkgKG5vdCBhbiBFbGVtZW50PykgLSBpbiB0aGF0IGNhc2UsIGJhaWxcbiAgLy8gJEZsb3dJZ25vcmU6IERvZXNuJ3QgdGhpbmsgZWxlbWVudHMgYXJlIGluZGV4YWJsZVxuICBpZiAoISgwLCBfc2hpbXMuaXNGdW5jdGlvbikoZWxbbWF0Y2hlc1NlbGVjdG9yRnVuY10pKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gJEZsb3dJZ25vcmU6IERvZXNuJ3QgdGhpbmsgZWxlbWVudHMgYXJlIGluZGV4YWJsZVxuICByZXR1cm4gZWxbbWF0Y2hlc1NlbGVjdG9yRnVuY10oc2VsZWN0b3IpO1xufVxuXG4vLyBXb3JrcyB1cCB0aGUgdHJlZSB0byB0aGUgZHJhZ2dhYmxlIGl0c2VsZiBhdHRlbXB0aW5nIHRvIG1hdGNoIHNlbGVjdG9yLlxuZnVuY3Rpb24gbWF0Y2hlc1NlbGVjdG9yQW5kUGFyZW50c1RvKGVsIC8qOiBOb2RlKi8sIHNlbGVjdG9yIC8qOiBzdHJpbmcqLywgYmFzZU5vZGUgLyo6IE5vZGUqLykgLyo6IGJvb2xlYW4qL3tcbiAgbGV0IG5vZGUgPSBlbDtcbiAgZG8ge1xuICAgIGlmIChtYXRjaGVzU2VsZWN0b3Iobm9kZSwgc2VsZWN0b3IpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAobm9kZSA9PT0gYmFzZU5vZGUpIHJldHVybiBmYWxzZTtcbiAgICAvLyAkRmxvd0lnbm9yZVtpbmNvbXBhdGlibGUtdHlwZV1cbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9IHdoaWxlIChub2RlKTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gYWRkRXZlbnQoZWwgLyo6ID9Ob2RlKi8sIGV2ZW50IC8qOiBzdHJpbmcqLywgaGFuZGxlciAvKjogRnVuY3Rpb24qLywgaW5wdXRPcHRpb25zIC8qOiBPYmplY3QqLykgLyo6IHZvaWQqL3tcbiAgaWYgKCFlbCkgcmV0dXJuO1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIGNhcHR1cmU6IHRydWUsXG4gICAgLi4uaW5wdXRPcHRpb25zXG4gIH07XG4gIC8vICRGbG93SWdub3JlW21ldGhvZC11bmJpbmRpbmddXG4gIGlmIChlbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAoZWwuYXR0YWNoRXZlbnQpIHtcbiAgICBlbC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGhhbmRsZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vICRGbG93SWdub3JlOiBEb2Vzbid0IHRoaW5rIGVsZW1lbnRzIGFyZSBpbmRleGFibGVcbiAgICBlbFsnb24nICsgZXZlbnRdID0gaGFuZGxlcjtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlRXZlbnQoZWwgLyo6ID9Ob2RlKi8sIGV2ZW50IC8qOiBzdHJpbmcqLywgaGFuZGxlciAvKjogRnVuY3Rpb24qLywgaW5wdXRPcHRpb25zIC8qOiBPYmplY3QqLykgLyo6IHZvaWQqL3tcbiAgaWYgKCFlbCkgcmV0dXJuO1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIGNhcHR1cmU6IHRydWUsXG4gICAgLi4uaW5wdXRPcHRpb25zXG4gIH07XG4gIC8vICRGbG93SWdub3JlW21ldGhvZC11bmJpbmRpbmddXG4gIGlmIChlbC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAoZWwuZGV0YWNoRXZlbnQpIHtcbiAgICBlbC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGhhbmRsZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vICRGbG93SWdub3JlOiBEb2Vzbid0IHRoaW5rIGVsZW1lbnRzIGFyZSBpbmRleGFibGVcbiAgICBlbFsnb24nICsgZXZlbnRdID0gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gb3V0ZXJIZWlnaHQobm9kZSAvKjogSFRNTEVsZW1lbnQqLykgLyo6IG51bWJlciove1xuICAvLyBUaGlzIGlzIGRlbGliZXJhdGVseSBleGNsdWRpbmcgbWFyZ2luIGZvciBvdXIgY2FsY3VsYXRpb25zLCBzaW5jZSB3ZSBhcmUgdXNpbmdcbiAgLy8gb2Zmc2V0VG9wIHdoaWNoIGlzIGluY2x1ZGluZyBtYXJnaW4uIFNlZSBnZXRCb3VuZFBvc2l0aW9uXG4gIGxldCBoZWlnaHQgPSBub2RlLmNsaWVudEhlaWdodDtcbiAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICBoZWlnaHQgKz0gKDAsIF9zaGltcy5pbnQpKGNvbXB1dGVkU3R5bGUuYm9yZGVyVG9wV2lkdGgpO1xuICBoZWlnaHQgKz0gKDAsIF9zaGltcy5pbnQpKGNvbXB1dGVkU3R5bGUuYm9yZGVyQm90dG9tV2lkdGgpO1xuICByZXR1cm4gaGVpZ2h0O1xufVxuZnVuY3Rpb24gb3V0ZXJXaWR0aChub2RlIC8qOiBIVE1MRWxlbWVudCovKSAvKjogbnVtYmVyKi97XG4gIC8vIFRoaXMgaXMgZGVsaWJlcmF0ZWx5IGV4Y2x1ZGluZyBtYXJnaW4gZm9yIG91ciBjYWxjdWxhdGlvbnMsIHNpbmNlIHdlIGFyZSB1c2luZ1xuICAvLyBvZmZzZXRMZWZ0IHdoaWNoIGlzIGluY2x1ZGluZyBtYXJnaW4uIFNlZSBnZXRCb3VuZFBvc2l0aW9uXG4gIGxldCB3aWR0aCA9IG5vZGUuY2xpZW50V2lkdGg7XG4gIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgd2lkdGggKz0gKDAsIF9zaGltcy5pbnQpKGNvbXB1dGVkU3R5bGUuYm9yZGVyTGVmdFdpZHRoKTtcbiAgd2lkdGggKz0gKDAsIF9zaGltcy5pbnQpKGNvbXB1dGVkU3R5bGUuYm9yZGVyUmlnaHRXaWR0aCk7XG4gIHJldHVybiB3aWR0aDtcbn1cbmZ1bmN0aW9uIGlubmVySGVpZ2h0KG5vZGUgLyo6IEhUTUxFbGVtZW50Ki8pIC8qOiBudW1iZXIqL3tcbiAgbGV0IGhlaWdodCA9IG5vZGUuY2xpZW50SGVpZ2h0O1xuICBjb25zdCBjb21wdXRlZFN0eWxlID0gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gIGhlaWdodCAtPSAoMCwgX3NoaW1zLmludCkoY29tcHV0ZWRTdHlsZS5wYWRkaW5nVG9wKTtcbiAgaGVpZ2h0IC09ICgwLCBfc2hpbXMuaW50KShjb21wdXRlZFN0eWxlLnBhZGRpbmdCb3R0b20pO1xuICByZXR1cm4gaGVpZ2h0O1xufVxuZnVuY3Rpb24gaW5uZXJXaWR0aChub2RlIC8qOiBIVE1MRWxlbWVudCovKSAvKjogbnVtYmVyKi97XG4gIGxldCB3aWR0aCA9IG5vZGUuY2xpZW50V2lkdGg7XG4gIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgd2lkdGggLT0gKDAsIF9zaGltcy5pbnQpKGNvbXB1dGVkU3R5bGUucGFkZGluZ0xlZnQpO1xuICB3aWR0aCAtPSAoMCwgX3NoaW1zLmludCkoY29tcHV0ZWRTdHlsZS5wYWRkaW5nUmlnaHQpO1xuICByZXR1cm4gd2lkdGg7XG59XG4vKjo6IGludGVyZmFjZSBFdmVudFdpdGhPZmZzZXQge1xuICBjbGllbnRYOiBudW1iZXIsIGNsaWVudFk6IG51bWJlclxufSovXG4vLyBHZXQgZnJvbSBvZmZzZXRQYXJlbnRcbmZ1bmN0aW9uIG9mZnNldFhZRnJvbVBhcmVudChldnQgLyo6IEV2ZW50V2l0aE9mZnNldCovLCBvZmZzZXRQYXJlbnQgLyo6IEhUTUxFbGVtZW50Ki8sIHNjYWxlIC8qOiBudW1iZXIqLykgLyo6IENvbnRyb2xQb3NpdGlvbiove1xuICBjb25zdCBpc0JvZHkgPSBvZmZzZXRQYXJlbnQgPT09IG9mZnNldFBhcmVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gIGNvbnN0IG9mZnNldFBhcmVudFJlY3QgPSBpc0JvZHkgPyB7XG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDBcbiAgfSA6IG9mZnNldFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgeCA9IChldnQuY2xpZW50WCArIG9mZnNldFBhcmVudC5zY3JvbGxMZWZ0IC0gb2Zmc2V0UGFyZW50UmVjdC5sZWZ0KSAvIHNjYWxlO1xuICBjb25zdCB5ID0gKGV2dC5jbGllbnRZICsgb2Zmc2V0UGFyZW50LnNjcm9sbFRvcCAtIG9mZnNldFBhcmVudFJlY3QudG9wKSAvIHNjYWxlO1xuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ1NTVHJhbnNmb3JtKGNvbnRyb2xQb3MgLyo6IENvbnRyb2xQb3NpdGlvbiovLCBwb3NpdGlvbk9mZnNldCAvKjogUG9zaXRpb25PZmZzZXRDb250cm9sUG9zaXRpb24qLykgLyo6IE9iamVjdCove1xuICBjb25zdCB0cmFuc2xhdGlvbiA9IGdldFRyYW5zbGF0aW9uKGNvbnRyb2xQb3MsIHBvc2l0aW9uT2Zmc2V0LCAncHgnKTtcbiAgcmV0dXJuIHtcbiAgICBbKDAsIF9nZXRQcmVmaXguYnJvd3NlclByZWZpeFRvS2V5KSgndHJhbnNmb3JtJywgX2dldFByZWZpeC5kZWZhdWx0KV06IHRyYW5zbGF0aW9uXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTVkdUcmFuc2Zvcm0oY29udHJvbFBvcyAvKjogQ29udHJvbFBvc2l0aW9uKi8sIHBvc2l0aW9uT2Zmc2V0IC8qOiBQb3NpdGlvbk9mZnNldENvbnRyb2xQb3NpdGlvbiovKSAvKjogc3RyaW5nKi97XG4gIGNvbnN0IHRyYW5zbGF0aW9uID0gZ2V0VHJhbnNsYXRpb24oY29udHJvbFBvcywgcG9zaXRpb25PZmZzZXQsICcnKTtcbiAgcmV0dXJuIHRyYW5zbGF0aW9uO1xufVxuZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb24oX3JlZiAvKjo6ICovLCBwb3NpdGlvbk9mZnNldCAvKjogUG9zaXRpb25PZmZzZXRDb250cm9sUG9zaXRpb24qLywgdW5pdFN1ZmZpeCAvKjogc3RyaW5nKi8pIC8qOiBzdHJpbmcqL3tcbiAgbGV0IHtcbiAgICB4LFxuICAgIHlcbiAgfSAvKjogQ29udHJvbFBvc2l0aW9uKi8gPSBfcmVmIC8qOiBDb250cm9sUG9zaXRpb24qLztcbiAgbGV0IHRyYW5zbGF0aW9uID0gXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHgpLmNvbmNhdCh1bml0U3VmZml4LCBcIixcIikuY29uY2F0KHkpLmNvbmNhdCh1bml0U3VmZml4LCBcIilcIik7XG4gIGlmIChwb3NpdGlvbk9mZnNldCkge1xuICAgIGNvbnN0IGRlZmF1bHRYID0gXCJcIi5jb25jYXQodHlwZW9mIHBvc2l0aW9uT2Zmc2V0LnggPT09ICdzdHJpbmcnID8gcG9zaXRpb25PZmZzZXQueCA6IHBvc2l0aW9uT2Zmc2V0LnggKyB1bml0U3VmZml4KTtcbiAgICBjb25zdCBkZWZhdWx0WSA9IFwiXCIuY29uY2F0KHR5cGVvZiBwb3NpdGlvbk9mZnNldC55ID09PSAnc3RyaW5nJyA/IHBvc2l0aW9uT2Zmc2V0LnkgOiBwb3NpdGlvbk9mZnNldC55ICsgdW5pdFN1ZmZpeCk7XG4gICAgdHJhbnNsYXRpb24gPSBcInRyYW5zbGF0ZShcIi5jb25jYXQoZGVmYXVsdFgsIFwiLCBcIikuY29uY2F0KGRlZmF1bHRZLCBcIilcIikgKyB0cmFuc2xhdGlvbjtcbiAgfVxuICByZXR1cm4gdHJhbnNsYXRpb247XG59XG5mdW5jdGlvbiBnZXRUb3VjaChlIC8qOiBNb3VzZVRvdWNoRXZlbnQqLywgaWRlbnRpZmllciAvKjogbnVtYmVyKi8pIC8qOiA/e2NsaWVudFg6IG51bWJlciwgY2xpZW50WTogbnVtYmVyfSove1xuICByZXR1cm4gZS50YXJnZXRUb3VjaGVzICYmICgwLCBfc2hpbXMuZmluZEluQXJyYXkpKGUudGFyZ2V0VG91Y2hlcywgdCA9PiBpZGVudGlmaWVyID09PSB0LmlkZW50aWZpZXIpIHx8IGUuY2hhbmdlZFRvdWNoZXMgJiYgKDAsIF9zaGltcy5maW5kSW5BcnJheSkoZS5jaGFuZ2VkVG91Y2hlcywgdCA9PiBpZGVudGlmaWVyID09PSB0LmlkZW50aWZpZXIpO1xufVxuZnVuY3Rpb24gZ2V0VG91Y2hJZGVudGlmaWVyKGUgLyo6IE1vdXNlVG91Y2hFdmVudCovKSAvKjogP251bWJlciove1xuICBpZiAoZS50YXJnZXRUb3VjaGVzICYmIGUudGFyZ2V0VG91Y2hlc1swXSkgcmV0dXJuIGUudGFyZ2V0VG91Y2hlc1swXS5pZGVudGlmaWVyO1xuICBpZiAoZS5jaGFuZ2VkVG91Y2hlcyAmJiBlLmNoYW5nZWRUb3VjaGVzWzBdKSByZXR1cm4gZS5jaGFuZ2VkVG91Y2hlc1swXS5pZGVudGlmaWVyO1xufVxuXG4vLyBVc2VyLXNlbGVjdCBIYWNrczpcbi8vXG4vLyBVc2VmdWwgZm9yIHByZXZlbnRpbmcgYmx1ZSBoaWdobGlnaHRzIGFsbCBvdmVyIGV2ZXJ5dGhpbmcgd2hlbiBkcmFnZ2luZy5cblxuLy8gTm90ZSB3ZSdyZSBwYXNzaW5nIGBkb2N1bWVudGAgYi9jIHdlIGNvdWxkIGJlIGlmcmFtZWRcbmZ1bmN0aW9uIGFkZFVzZXJTZWxlY3RTdHlsZXMoZG9jIC8qOiA/RG9jdW1lbnQqLykge1xuICBpZiAoIWRvYykgcmV0dXJuO1xuICBsZXQgc3R5bGVFbCA9IGRvYy5nZXRFbGVtZW50QnlJZCgncmVhY3QtZHJhZ2dhYmxlLXN0eWxlLWVsJyk7XG4gIGlmICghc3R5bGVFbCkge1xuICAgIHN0eWxlRWwgPSBkb2MuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBzdHlsZUVsLnR5cGUgPSAndGV4dC9jc3MnO1xuICAgIHN0eWxlRWwuaWQgPSAncmVhY3QtZHJhZ2dhYmxlLXN0eWxlLWVsJztcbiAgICBzdHlsZUVsLmlubmVySFRNTCA9ICcucmVhY3QtZHJhZ2dhYmxlLXRyYW5zcGFyZW50LXNlbGVjdGlvbiAqOjotbW96LXNlbGVjdGlvbiB7YWxsOiBpbmhlcml0O31cXG4nO1xuICAgIHN0eWxlRWwuaW5uZXJIVE1MICs9ICcucmVhY3QtZHJhZ2dhYmxlLXRyYW5zcGFyZW50LXNlbGVjdGlvbiAqOjpzZWxlY3Rpb24ge2FsbDogaW5oZXJpdDt9XFxuJztcbiAgICBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChzdHlsZUVsKTtcbiAgfVxuICBpZiAoZG9jLmJvZHkpIGFkZENsYXNzTmFtZShkb2MuYm9keSwgJ3JlYWN0LWRyYWdnYWJsZS10cmFuc3BhcmVudC1zZWxlY3Rpb24nKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVVzZXJTZWxlY3RTdHlsZXMoZG9jIC8qOiA/RG9jdW1lbnQqLykge1xuICBpZiAoIWRvYykgcmV0dXJuO1xuICB0cnkge1xuICAgIGlmIChkb2MuYm9keSkgcmVtb3ZlQ2xhc3NOYW1lKGRvYy5ib2R5LCAncmVhY3QtZHJhZ2dhYmxlLXRyYW5zcGFyZW50LXNlbGVjdGlvbicpO1xuICAgIC8vICRGbG93SWdub3JlOiBJRVxuICAgIGlmIChkb2Muc2VsZWN0aW9uKSB7XG4gICAgICAvLyAkRmxvd0lnbm9yZTogSUVcbiAgICAgIGRvYy5zZWxlY3Rpb24uZW1wdHkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVtb3ZlIHNlbGVjdGlvbiBjYXVzZWQgYnkgc2Nyb2xsLCB1bmxlc3MgaXQncyBhIGZvY3VzZWQgaW5wdXRcbiAgICAgIC8vICh3ZSB1c2UgZG9jLmRlZmF1bHRWaWV3IGluIGNhc2Ugd2UncmUgaW4gYW4gaWZyYW1lKVxuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gKGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3cpLmdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKHNlbGVjdGlvbiAmJiBzZWxlY3Rpb24udHlwZSAhPT0gJ0NhcmV0Jykge1xuICAgICAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gcHJvYmFibHkgSUVcbiAgfVxufVxuZnVuY3Rpb24gYWRkQ2xhc3NOYW1lKGVsIC8qOiBIVE1MRWxlbWVudCovLCBjbGFzc05hbWUgLyo6IHN0cmluZyovKSB7XG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBlbC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFlbC5jbGFzc05hbWUubWF0Y2gobmV3IFJlZ0V4cChcIig/Ol58XFxcXHMpXCIuY29uY2F0KGNsYXNzTmFtZSwgXCIoPyFcXFxcUylcIikpKSkge1xuICAgICAgZWwuY2xhc3NOYW1lICs9IFwiIFwiLmNvbmNhdChjbGFzc05hbWUpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3NOYW1lKGVsIC8qOiBIVE1MRWxlbWVudCovLCBjbGFzc05hbWUgLyo6IHN0cmluZyovKSB7XG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgZWwuY2xhc3NOYW1lID0gZWwuY2xhc3NOYW1lLnJlcGxhY2UobmV3IFJlZ0V4cChcIig/Ol58XFxcXHMpXCIuY29uY2F0KGNsYXNzTmFtZSwgXCIoPyFcXFxcUylcIiksICdnJyksICcnKTtcbiAgfVxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-draggable/build/cjs/utils/domFns.js\n"));

/***/ }),

/***/ "./node_modules/react-draggable/build/cjs/utils/getPrefix.js":
/*!*******************************************************************!*\
  !*** ./node_modules/react-draggable/build/cjs/utils/getPrefix.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.browserPrefixToKey = browserPrefixToKey;\nexports.browserPrefixToStyle = browserPrefixToStyle;\nexports[\"default\"] = void 0;\nexports.getPrefix = getPrefix;\nconst prefixes = ['Moz', 'Webkit', 'O', 'ms'];\nfunction getPrefix() /*: string*/{\n  var _window$document;\n  let prop /*: string*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'transform';\n  // Ensure we're running in an environment where there is actually a global\n  // `window` obj\n  if (typeof window === 'undefined') return '';\n\n  // If we're in a pseudo-browser server-side environment, this access\n  // path may not exist, so bail out if it doesn't.\n  const style = (_window$document = window.document) === null || _window$document === void 0 || (_window$document = _window$document.documentElement) === null || _window$document === void 0 ? void 0 : _window$document.style;\n  if (!style) return '';\n  if (prop in style) return '';\n  for (let i = 0; i < prefixes.length; i++) {\n    if (browserPrefixToKey(prop, prefixes[i]) in style) return prefixes[i];\n  }\n  return '';\n}\nfunction browserPrefixToKey(prop /*: string*/, prefix /*: string*/) /*: string*/{\n  return prefix ? \"\".concat(prefix).concat(kebabToTitleCase(prop)) : prop;\n}\nfunction browserPrefixToStyle(prop /*: string*/, prefix /*: string*/) /*: string*/{\n  return prefix ? \"-\".concat(prefix.toLowerCase(), \"-\").concat(prop) : prop;\n}\nfunction kebabToTitleCase(str /*: string*/) /*: string*/{\n  let out = '';\n  let shouldCapitalize = true;\n  for (let i = 0; i < str.length; i++) {\n    if (shouldCapitalize) {\n      out += str[i].toUpperCase();\n      shouldCapitalize = false;\n    } else if (str[i] === '-') {\n      shouldCapitalize = true;\n    } else {\n      out += str[i];\n    }\n  }\n  return out;\n}\n\n// Default export is the prefix itself, like 'Moz', 'Webkit', etc\n// Note that you may have to re-test for certain things; for instance, Chrome 50\n// can handle unprefixed `transform`, but not unprefixed `user-select`\nvar _default = exports[\"default\"] = (getPrefix() /*: string*/);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy91dGlscy9nZXRQcmVmaXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMEJBQTBCO0FBQzFCLDRCQUE0QjtBQUM1QixrQkFBZTtBQUNmLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQSxlQUFlLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL3V0aWxzL2dldFByZWZpeC5qcz80NGEzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5icm93c2VyUHJlZml4VG9LZXkgPSBicm93c2VyUHJlZml4VG9LZXk7XG5leHBvcnRzLmJyb3dzZXJQcmVmaXhUb1N0eWxlID0gYnJvd3NlclByZWZpeFRvU3R5bGU7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5leHBvcnRzLmdldFByZWZpeCA9IGdldFByZWZpeDtcbmNvbnN0IHByZWZpeGVzID0gWydNb3onLCAnV2Via2l0JywgJ08nLCAnbXMnXTtcbmZ1bmN0aW9uIGdldFByZWZpeCgpIC8qOiBzdHJpbmcqL3tcbiAgdmFyIF93aW5kb3ckZG9jdW1lbnQ7XG4gIGxldCBwcm9wIC8qOiBzdHJpbmcqLyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ3RyYW5zZm9ybSc7XG4gIC8vIEVuc3VyZSB3ZSdyZSBydW5uaW5nIGluIGFuIGVudmlyb25tZW50IHdoZXJlIHRoZXJlIGlzIGFjdHVhbGx5IGEgZ2xvYmFsXG4gIC8vIGB3aW5kb3dgIG9ialxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiAnJztcblxuICAvLyBJZiB3ZSdyZSBpbiBhIHBzZXVkby1icm93c2VyIHNlcnZlci1zaWRlIGVudmlyb25tZW50LCB0aGlzIGFjY2Vzc1xuICAvLyBwYXRoIG1heSBub3QgZXhpc3QsIHNvIGJhaWwgb3V0IGlmIGl0IGRvZXNuJ3QuXG4gIGNvbnN0IHN0eWxlID0gKF93aW5kb3ckZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQpID09PSBudWxsIHx8IF93aW5kb3ckZG9jdW1lbnQgPT09IHZvaWQgMCB8fCAoX3dpbmRvdyRkb2N1bWVudCA9IF93aW5kb3ckZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfd2luZG93JGRvY3VtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfd2luZG93JGRvY3VtZW50LnN0eWxlO1xuICBpZiAoIXN0eWxlKSByZXR1cm4gJyc7XG4gIGlmIChwcm9wIGluIHN0eWxlKSByZXR1cm4gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYnJvd3NlclByZWZpeFRvS2V5KHByb3AsIHByZWZpeGVzW2ldKSBpbiBzdHlsZSkgcmV0dXJuIHByZWZpeGVzW2ldO1xuICB9XG4gIHJldHVybiAnJztcbn1cbmZ1bmN0aW9uIGJyb3dzZXJQcmVmaXhUb0tleShwcm9wIC8qOiBzdHJpbmcqLywgcHJlZml4IC8qOiBzdHJpbmcqLykgLyo6IHN0cmluZyove1xuICByZXR1cm4gcHJlZml4ID8gXCJcIi5jb25jYXQocHJlZml4KS5jb25jYXQoa2ViYWJUb1RpdGxlQ2FzZShwcm9wKSkgOiBwcm9wO1xufVxuZnVuY3Rpb24gYnJvd3NlclByZWZpeFRvU3R5bGUocHJvcCAvKjogc3RyaW5nKi8sIHByZWZpeCAvKjogc3RyaW5nKi8pIC8qOiBzdHJpbmcqL3tcbiAgcmV0dXJuIHByZWZpeCA/IFwiLVwiLmNvbmNhdChwcmVmaXgudG9Mb3dlckNhc2UoKSwgXCItXCIpLmNvbmNhdChwcm9wKSA6IHByb3A7XG59XG5mdW5jdGlvbiBrZWJhYlRvVGl0bGVDYXNlKHN0ciAvKjogc3RyaW5nKi8pIC8qOiBzdHJpbmcqL3tcbiAgbGV0IG91dCA9ICcnO1xuICBsZXQgc2hvdWxkQ2FwaXRhbGl6ZSA9IHRydWU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHNob3VsZENhcGl0YWxpemUpIHtcbiAgICAgIG91dCArPSBzdHJbaV0udG9VcHBlckNhc2UoKTtcbiAgICAgIHNob3VsZENhcGl0YWxpemUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHN0cltpXSA9PT0gJy0nKSB7XG4gICAgICBzaG91bGRDYXBpdGFsaXplID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9IHN0cltpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuLy8gRGVmYXVsdCBleHBvcnQgaXMgdGhlIHByZWZpeCBpdHNlbGYsIGxpa2UgJ01veicsICdXZWJraXQnLCBldGNcbi8vIE5vdGUgdGhhdCB5b3UgbWF5IGhhdmUgdG8gcmUtdGVzdCBmb3IgY2VydGFpbiB0aGluZ3M7IGZvciBpbnN0YW5jZSwgQ2hyb21lIDUwXG4vLyBjYW4gaGFuZGxlIHVucHJlZml4ZWQgYHRyYW5zZm9ybWAsIGJ1dCBub3QgdW5wcmVmaXhlZCBgdXNlci1zZWxlY3RgXG52YXIgX2RlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQgPSAoZ2V0UHJlZml4KCkgLyo6IHN0cmluZyovKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-draggable/build/cjs/utils/getPrefix.js\n"));

/***/ }),

/***/ "./node_modules/react-draggable/build/cjs/utils/log.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-draggable/build/cjs/utils/log.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = log;\n/*eslint no-console:0*/\nfunction log() {\n  if (false) {}\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy91dGlscy9sb2cuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZjtBQUNBO0FBQ0EsTUFBTSxLQUFTLEVBQUUsRUFBMEI7QUFDM0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRyYWdnYWJsZS9idWlsZC9janMvdXRpbHMvbG9nLmpzP2UwNjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBsb2c7XG4vKmVzbGludCBuby1jb25zb2xlOjAqL1xuZnVuY3Rpb24gbG9nKCkge1xuICBpZiAodW5kZWZpbmVkKSBjb25zb2xlLmxvZyguLi5hcmd1bWVudHMpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-draggable/build/cjs/utils/log.js\n"));

/***/ }),

/***/ "./node_modules/react-draggable/build/cjs/utils/positionFns.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react-draggable/build/cjs/utils/positionFns.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.canDragX = canDragX;\nexports.canDragY = canDragY;\nexports.createCoreData = createCoreData;\nexports.createDraggableData = createDraggableData;\nexports.getBoundPosition = getBoundPosition;\nexports.getControlPosition = getControlPosition;\nexports.snapToGrid = snapToGrid;\nvar _shims = __webpack_require__(/*! ./shims */ \"./node_modules/react-draggable/build/cjs/utils/shims.js\");\nvar _domFns = __webpack_require__(/*! ./domFns */ \"./node_modules/react-draggable/build/cjs/utils/domFns.js\");\n/*:: import type Draggable from '../Draggable';*/\n/*:: import type {Bounds, ControlPosition, DraggableData, MouseTouchEvent} from './types';*/\n/*:: import type DraggableCore from '../DraggableCore';*/\nfunction getBoundPosition(draggable /*: Draggable*/, x /*: number*/, y /*: number*/) /*: [number, number]*/{\n  // If no bounds, short-circuit and move on\n  if (!draggable.props.bounds) return [x, y];\n\n  // Clone new bounds\n  let {\n    bounds\n  } = draggable.props;\n  bounds = typeof bounds === 'string' ? bounds : cloneBounds(bounds);\n  const node = findDOMNode(draggable);\n  if (typeof bounds === 'string') {\n    const {\n      ownerDocument\n    } = node;\n    const ownerWindow = ownerDocument.defaultView;\n    let boundNode;\n    if (bounds === 'parent') {\n      boundNode = node.parentNode;\n    } else {\n      boundNode = ownerDocument.querySelector(bounds);\n    }\n    if (!(boundNode instanceof ownerWindow.HTMLElement)) {\n      throw new Error('Bounds selector \"' + bounds + '\" could not find an element.');\n    }\n    const boundNodeEl /*: HTMLElement*/ = boundNode; // for Flow, can't seem to refine correctly\n    const nodeStyle = ownerWindow.getComputedStyle(node);\n    const boundNodeStyle = ownerWindow.getComputedStyle(boundNodeEl);\n    // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.\n    bounds = {\n      left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.marginLeft),\n      top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.marginTop),\n      right: (0, _domFns.innerWidth)(boundNodeEl) - (0, _domFns.outerWidth)(node) - node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingRight) - (0, _shims.int)(nodeStyle.marginRight),\n      bottom: (0, _domFns.innerHeight)(boundNodeEl) - (0, _domFns.outerHeight)(node) - node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingBottom) - (0, _shims.int)(nodeStyle.marginBottom)\n    };\n  }\n\n  // Keep x and y below right and bottom limits...\n  if ((0, _shims.isNum)(bounds.right)) x = Math.min(x, bounds.right);\n  if ((0, _shims.isNum)(bounds.bottom)) y = Math.min(y, bounds.bottom);\n\n  // But above left and top limits.\n  if ((0, _shims.isNum)(bounds.left)) x = Math.max(x, bounds.left);\n  if ((0, _shims.isNum)(bounds.top)) y = Math.max(y, bounds.top);\n  return [x, y];\n}\nfunction snapToGrid(grid /*: [number, number]*/, pendingX /*: number*/, pendingY /*: number*/) /*: [number, number]*/{\n  const x = Math.round(pendingX / grid[0]) * grid[0];\n  const y = Math.round(pendingY / grid[1]) * grid[1];\n  return [x, y];\n}\nfunction canDragX(draggable /*: Draggable*/) /*: boolean*/{\n  return draggable.props.axis === 'both' || draggable.props.axis === 'x';\n}\nfunction canDragY(draggable /*: Draggable*/) /*: boolean*/{\n  return draggable.props.axis === 'both' || draggable.props.axis === 'y';\n}\n\n// Get {x, y} positions from event.\nfunction getControlPosition(e /*: MouseTouchEvent*/, touchIdentifier /*: ?number*/, draggableCore /*: DraggableCore*/) /*: ?ControlPosition*/{\n  const touchObj = typeof touchIdentifier === 'number' ? (0, _domFns.getTouch)(e, touchIdentifier) : null;\n  if (typeof touchIdentifier === 'number' && !touchObj) return null; // not the right touch\n  const node = findDOMNode(draggableCore);\n  // User can provide an offsetParent if desired.\n  const offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;\n  return (0, _domFns.offsetXYFromParent)(touchObj || e, offsetParent, draggableCore.props.scale);\n}\n\n// Create an data object exposed by <DraggableCore>'s events\nfunction createCoreData(draggable /*: DraggableCore*/, x /*: number*/, y /*: number*/) /*: DraggableData*/{\n  const isStart = !(0, _shims.isNum)(draggable.lastX);\n  const node = findDOMNode(draggable);\n  if (isStart) {\n    // If this is our first move, use the x and y as last coords.\n    return {\n      node,\n      deltaX: 0,\n      deltaY: 0,\n      lastX: x,\n      lastY: y,\n      x,\n      y\n    };\n  } else {\n    // Otherwise calculate proper values.\n    return {\n      node,\n      deltaX: x - draggable.lastX,\n      deltaY: y - draggable.lastY,\n      lastX: draggable.lastX,\n      lastY: draggable.lastY,\n      x,\n      y\n    };\n  }\n}\n\n// Create an data exposed by <Draggable>'s events\nfunction createDraggableData(draggable /*: Draggable*/, coreData /*: DraggableData*/) /*: DraggableData*/{\n  const scale = draggable.props.scale;\n  return {\n    node: coreData.node,\n    x: draggable.state.x + coreData.deltaX / scale,\n    y: draggable.state.y + coreData.deltaY / scale,\n    deltaX: coreData.deltaX / scale,\n    deltaY: coreData.deltaY / scale,\n    lastX: draggable.state.x,\n    lastY: draggable.state.y\n  };\n}\n\n// A lot faster than stringify/parse\nfunction cloneBounds(bounds /*: Bounds*/) /*: Bounds*/{\n  return {\n    left: bounds.left,\n    top: bounds.top,\n    right: bounds.right,\n    bottom: bounds.bottom\n  };\n}\nfunction findDOMNode(draggable /*: Draggable | DraggableCore*/) /*: HTMLElement*/{\n  const node = draggable.findDOMNode();\n  if (!node) {\n    throw new Error('<DraggableCore>: Unmounted during event!');\n  }\n  // $FlowIgnore we can't assert on HTMLElement due to tests... FIXME\n  return node;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy91dGlscy9wb3NpdGlvbkZucy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLHNCQUFzQjtBQUN0QiwyQkFBMkI7QUFDM0Isd0JBQXdCO0FBQ3hCLDBCQUEwQjtBQUMxQixrQkFBa0I7QUFDbEIsYUFBYSxtQkFBTyxDQUFDLHdFQUFTO0FBQzlCLGNBQWMsbUJBQU8sQ0FBQywwRUFBVTtBQUNoQywrQ0FBK0M7QUFDL0Msa0JBQWtCLHlEQUF5RCxlQUFlO0FBQzFGLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxNQUFNO0FBQ2Q7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy91dGlscy9wb3NpdGlvbkZucy5qcz9hOWQ3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jYW5EcmFnWCA9IGNhbkRyYWdYO1xuZXhwb3J0cy5jYW5EcmFnWSA9IGNhbkRyYWdZO1xuZXhwb3J0cy5jcmVhdGVDb3JlRGF0YSA9IGNyZWF0ZUNvcmVEYXRhO1xuZXhwb3J0cy5jcmVhdGVEcmFnZ2FibGVEYXRhID0gY3JlYXRlRHJhZ2dhYmxlRGF0YTtcbmV4cG9ydHMuZ2V0Qm91bmRQb3NpdGlvbiA9IGdldEJvdW5kUG9zaXRpb247XG5leHBvcnRzLmdldENvbnRyb2xQb3NpdGlvbiA9IGdldENvbnRyb2xQb3NpdGlvbjtcbmV4cG9ydHMuc25hcFRvR3JpZCA9IHNuYXBUb0dyaWQ7XG52YXIgX3NoaW1zID0gcmVxdWlyZShcIi4vc2hpbXNcIik7XG52YXIgX2RvbUZucyA9IHJlcXVpcmUoXCIuL2RvbUZuc1wiKTtcbi8qOjogaW1wb3J0IHR5cGUgRHJhZ2dhYmxlIGZyb20gJy4uL0RyYWdnYWJsZSc7Ki9cbi8qOjogaW1wb3J0IHR5cGUge0JvdW5kcywgQ29udHJvbFBvc2l0aW9uLCBEcmFnZ2FibGVEYXRhLCBNb3VzZVRvdWNoRXZlbnR9IGZyb20gJy4vdHlwZXMnOyovXG4vKjo6IGltcG9ydCB0eXBlIERyYWdnYWJsZUNvcmUgZnJvbSAnLi4vRHJhZ2dhYmxlQ29yZSc7Ki9cbmZ1bmN0aW9uIGdldEJvdW5kUG9zaXRpb24oZHJhZ2dhYmxlIC8qOiBEcmFnZ2FibGUqLywgeCAvKjogbnVtYmVyKi8sIHkgLyo6IG51bWJlciovKSAvKjogW251bWJlciwgbnVtYmVyXSove1xuICAvLyBJZiBubyBib3VuZHMsIHNob3J0LWNpcmN1aXQgYW5kIG1vdmUgb25cbiAgaWYgKCFkcmFnZ2FibGUucHJvcHMuYm91bmRzKSByZXR1cm4gW3gsIHldO1xuXG4gIC8vIENsb25lIG5ldyBib3VuZHNcbiAgbGV0IHtcbiAgICBib3VuZHNcbiAgfSA9IGRyYWdnYWJsZS5wcm9wcztcbiAgYm91bmRzID0gdHlwZW9mIGJvdW5kcyA9PT0gJ3N0cmluZycgPyBib3VuZHMgOiBjbG9uZUJvdW5kcyhib3VuZHMpO1xuICBjb25zdCBub2RlID0gZmluZERPTU5vZGUoZHJhZ2dhYmxlKTtcbiAgaWYgKHR5cGVvZiBib3VuZHMgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3Qge1xuICAgICAgb3duZXJEb2N1bWVudFxuICAgIH0gPSBub2RlO1xuICAgIGNvbnN0IG93bmVyV2luZG93ID0gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICBsZXQgYm91bmROb2RlO1xuICAgIGlmIChib3VuZHMgPT09ICdwYXJlbnQnKSB7XG4gICAgICBib3VuZE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvdW5kTm9kZSA9IG93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3Rvcihib3VuZHMpO1xuICAgIH1cbiAgICBpZiAoIShib3VuZE5vZGUgaW5zdGFuY2VvZiBvd25lcldpbmRvdy5IVE1MRWxlbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQm91bmRzIHNlbGVjdG9yIFwiJyArIGJvdW5kcyArICdcIiBjb3VsZCBub3QgZmluZCBhbiBlbGVtZW50LicpO1xuICAgIH1cbiAgICBjb25zdCBib3VuZE5vZGVFbCAvKjogSFRNTEVsZW1lbnQqLyA9IGJvdW5kTm9kZTsgLy8gZm9yIEZsb3csIGNhbid0IHNlZW0gdG8gcmVmaW5lIGNvcnJlY3RseVxuICAgIGNvbnN0IG5vZGVTdHlsZSA9IG93bmVyV2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgY29uc3QgYm91bmROb2RlU3R5bGUgPSBvd25lcldpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGJvdW5kTm9kZUVsKTtcbiAgICAvLyBDb21wdXRlIGJvdW5kcy4gVGhpcyBpcyBhIHBhaW4gd2l0aCBwYWRkaW5nIGFuZCBvZmZzZXRzIGJ1dCB0aGlzIGdldHMgaXQgZXhhY3RseSByaWdodC5cbiAgICBib3VuZHMgPSB7XG4gICAgICBsZWZ0OiAtbm9kZS5vZmZzZXRMZWZ0ICsgKDAsIF9zaGltcy5pbnQpKGJvdW5kTm9kZVN0eWxlLnBhZGRpbmdMZWZ0KSArICgwLCBfc2hpbXMuaW50KShub2RlU3R5bGUubWFyZ2luTGVmdCksXG4gICAgICB0b3A6IC1ub2RlLm9mZnNldFRvcCArICgwLCBfc2hpbXMuaW50KShib3VuZE5vZGVTdHlsZS5wYWRkaW5nVG9wKSArICgwLCBfc2hpbXMuaW50KShub2RlU3R5bGUubWFyZ2luVG9wKSxcbiAgICAgIHJpZ2h0OiAoMCwgX2RvbUZucy5pbm5lcldpZHRoKShib3VuZE5vZGVFbCkgLSAoMCwgX2RvbUZucy5vdXRlcldpZHRoKShub2RlKSAtIG5vZGUub2Zmc2V0TGVmdCArICgwLCBfc2hpbXMuaW50KShib3VuZE5vZGVTdHlsZS5wYWRkaW5nUmlnaHQpIC0gKDAsIF9zaGltcy5pbnQpKG5vZGVTdHlsZS5tYXJnaW5SaWdodCksXG4gICAgICBib3R0b206ICgwLCBfZG9tRm5zLmlubmVySGVpZ2h0KShib3VuZE5vZGVFbCkgLSAoMCwgX2RvbUZucy5vdXRlckhlaWdodCkobm9kZSkgLSBub2RlLm9mZnNldFRvcCArICgwLCBfc2hpbXMuaW50KShib3VuZE5vZGVTdHlsZS5wYWRkaW5nQm90dG9tKSAtICgwLCBfc2hpbXMuaW50KShub2RlU3R5bGUubWFyZ2luQm90dG9tKVxuICAgIH07XG4gIH1cblxuICAvLyBLZWVwIHggYW5kIHkgYmVsb3cgcmlnaHQgYW5kIGJvdHRvbSBsaW1pdHMuLi5cbiAgaWYgKCgwLCBfc2hpbXMuaXNOdW0pKGJvdW5kcy5yaWdodCkpIHggPSBNYXRoLm1pbih4LCBib3VuZHMucmlnaHQpO1xuICBpZiAoKDAsIF9zaGltcy5pc051bSkoYm91bmRzLmJvdHRvbSkpIHkgPSBNYXRoLm1pbih5LCBib3VuZHMuYm90dG9tKTtcblxuICAvLyBCdXQgYWJvdmUgbGVmdCBhbmQgdG9wIGxpbWl0cy5cbiAgaWYgKCgwLCBfc2hpbXMuaXNOdW0pKGJvdW5kcy5sZWZ0KSkgeCA9IE1hdGgubWF4KHgsIGJvdW5kcy5sZWZ0KTtcbiAgaWYgKCgwLCBfc2hpbXMuaXNOdW0pKGJvdW5kcy50b3ApKSB5ID0gTWF0aC5tYXgoeSwgYm91bmRzLnRvcCk7XG4gIHJldHVybiBbeCwgeV07XG59XG5mdW5jdGlvbiBzbmFwVG9HcmlkKGdyaWQgLyo6IFtudW1iZXIsIG51bWJlcl0qLywgcGVuZGluZ1ggLyo6IG51bWJlciovLCBwZW5kaW5nWSAvKjogbnVtYmVyKi8pIC8qOiBbbnVtYmVyLCBudW1iZXJdKi97XG4gIGNvbnN0IHggPSBNYXRoLnJvdW5kKHBlbmRpbmdYIC8gZ3JpZFswXSkgKiBncmlkWzBdO1xuICBjb25zdCB5ID0gTWF0aC5yb3VuZChwZW5kaW5nWSAvIGdyaWRbMV0pICogZ3JpZFsxXTtcbiAgcmV0dXJuIFt4LCB5XTtcbn1cbmZ1bmN0aW9uIGNhbkRyYWdYKGRyYWdnYWJsZSAvKjogRHJhZ2dhYmxlKi8pIC8qOiBib29sZWFuKi97XG4gIHJldHVybiBkcmFnZ2FibGUucHJvcHMuYXhpcyA9PT0gJ2JvdGgnIHx8IGRyYWdnYWJsZS5wcm9wcy5heGlzID09PSAneCc7XG59XG5mdW5jdGlvbiBjYW5EcmFnWShkcmFnZ2FibGUgLyo6IERyYWdnYWJsZSovKSAvKjogYm9vbGVhbiove1xuICByZXR1cm4gZHJhZ2dhYmxlLnByb3BzLmF4aXMgPT09ICdib3RoJyB8fCBkcmFnZ2FibGUucHJvcHMuYXhpcyA9PT0gJ3knO1xufVxuXG4vLyBHZXQge3gsIHl9IHBvc2l0aW9ucyBmcm9tIGV2ZW50LlxuZnVuY3Rpb24gZ2V0Q29udHJvbFBvc2l0aW9uKGUgLyo6IE1vdXNlVG91Y2hFdmVudCovLCB0b3VjaElkZW50aWZpZXIgLyo6ID9udW1iZXIqLywgZHJhZ2dhYmxlQ29yZSAvKjogRHJhZ2dhYmxlQ29yZSovKSAvKjogP0NvbnRyb2xQb3NpdGlvbiove1xuICBjb25zdCB0b3VjaE9iaiA9IHR5cGVvZiB0b3VjaElkZW50aWZpZXIgPT09ICdudW1iZXInID8gKDAsIF9kb21GbnMuZ2V0VG91Y2gpKGUsIHRvdWNoSWRlbnRpZmllcikgOiBudWxsO1xuICBpZiAodHlwZW9mIHRvdWNoSWRlbnRpZmllciA9PT0gJ251bWJlcicgJiYgIXRvdWNoT2JqKSByZXR1cm4gbnVsbDsgLy8gbm90IHRoZSByaWdodCB0b3VjaFxuICBjb25zdCBub2RlID0gZmluZERPTU5vZGUoZHJhZ2dhYmxlQ29yZSk7XG4gIC8vIFVzZXIgY2FuIHByb3ZpZGUgYW4gb2Zmc2V0UGFyZW50IGlmIGRlc2lyZWQuXG4gIGNvbnN0IG9mZnNldFBhcmVudCA9IGRyYWdnYWJsZUNvcmUucHJvcHMub2Zmc2V0UGFyZW50IHx8IG5vZGUub2Zmc2V0UGFyZW50IHx8IG5vZGUub3duZXJEb2N1bWVudC5ib2R5O1xuICByZXR1cm4gKDAsIF9kb21GbnMub2Zmc2V0WFlGcm9tUGFyZW50KSh0b3VjaE9iaiB8fCBlLCBvZmZzZXRQYXJlbnQsIGRyYWdnYWJsZUNvcmUucHJvcHMuc2NhbGUpO1xufVxuXG4vLyBDcmVhdGUgYW4gZGF0YSBvYmplY3QgZXhwb3NlZCBieSA8RHJhZ2dhYmxlQ29yZT4ncyBldmVudHNcbmZ1bmN0aW9uIGNyZWF0ZUNvcmVEYXRhKGRyYWdnYWJsZSAvKjogRHJhZ2dhYmxlQ29yZSovLCB4IC8qOiBudW1iZXIqLywgeSAvKjogbnVtYmVyKi8pIC8qOiBEcmFnZ2FibGVEYXRhKi97XG4gIGNvbnN0IGlzU3RhcnQgPSAhKDAsIF9zaGltcy5pc051bSkoZHJhZ2dhYmxlLmxhc3RYKTtcbiAgY29uc3Qgbm9kZSA9IGZpbmRET01Ob2RlKGRyYWdnYWJsZSk7XG4gIGlmIChpc1N0YXJ0KSB7XG4gICAgLy8gSWYgdGhpcyBpcyBvdXIgZmlyc3QgbW92ZSwgdXNlIHRoZSB4IGFuZCB5IGFzIGxhc3QgY29vcmRzLlxuICAgIHJldHVybiB7XG4gICAgICBub2RlLFxuICAgICAgZGVsdGFYOiAwLFxuICAgICAgZGVsdGFZOiAwLFxuICAgICAgbGFzdFg6IHgsXG4gICAgICBsYXN0WTogeSxcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBPdGhlcndpc2UgY2FsY3VsYXRlIHByb3BlciB2YWx1ZXMuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5vZGUsXG4gICAgICBkZWx0YVg6IHggLSBkcmFnZ2FibGUubGFzdFgsXG4gICAgICBkZWx0YVk6IHkgLSBkcmFnZ2FibGUubGFzdFksXG4gICAgICBsYXN0WDogZHJhZ2dhYmxlLmxhc3RYLFxuICAgICAgbGFzdFk6IGRyYWdnYWJsZS5sYXN0WSxcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgfVxufVxuXG4vLyBDcmVhdGUgYW4gZGF0YSBleHBvc2VkIGJ5IDxEcmFnZ2FibGU+J3MgZXZlbnRzXG5mdW5jdGlvbiBjcmVhdGVEcmFnZ2FibGVEYXRhKGRyYWdnYWJsZSAvKjogRHJhZ2dhYmxlKi8sIGNvcmVEYXRhIC8qOiBEcmFnZ2FibGVEYXRhKi8pIC8qOiBEcmFnZ2FibGVEYXRhKi97XG4gIGNvbnN0IHNjYWxlID0gZHJhZ2dhYmxlLnByb3BzLnNjYWxlO1xuICByZXR1cm4ge1xuICAgIG5vZGU6IGNvcmVEYXRhLm5vZGUsXG4gICAgeDogZHJhZ2dhYmxlLnN0YXRlLnggKyBjb3JlRGF0YS5kZWx0YVggLyBzY2FsZSxcbiAgICB5OiBkcmFnZ2FibGUuc3RhdGUueSArIGNvcmVEYXRhLmRlbHRhWSAvIHNjYWxlLFxuICAgIGRlbHRhWDogY29yZURhdGEuZGVsdGFYIC8gc2NhbGUsXG4gICAgZGVsdGFZOiBjb3JlRGF0YS5kZWx0YVkgLyBzY2FsZSxcbiAgICBsYXN0WDogZHJhZ2dhYmxlLnN0YXRlLngsXG4gICAgbGFzdFk6IGRyYWdnYWJsZS5zdGF0ZS55XG4gIH07XG59XG5cbi8vIEEgbG90IGZhc3RlciB0aGFuIHN0cmluZ2lmeS9wYXJzZVxuZnVuY3Rpb24gY2xvbmVCb3VuZHMoYm91bmRzIC8qOiBCb3VuZHMqLykgLyo6IEJvdW5kcyove1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IGJvdW5kcy5sZWZ0LFxuICAgIHRvcDogYm91bmRzLnRvcCxcbiAgICByaWdodDogYm91bmRzLnJpZ2h0LFxuICAgIGJvdHRvbTogYm91bmRzLmJvdHRvbVxuICB9O1xufVxuZnVuY3Rpb24gZmluZERPTU5vZGUoZHJhZ2dhYmxlIC8qOiBEcmFnZ2FibGUgfCBEcmFnZ2FibGVDb3JlKi8pIC8qOiBIVE1MRWxlbWVudCove1xuICBjb25zdCBub2RlID0gZHJhZ2dhYmxlLmZpbmRET01Ob2RlKCk7XG4gIGlmICghbm9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignPERyYWdnYWJsZUNvcmU+OiBVbm1vdW50ZWQgZHVyaW5nIGV2ZW50IScpO1xuICB9XG4gIC8vICRGbG93SWdub3JlIHdlIGNhbid0IGFzc2VydCBvbiBIVE1MRWxlbWVudCBkdWUgdG8gdGVzdHMuLi4gRklYTUVcbiAgcmV0dXJuIG5vZGU7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-draggable/build/cjs/utils/positionFns.js\n"));

/***/ }),

/***/ "./node_modules/react-draggable/build/cjs/utils/shims.js":
/*!***************************************************************!*\
  !*** ./node_modules/react-draggable/build/cjs/utils/shims.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.dontSetMe = dontSetMe;\nexports.findInArray = findInArray;\nexports.int = int;\nexports.isFunction = isFunction;\nexports.isNum = isNum;\n// @credits https://gist.github.com/rogozhnikoff/a43cfed27c41e4e68cdc\nfunction findInArray(array /*: Array<any> | TouchList*/, callback /*: Function*/) /*: any*/{\n  for (let i = 0, length = array.length; i < length; i++) {\n    if (callback.apply(callback, [array[i], i, array])) return array[i];\n  }\n}\nfunction isFunction(func /*: any*/) /*: boolean %checks*/{\n  // $FlowIgnore[method-unbinding]\n  return typeof func === 'function' || Object.prototype.toString.call(func) === '[object Function]';\n}\nfunction isNum(num /*: any*/) /*: boolean %checks*/{\n  return typeof num === 'number' && !isNaN(num);\n}\nfunction int(a /*: string*/) /*: number*/{\n  return parseInt(a, 10);\n}\nfunction dontSetMe(props /*: Object*/, propName /*: string*/, componentName /*: string*/) /*: ?Error*/{\n  if (props[propName]) {\n    return new Error(\"Invalid prop \".concat(propName, \" passed to \").concat(componentName, \" - do not set this, set it on the child.\"));\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy91dGlscy9zaGltcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixpQkFBaUI7QUFDakIsbUJBQW1CO0FBQ25CLFdBQVc7QUFDWCxrQkFBa0I7QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRyYWdnYWJsZS9idWlsZC9janMvdXRpbHMvc2hpbXMuanM/ZDllNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZG9udFNldE1lID0gZG9udFNldE1lO1xuZXhwb3J0cy5maW5kSW5BcnJheSA9IGZpbmRJbkFycmF5O1xuZXhwb3J0cy5pbnQgPSBpbnQ7XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuZXhwb3J0cy5pc051bSA9IGlzTnVtO1xuLy8gQGNyZWRpdHMgaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcm9nb3pobmlrb2ZmL2E0M2NmZWQyN2M0MWU0ZTY4Y2RjXG5mdW5jdGlvbiBmaW5kSW5BcnJheShhcnJheSAvKjogQXJyYXk8YW55PiB8IFRvdWNoTGlzdCovLCBjYWxsYmFjayAvKjogRnVuY3Rpb24qLykgLyo6IGFueSove1xuICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY2FsbGJhY2suYXBwbHkoY2FsbGJhY2ssIFthcnJheVtpXSwgaSwgYXJyYXldKSkgcmV0dXJuIGFycmF5W2ldO1xuICB9XG59XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGZ1bmMgLyo6IGFueSovKSAvKjogYm9vbGVhbiAlY2hlY2tzKi97XG4gIC8vICRGbG93SWdub3JlW21ldGhvZC11bmJpbmRpbmddXG4gIHJldHVybiB0eXBlb2YgZnVuYyA9PT0gJ2Z1bmN0aW9uJyB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZnVuYykgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5mdW5jdGlvbiBpc051bShudW0gLyo6IGFueSovKSAvKjogYm9vbGVhbiAlY2hlY2tzKi97XG4gIHJldHVybiB0eXBlb2YgbnVtID09PSAnbnVtYmVyJyAmJiAhaXNOYU4obnVtKTtcbn1cbmZ1bmN0aW9uIGludChhIC8qOiBzdHJpbmcqLykgLyo6IG51bWJlciove1xuICByZXR1cm4gcGFyc2VJbnQoYSwgMTApO1xufVxuZnVuY3Rpb24gZG9udFNldE1lKHByb3BzIC8qOiBPYmplY3QqLywgcHJvcE5hbWUgLyo6IHN0cmluZyovLCBjb21wb25lbnROYW1lIC8qOiBzdHJpbmcqLykgLyo6ID9FcnJvciove1xuICBpZiAocHJvcHNbcHJvcE5hbWVdKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIkludmFsaWQgcHJvcCBcIi5jb25jYXQocHJvcE5hbWUsIFwiIHBhc3NlZCB0byBcIikuY29uY2F0KGNvbXBvbmVudE5hbWUsIFwiIC0gZG8gbm90IHNldCB0aGlzLCBzZXQgaXQgb24gdGhlIGNoaWxkLlwiKSk7XG4gIH1cbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-draggable/build/cjs/utils/shims.js\n"));

/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/** @license React v16.13.1\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;\nvar REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary\n// (unstable) APIs that have been removed. Can we remove the symbols?\n\nvar REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;\nvar REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\nvar REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;\nvar REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;\nvar REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\nvar REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;\nvar REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;\nvar REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;\nvar REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;\nvar REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;\n\nfunction isValidElementType(type) {\n  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);\n}\n\nfunction typeOf(object) {\n  if (typeof object === 'object' && object !== null) {\n    var $$typeof = object.$$typeof;\n\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE:\n        var type = object.type;\n\n        switch (type) {\n          case REACT_ASYNC_MODE_TYPE:\n          case REACT_CONCURRENT_MODE_TYPE:\n          case REACT_FRAGMENT_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_SUSPENSE_TYPE:\n            return type;\n\n          default:\n            var $$typeofType = type && type.$$typeof;\n\n            switch ($$typeofType) {\n              case REACT_CONTEXT_TYPE:\n              case REACT_FORWARD_REF_TYPE:\n              case REACT_LAZY_TYPE:\n              case REACT_MEMO_TYPE:\n              case REACT_PROVIDER_TYPE:\n                return $$typeofType;\n\n              default:\n                return $$typeof;\n            }\n\n        }\n\n      case REACT_PORTAL_TYPE:\n        return $$typeof;\n    }\n  }\n\n  return undefined;\n} // AsyncMode is deprecated along with isAsyncMode\n\nvar AsyncMode = REACT_ASYNC_MODE_TYPE;\nvar ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;\nvar ContextConsumer = REACT_CONTEXT_TYPE;\nvar ContextProvider = REACT_PROVIDER_TYPE;\nvar Element = REACT_ELEMENT_TYPE;\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Fragment = REACT_FRAGMENT_TYPE;\nvar Lazy = REACT_LAZY_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nvar Portal = REACT_PORTAL_TYPE;\nvar Profiler = REACT_PROFILER_TYPE;\nvar StrictMode = REACT_STRICT_MODE_TYPE;\nvar Suspense = REACT_SUSPENSE_TYPE;\nvar hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated\n\nfunction isAsyncMode(object) {\n  {\n    if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint\n\n      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');\n    }\n  }\n\n  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;\n}\nfunction isConcurrentMode(object) {\n  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;\n}\nfunction isContextConsumer(object) {\n  return typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isContextProvider(object) {\n  return typeOf(object) === REACT_PROVIDER_TYPE;\n}\nfunction isElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nfunction isForwardRef(object) {\n  return typeOf(object) === REACT_FORWARD_REF_TYPE;\n}\nfunction isFragment(object) {\n  return typeOf(object) === REACT_FRAGMENT_TYPE;\n}\nfunction isLazy(object) {\n  return typeOf(object) === REACT_LAZY_TYPE;\n}\nfunction isMemo(object) {\n  return typeOf(object) === REACT_MEMO_TYPE;\n}\nfunction isPortal(object) {\n  return typeOf(object) === REACT_PORTAL_TYPE;\n}\nfunction isProfiler(object) {\n  return typeOf(object) === REACT_PROFILER_TYPE;\n}\nfunction isStrictMode(object) {\n  return typeOf(object) === REACT_STRICT_MODE_TYPE;\n}\nfunction isSuspense(object) {\n  return typeOf(object) === REACT_SUSPENSE_TYPE;\n}\n\nexports.AsyncMode = AsyncMode;\nexports.ConcurrentMode = ConcurrentMode;\nexports.ContextConsumer = ContextConsumer;\nexports.ContextProvider = ContextProvider;\nexports.Element = Element;\nexports.ForwardRef = ForwardRef;\nexports.Fragment = Fragment;\nexports.Lazy = Lazy;\nexports.Memo = Memo;\nexports.Portal = Portal;\nexports.Profiler = Profiler;\nexports.StrictMode = StrictMode;\nexports.Suspense = Suspense;\nexports.isAsyncMode = isAsyncMode;\nexports.isConcurrentMode = isConcurrentMode;\nexports.isContextConsumer = isContextConsumer;\nexports.isContextProvider = isContextProvider;\nexports.isElement = isElement;\nexports.isForwardRef = isForwardRef;\nexports.isFragment = isFragment;\nexports.isLazy = isLazy;\nexports.isMemo = isMemo;\nexports.isPortal = isPortal;\nexports.isProfiler = isProfiler;\nexports.isStrictMode = isStrictMode;\nexports.isSuspense = isSuspense;\nexports.isValidElementType = isValidElementType;\nexports.typeOf = typeOf;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7Ozs7QUFJYixJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakIsc0JBQXNCO0FBQ3RCLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIsZUFBZTtBQUNmLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsWUFBWTtBQUNaLFlBQVk7QUFDWixjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsbUJBQW1CO0FBQ25CLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLGlCQUFpQjtBQUNqQixvQkFBb0I7QUFDcEIsa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZCxjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLGtCQUFrQjtBQUNsQixvQkFBb0I7QUFDcEIsa0JBQWtCO0FBQ2xCLDBCQUEwQjtBQUMxQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanM/NDk2YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjEzLjFcbiAqIHJlYWN0LWlzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpIDogMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpIDogMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpIDogMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKSA6IDB4ZWFjZTsgLy8gVE9ETzogV2UgZG9uJ3QgdXNlIEFzeW5jTW9kZSBvciBDb25jdXJyZW50TW9kZSBhbnltb3JlLiBUaGV5IHdlcmUgdGVtcG9yYXJ5XG4vLyAodW5zdGFibGUpIEFQSXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZC4gQ2FuIHdlIHJlbW92ZSB0aGUgc3ltYm9scz9cblxudmFyIFJFQUNUX0FTWU5DX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmFzeW5jX21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbmN1cnJlbnRfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpIDogMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKSA6IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJykgOiAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubGF6eScpIDogMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5ibG9jaycpIDogMHhlYWQ5O1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpIDogMHhlYWQ1O1xudmFyIFJFQUNUX1JFU1BPTkRFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucmVzcG9uZGVyJykgOiAweGVhZDY7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJykgOiAweGVhZDc7XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgLy8gTm90ZTogaXRzIHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIGlmIGl0J3MgYSBwb2x5ZmlsbC5cbiAgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1JFU1BPTkRFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1NDT1BFX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSk7XG59XG5cbmZ1bmN0aW9uIHR5cGVPZihvYmplY3QpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIHZhciAkJHR5cGVvZiA9IG9iamVjdC4kJHR5cGVvZjtcblxuICAgIHN3aXRjaCAoJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICB2YXIgdHlwZSA9IG9iamVjdC50eXBlO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcblxuICAgICAgICAgICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mVHlwZTtcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufSAvLyBBc3luY01vZGUgaXMgZGVwcmVjYXRlZCBhbG9uZyB3aXRoIGlzQXN5bmNNb2RlXG5cbnZhciBBc3luY01vZGUgPSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG52YXIgQ29uY3VycmVudE1vZGUgPSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbnZhciBDb250ZXh0Q29uc3VtZXIgPSBSRUFDVF9DT05URVhUX1RZUEU7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbnZhciBFbGVtZW50ID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xudmFyIEZvcndhcmRSZWYgPSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xudmFyIEZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbnZhciBMYXp5ID0gUkVBQ1RfTEFaWV9UWVBFO1xudmFyIE1lbW8gPSBSRUFDVF9NRU1PX1RZUEU7XG52YXIgUG9ydGFsID0gUkVBQ1RfUE9SVEFMX1RZUEU7XG52YXIgUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xudmFyIFN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xudmFyIFN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbnZhciBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IGZhbHNlOyAvLyBBc3luY01vZGUgc2hvdWxkIGJlIGRlcHJlY2F0ZWRcblxuZnVuY3Rpb24gaXNBc3luY01vZGUob2JqZWN0KSB7XG4gIHtcbiAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlKSB7XG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IHRydWU7IC8vIFVzaW5nIGNvbnNvbGVbJ3dhcm4nXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG5cbiAgICAgIGNvbnNvbGVbJ3dhcm4nXSgnVGhlIFJlYWN0SXMuaXNBc3luY01vZGUoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCAnICsgJ2FuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTcrLiBVcGRhdGUgeW91ciBjb2RlIHRvIHVzZSAnICsgJ1JlYWN0SXMuaXNDb25jdXJyZW50TW9kZSgpIGluc3RlYWQuIEl0IGhhcyB0aGUgZXhhY3Qgc2FtZSBBUEkuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB8fCB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlRFWFRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST1ZJREVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZvcndhcmRSZWYob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRnJhZ21lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTGF6eShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9MQVpZX1RZUEU7XG59XG5mdW5jdGlvbiBpc01lbW8ob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xufVxuZnVuY3Rpb24gaXNQb3J0YWwob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUE9SVEFMX1RZUEU7XG59XG5mdW5jdGlvbiBpc1Byb2ZpbGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N0cmljdE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2Uob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbn1cblxuZXhwb3J0cy5Bc3luY01vZGUgPSBBc3luY01vZGU7XG5leHBvcnRzLkNvbmN1cnJlbnRNb2RlID0gQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLkNvbnRleHRDb25zdW1lciA9IENvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuQ29udGV4dFByb3ZpZGVyID0gQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5FbGVtZW50ID0gRWxlbWVudDtcbmV4cG9ydHMuRm9yd2FyZFJlZiA9IEZvcndhcmRSZWY7XG5leHBvcnRzLkZyYWdtZW50ID0gRnJhZ21lbnQ7XG5leHBvcnRzLkxhenkgPSBMYXp5O1xuZXhwb3J0cy5NZW1vID0gTWVtbztcbmV4cG9ydHMuUG9ydGFsID0gUG9ydGFsO1xuZXhwb3J0cy5Qcm9maWxlciA9IFByb2ZpbGVyO1xuZXhwb3J0cy5TdHJpY3RNb2RlID0gU3RyaWN0TW9kZTtcbmV4cG9ydHMuU3VzcGVuc2UgPSBTdXNwZW5zZTtcbmV4cG9ydHMuaXNBc3luY01vZGUgPSBpc0FzeW5jTW9kZTtcbmV4cG9ydHMuaXNDb25jdXJyZW50TW9kZSA9IGlzQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLmlzQ29udGV4dENvbnN1bWVyID0gaXNDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLmlzQ29udGV4dFByb3ZpZGVyID0gaXNDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbmV4cG9ydHMuaXNGb3J3YXJkUmVmID0gaXNGb3J3YXJkUmVmO1xuZXhwb3J0cy5pc0ZyYWdtZW50ID0gaXNGcmFnbWVudDtcbmV4cG9ydHMuaXNMYXp5ID0gaXNMYXp5O1xuZXhwb3J0cy5pc01lbW8gPSBpc01lbW87XG5leHBvcnRzLmlzUG9ydGFsID0gaXNQb3J0YWw7XG5leHBvcnRzLmlzUHJvZmlsZXIgPSBpc1Byb2ZpbGVyO1xuZXhwb3J0cy5pc1N0cmljdE1vZGUgPSBpc1N0cmljdE1vZGU7XG5leHBvcnRzLmlzU3VzcGVuc2UgPSBpc1N1c3BlbnNlO1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGU7XG5leHBvcnRzLnR5cGVPZiA9IHR5cGVPZjtcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-is/cjs/react-is.development.js\n"));

/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ \"./node_modules/react-is/cjs/react-is.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLGdJQUF5RDtBQUMzRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanM/YjMxMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-is/index.js\n"));

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-runtime.development.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-runtime.development.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_MODULE_REFERENCE;\n\n{\n  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n}\n\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      // eslint-disable-next-line no-fallthrough\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if ( !fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n    return type;\n  }\n} // $FlowFixMe only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner$1.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement$1(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement$1(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object') {\n      return;\n    }\n\n    if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else if (node) {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement$1(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement$1(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement$1(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement$1(null);\n    }\n  }\n}\n\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n// even with the prod transform. This means that jsxDEV is purely\n// opt-in behavior for better messages but that we won't stop\n// giving you warnings if you use production apis.\n\nfunction jsxWithValidationStatic(type, props, key) {\n  {\n    return jsxWithValidation(type, props, key, true);\n  }\n}\nfunction jsxWithValidationDynamic(type, props, key) {\n  {\n    return jsxWithValidation(type, props, key, false);\n  }\n}\n\nvar jsx =  jsxWithValidationDynamic ; // we may want to special case jsxs internally to take advantage of static children.\n// for now we can ship identical prod functions\n\nvar jsxs =  jsxWithValidationStatic ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsx = jsx;\nexports.jsxs = jsxs;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7O0FBRUEsWUFBWSxtQkFBTyxDQUFDLDRDQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQzs7QUFFckMsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUEsZ0NBQWdDOztBQUVoQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkhBQTJIO0FBQzNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0VBQW9FOztBQUVwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7O0FBRUE7O0FBRUEsZ0JBQWdCO0FBQ2hCLFdBQVc7QUFDWCxZQUFZO0FBQ1osR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/MmZjMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7IC8vIFRyYWNrIHdoaWNoIEZpYmVyKHMpIHNjaGVkdWxlIHJlbmRlciB3b3JrLlxuXG52YXIgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRTtcblxue1xuICBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QubW9kdWxlLnJlZmVyZW5jZScpO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFIHx8IHR5cGUuZ2V0TW9kdWxlSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lO1xuXG4gIGlmIChkaXNwbGF5TmFtZSkge1xuICAgIHJldHVybiBkaXNwbGF5TmFtZTtcbiAgfVxuXG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWU7XG59IC8vIEtlZXAgaW4gc3luYyB3aXRoIHJlYWN0LXJlY29uY2lsZXIvZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlclxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufSAvLyBOb3RlIHRoYXQgdGhlIHJlY29uY2lsZXIgcGFja2FnZSBzaG91bGQgZ2VuZXJhbGx5IHByZWZlciB0byB1c2UgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcigpIGluc3RlYWQuXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICggIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVcblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfVxuXG4gICAgICBmbigpO1xuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vKlxuICogVGhlIGAnJyArIHZhbHVlYCBwYXR0ZXJuICh1c2VkIGluIGluIHBlcmYtc2Vuc2l0aXZlIGNvZGUpIHRocm93cyBmb3IgU3ltYm9sXG4gKiBhbmQgVGVtcG9yYWwuKiB0eXBlcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzIyMDY0LlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgd2lsbCB0aHJvdyBhbiBlYXNpZXItdG8tdW5kZXJzdGFuZCxcbiAqIGVhc2llci10by1kZWJ1ZyBleGNlcHRpb24gd2l0aCBhIGNsZWFyIGVycm9ycyBtZXNzYWdlIG1lc3NhZ2UgZXhwbGFpbmluZyB0aGVcbiAqIHByb2JsZW0uIChJbnN0ZWFkIG9mIGEgY29uZnVzaW5nIGV4Y2VwdGlvbiB0aHJvd24gaW5zaWRlIHRoZSBpbXBsZW1lbnRhdGlvblxuICogb2YgdGhlIGB2YWx1ZWAgb2JqZWN0KS5cbiAqL1xuLy8gJEZsb3dGaXhNZSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cbmZ1bmN0aW9uIHR5cGVOYW1lKHZhbHVlKSB7XG4gIHtcbiAgICAvLyB0b1N0cmluZ1RhZyBpcyBuZWVkZWQgZm9yIG5hbWVzcGFjZWQgdHlwZXMgbGlrZSBUZW1wb3JhbC5JbnN0YW50XG4gICAgdmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWc7XG4gICAgdmFyIHR5cGUgPSBoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ09iamVjdCc7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbnZhciBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bjtcbnZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZikge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IHNlbGYpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5cbmZ1bmN0aW9uIGpzeERFVih0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIHtcbiAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcblxuICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAgIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG5cbiAgICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wVHlwZXM7XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7IC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG5cbiAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcblxuICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYodHlwZSwgcHJvcHMsIGtleSwgc291cmNlLCBzZWxmKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG5cbiAgICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2ldLCB0eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yKCdSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiAnICsgJ1lvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gJyArICdVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufSAvLyBUaGVzZSB0d28gZnVuY3Rpb25zIGV4aXN0IHRvIHN0aWxsIGdldCBjaGlsZCB3YXJuaW5ncyBpbiBkZXZcbi8vIGV2ZW4gd2l0aCB0aGUgcHJvZCB0cmFuc2Zvcm0uIFRoaXMgbWVhbnMgdGhhdCBqc3hERVYgaXMgcHVyZWx5XG4vLyBvcHQtaW4gYmVoYXZpb3IgZm9yIGJldHRlciBtZXNzYWdlcyBidXQgdGhhdCB3ZSB3b24ndCBzdG9wXG4vLyBnaXZpbmcgeW91IHdhcm5pbmdzIGlmIHlvdSB1c2UgcHJvZHVjdGlvbiBhcGlzLlxuXG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvblN0YXRpYyh0eXBlLCBwcm9wcywga2V5KSB7XG4gIHtcbiAgICByZXR1cm4ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgdHJ1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uRHluYW1pYyh0eXBlLCBwcm9wcywga2V5KSB7XG4gIHtcbiAgICByZXR1cm4ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgZmFsc2UpO1xuICB9XG59XG5cbnZhciBqc3ggPSAganN4V2l0aFZhbGlkYXRpb25EeW5hbWljIDsgLy8gd2UgbWF5IHdhbnQgdG8gc3BlY2lhbCBjYXNlIGpzeHMgaW50ZXJuYWxseSB0byB0YWtlIGFkdmFudGFnZSBvZiBzdGF0aWMgY2hpbGRyZW4uXG4vLyBmb3Igbm93IHdlIGNhbiBzaGlwIGlkZW50aWNhbCBwcm9kIGZ1bmN0aW9uc1xuXG52YXIganN4cyA9ICBqc3hXaXRoVmFsaWRhdGlvblN0YXRpYyA7XG5cbmV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuZXhwb3J0cy5qc3ggPSBqc3g7XG5leHBvcnRzLmpzeHMgPSBqc3hzO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react-jsx-runtime.development.js\n"));

/***/ }),

/***/ "./node_modules/react/jsx-runtime.js":
/*!*******************************************!*\
  !*** ./node_modules/react/jsx-runtime.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-runtime.development.js */ \"./node_modules/react/cjs/react-jsx-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LXJ1bnRpbWUuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLCtJQUFrRTtBQUNwRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LXJ1bnRpbWUuanM/MzRkMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react/jsx-runtime.js\n"));

/***/ })

}]);